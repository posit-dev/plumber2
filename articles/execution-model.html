<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Runtime • plumber2</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Runtime">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">plumber2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/quickstart.html">1. Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/routing-and-input.html">2. Routing &amp; Input</a></li>
    <li><a class="dropdown-item" href="../articles/rendering-output.html">3. Rendering output</a></li>
    <li><a class="dropdown-item" href="../articles/execution-model.html">4. Runtime</a></li>
    <li><a class="dropdown-item" href="../articles/hosting.html">5. Hosting</a></li>
    <li><a class="dropdown-item" href="../articles/programmatic-usage.html">6. Programmatic usage</a></li>
    <li><a class="dropdown-item" href="../articles/annotations.html">7. Annotation Reference</a></li>
    <li><a class="dropdown-item" href="../articles/security.html">8. Security</a></li>
    <li><a class="dropdown-item" href="../articles/tips-and-tricks.html">9. Tips &amp; Tricks</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Runtime</h1>
            
      

      <div class="d-none name"><code>execution-model.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="execution-model">Execution Model<a class="anchor" aria-label="anchor" href="#execution-model"></a>
</h2>
<p>When you <code>plumb()</code> a file, Plumber calls
<code><a href="https://rdrr.io/r/base/source.html" class="external-link">source()</a></code> on that file which will evaluate any top-level
code that you have defined.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Global code; gets executed at plumb() time.</span></span>
<span><span class="va">counter</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span></span>
<span><span class="co">#* @get /</span></span>
<span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Only gets evaluated when this endpoint is requested.</span></span>
<span>  <span class="va">counter</span> <span class="op">&lt;&lt;-</span> <span class="va">counter</span> <span class="op">+</span> <span class="fl">1</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>If you include this file in a call to <code><a href="../reference/api.html">api()</a></code>, the
<code>counter</code> variable will be created and will live in the
environment created for this API route. However, the endpoint defined
will not be evaluated until it is invoked in response to an incoming
request. Because the endpoint uses <code>&lt;&lt;-</code>, the
“double-assignment” operator, it mutates the <code>counter</code>
variable that was previously defined when the file was parsed. This
technique allows all endpoints and filters to share some data defined at
the top-level of your API.</p>
</div>
<div class="section level2">
<h2 id="environments">Environments<a class="anchor" aria-label="anchor" href="#environments"></a>
</h2>
<p>When you create a plumber API using <code><a href="../reference/api.html">api()</a></code> you can
provide an environment to the <code>env</code> argument. By default the
calling environment (often the global environment) is used. This
environment will be used as the parent environment when parsing files,
but each file will be parsed in it’s own environment to avoid
interfering with each other. This means that you cannot share objects
between files. If handlers from different files need to access the same
data it is a sign that you need a more advanced data store than an
object defined in the plumber file.</p>
</div>
<div class="section level2">
<h2 id="performance-request-processing">Performance &amp; Request Processing<a class="anchor" aria-label="anchor" href="#performance-request-processing"></a>
</h2>
<p>R is a single-threaded programming language, meaning that it can only
do one task at a time. This is still true when serving APIs using
Plumber, so if you have a single endpoint that takes two seconds to
generate a response, then every time that endpoint is requested, your R
process will be unable to respond to any additional incoming requests
for those two seconds.</p>
<p>Incoming HTTP requests are serviced in the order in which they
appeared, but if requests are coming in more quickly than they can be
processed by the API, a backlog of requests will accrue. The common
solutions to this problem are to do either or both of:</p>
<ol style="list-style-type: decimal">
<li>Keep your API performant. All filters and endpoints should complete
very quickly and any long-running or complicated tasks should be done
outside of the API process.</li>
<li>Run multiple R processes to redundantly host a single Plumber API
and load-balance incoming requests between all available processes. See
the <a href="./hosting.html">hosting section</a> for details on which
hosting environments support this feature.</li>
</ol>
</div>
<div class="section level2">
<h2 id="managing-state">Managing State<a class="anchor" aria-label="anchor" href="#managing-state"></a>
</h2>
<p>Often, Plumber APIs will require coordination of some state. This
state may need to be shared between multiple endpoints in the same API
(e.g. a counter that increments every time an endpoint is invoked).
Alternatively, it could be information that needs to be persisted across
requests from a single client (e.g. storing a preference or setting for
some user). Lastly, it might require coordinating between multiple
Plumber processes running independently behind a load-balancer. Each of
these scenarios have unique properties that determine which solution
might be appropriate.</p>
<p>As previously discussed, R is single-threaded. Therefore it’s
important that you consider the fact that you may eventually need
multiple R processes running in parallel to handle the incoming traffic
of your API. While this may not seem important initially, you may thank
yourself later for designing a “horizontally scalable” API (or one that
can be scaled by adding more R processes in parallel).</p>
<p>The key to building a horizontally scalable API is to ensure that
each Plumber process is “stateless,” meaning that any persistent state
lives outside of the Plumber process. In any of the hosting environments
that exist today, it is not guaranteed that two subsequent requests from
a single client will be served by the same process. Thus it’s never safe
to assume that information stored in-memory will be available between
requests for a horizontally scaled app. Below are a few options to
consider to coordinate state for a Plumber API.</p>
<div class="section level3">
<h3 id="in-memory">In-Memory<a class="anchor" aria-label="anchor" href="#in-memory"></a>
</h3>
<p>As shown previous in the <a href="#execution-model">Execution Model
section</a>, it is possible to share state using the environment
associated with the Plumber router.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Global code; gets executed at plumb() time.</span></span>
<span><span class="va">counter</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span></span>
<span><span class="co">#* @get /</span></span>
<span><span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Only gets evaluated when this endpoint is requested.</span></span>
<span>  <span class="va">counter</span> <span class="op">&lt;&lt;-</span> <span class="va">counter</span> <span class="op">+</span> <span class="fl">1</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>This is the one approach presented that does not allow your Plumber
process to be stateless. The approach is sufficient for coordinating
state within a single route in a single process, but as you scale your
API by adding processes or routes, this state will no longer be
coordinated between them.</p>
<p>Therefore this approach can be effective for “read-only” data – such
as if you were to load a single, large dataset into memory when the API
starts, then allow all filters and endpoints to reference that dataset
moving forward – but it will not allow you to share state across
multiple processes as you scale. If you want to build a scalable,
stateless application, you should avoid relying on the in-memory R
environment to coordinate state between the pieces of your API.</p>
</div>
<div class="section level3">
<h3 id="file-system">File System<a class="anchor" aria-label="anchor" href="#file-system"></a>
</h3>
<p>Writing to files on disk is often the next most obvious choice for
storing state. Plumber APIs could modify a data frame then use
<code><a href="https://rdrr.io/r/utils/write.table.html" class="external-link">write.csv()</a></code> to save that data to disk, or use
<code><a href="https://rdrr.io/r/base/writeLines.html" class="external-link">writeLines()</a></code> to append some new data to an existing file.
These approaches enable your R process to be stateless, but are not
always resilient to concurrency issues. For instance, if you’ve
horizontally scaled your API to five R processes and two go to
<code><a href="https://rdrr.io/r/utils/write.table.html" class="external-link">write.csv()</a></code> simultaneously, you will either see one
process’s data get immediately overwritten by the other’s, or – even
worse – you may end up with a corrupted CSV file which can’t be read.
Unless otherwise stated, it’s safe to assume that any R function that
writes data to disk is not resilient to concurrency contention, so you
should not rely on the filesystem to coordinate shared state for any
more than a single R process running concurrently.</p>
<p>It’s also important to ask whether or not the <a href="./hosting.html">hosting platform</a> you’ll be using supports
persistent storage on disk. For instance, Docker may insulate your R
process from your hardware and not allow you to write outside of your
container. RStudio Connect, too, will provision a new directory every
time you deploy an updated version of your API which will discard any
data you had written to disk up to that point. So if you’re considering
writing your state to disk long-term, be sure that your hosting
environment supports persistent on-disk storage and that you’ve
considered the concurrency implications of your code.</p>
</div>
<div class="section level3">
<h3 id="state-cookies">Cookies<a class="anchor" aria-label="anchor" href="#state-cookies"></a>
</h3>
<p>HTTP cookies are a convention that allow web servers to send some
state to a client with the expectation that the client would then
include that state in future requests. See the <a href="./rendering-output.html#setting-cookies">Setting Cookies
section</a> for details on how to leverage cookies in Plumber.</p>
<p>All modern web browsers support cookies (unless configured not to)
and many other clients do, as well, though some clients require
additional configuration in order to do so. If you’re confident that the
intended clients for your API support cookies then you could consider
storing some state in cookies. This approach mitigates concerns about
horizontal scalability, as the state is written to each client
independently and then included in subsequent requests from that client.
This also minimizes the infrastructure requirements for hosting your
Plumber APIs since you don’t need to setup a system capable of storing
all of this state; instead, you’ve commissioned your clients to store
their own state.</p>
<p>One issue with maintaining state in cookies is that their size should
be kept to a minimum. Clients impose restrictions differently, but you
should not plan to store more than 4kB of information in a cookie. And
realize that whatever information gets placed in the cookie must be
retransmitted by the client with <em>every</em> request. This can
significantly increase the size of each HTTP request that your clients
make.</p>
<p>The most notable concern when considering using cookies to store
state is that since your clients are responsible for storing and sending
their state, you cannot expect that the state has not been tampered
with. Thus, while it may be acceptable to store user preferences like
<code>preferredColor="blue"</code>, you should <em>not</em> store
authentication information like <code>userID=1493</code>, since the user
could trivially change that cookie to another user’s ID to impersonate
them.</p>
<p>If you’d like to use cookies to store information with guarantees
that the user cannot either read or modify the state, see the <a href="./rendering-output.html#encrypted-cookies">Encrypted Cookies
section</a>).</p>
</div>
<div class="section level3">
<h3 id="external-data-store">External Data Store<a class="anchor" aria-label="anchor" href="#external-data-store"></a>
</h3>
<p>The final option to consider when coordinating state for an API is
leveraging an external data store. This could be a relational database
(like MySQL or Amazon RedShift), a non-relational database (like
MongoDB), or an transactional data store like Redis.</p>
<p>One important consideration for any of these options is to ensure
that they are “transactional,” meaning that two Plumber processes trying
to write at the same time won’t overwrite one another. If you’re
interested in pursuing this option you should see <a href="https://solutions.rstudio.com/db/" class="external-link">solutions.rstudio.com/db/</a>
or look at <a href="http://shiny.rstudio.com/articles/overview.html" class="external-link">some</a> of the
<a href="http://shiny.rstudio.com/articles/sql-injections.html" class="external-link">resources</a>
<a href="http://shiny.rstudio.com/articles/pool-basics.html" class="external-link">put
together</a> for Shiny as pertains to dealing with databases in a
web-accessible R platform.</p>
</div>
</div>
<div class="section level2">
<h2 id="exit-handlers">Exit Handlers<a class="anchor" aria-label="anchor" href="#exit-handlers"></a>
</h2>
<p>It may be useful to define a function that you want to run as your
API is closing – for instance, if you have a pool of database
connections that need to be cleaned up when your Plumber process is
being terminated. You can add a handler to the <code>"end"</code> event
to do this.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/api.html">api</a></span><span class="op">(</span><span class="st">"plumber.R"</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/api_on.html">api_on</a></span><span class="op">(</span><span class="st">"end"</span>, <span class="kw">function</span><span class="op">(</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="st">"Bye bye!"</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/api_run.html">api_run</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>When you interrupt the API (for instance by pressing
<code>Ctrl+C</code> (for blocking sessions) or calling
<code><a href="../reference/api_run.html">api_stop()</a></code> (for non-blocking sessions)) you’ll see
<code>Bye bye!</code> printed to the console. You can even register
multiple <code>end</code> handlers and they’ll be run in the order in
which they were registered.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Thomas Lin Pedersen.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
