[{"path":[]},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://plumber2.posit.co/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://plumber2.posit.co/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Posit, PBC Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations","dir":"Articles","previous_headings":"","what":"Annotations","title":"Annotations reference","text":"Annotations specially-structured comments used plumber file create API. full annotation line starts #*, annotation keyword @..., number space characters followed content. wish use annotation document API file don’t want OpenAPI documentation generated can use @noDoc tag works much like roxygens @noRd.","code":""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotation-settings","dir":"Articles","previous_headings":"","what":"Annotation settings","title":"Annotations reference","text":"annotations modify file parsed interpreted. must appear first block file (case @roxygenPrefix first line). default, plumber2 uses #* prefix blocks avoid clashing roxygen comments. plumber (old one) allowed either recommended differentiate roxygen plumber2 annotations can opt also understanding roxygen prefix. tag must appear first line file effect. wish always allow roxygen prefixes can set plumber2.roxygenPrefix option TRUE direct equivalent programmatic usage pertains parsing plumber file. default, name file (without extension) used name route handlers etc attached . However, can change first block file @routeName tag specifying name use route specific blocks file. also makes possible split specification single route among multiple files begins grow unwieldy direct equivalent programmatic usage pertains parsing plumber file. relevant function route argument can specify route add given functionality . Route files processed alphanumerical order influence order route attached. can modify route order (file processing order) using @routeOrder tag. multiple files @routeName lowest @routeOrder value used. file without @routeOrder tag added , using default alphanumeric order. can programmatically control location route add api_add_route() using argument. Many annotations somehow references URL paths, either endpoint handler, serve shiny app . can set root whole file prepended relevant URL. way easy move functionality single file different location necessary. can programmatically set root new route add api_add_route() using root argument.","code":"#* @roxygenPrefix NULL #* @routeName main_route NULL #* @routeOrder 3 NULL #* @root /path/to/these/apis NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"use-roxygen-prefix","dir":"Articles","previous_headings":"","what":"Use roxygen prefix","title":"Annotations reference","text":"default, plumber2 uses #* prefix blocks avoid clashing roxygen comments. plumber (old one) allowed either recommended differentiate roxygen plumber2 annotations can opt also understanding roxygen prefix. tag must appear first line file effect. wish always allow roxygen prefixes can set plumber2.roxygenPrefix option TRUE direct equivalent programmatic usage pertains parsing plumber file.","code":"#* @roxygenPrefix NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @roxygenPrefix NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"direct equivalent programmatic usage pertains parsing plumber file.","code":""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"specifying-route-name","dir":"Articles","previous_headings":"","what":"Specifying route name","title":"Annotations reference","text":"default, name file (without extension) used name route handlers etc attached . However, can change first block file @routeName tag specifying name use route specific blocks file. also makes possible split specification single route among multiple files begins grow unwieldy direct equivalent programmatic usage pertains parsing plumber file. relevant function route argument can specify route add given functionality .","code":"#* @routeName main_route NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example-1","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @routeName main_route NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-1","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"direct equivalent programmatic usage pertains parsing plumber file. relevant function route argument can specify route add given functionality .","code":""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"specifying-route-order","dir":"Articles","previous_headings":"","what":"Specifying route order","title":"Annotations reference","text":"Route files processed alphanumerical order influence order route attached. can modify route order (file processing order) using @routeOrder tag. multiple files @routeName lowest @routeOrder value used. file without @routeOrder tag added , using default alphanumeric order. can programmatically control location route add api_add_route() using argument.","code":"#* @routeOrder 3 NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example-2","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @routeOrder 3 NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-2","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"can programmatically control location route add api_add_route() using argument.","code":""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"specifying-root-url-for-the-whole-file","dir":"Articles","previous_headings":"","what":"Specifying root url for the whole file","title":"Annotations reference","text":"Many annotations somehow references URL paths, either endpoint handler, serve shiny app . can set root whole file prepended relevant URL. way easy move functionality single file different location necessary. can programmatically set root new route add api_add_route() using root argument.","code":"#* @root /path/to/these/apis NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example-3","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @root /path/to/these/apis NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-3","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"can programmatically set root new route add api_add_route() using root argument.","code":""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"global-annotations","dir":"Articles","previous_headings":"","what":"Global annotations","title":"Annotations reference","text":"Global annotations related handler placed block. block terminated \"_API\" expression. Instead @title @description can also use convention first line gives title proceeding lines first tag gives description.","code":"#* Sample Pet Store App #* #* This is a sample server for a pet store. #* #* @tos http://example.com/terms/ #* @contact list(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\") #* @license list(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\") #* @version 1.0.1 #* @tag pet Pets operations #* @tag toy Toys operations #* @tag \"toy space\" Toys operations \"_API\" api() |>   api_doc_add(     openapi(     info = openapi_info(       title = \"Sample Pet Store App\",       description = \"This is a sample server for a pet store.\",       terms_of_service = \"http://example.com/terms/\",       contact = openapi_contact(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\"),       license = openapi_license(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\"),       version = \"1.0.1\"     ),     tags = list(       openapi_tag(name = \"pet\", description = \"Pets operations\"),       openapi_tag(name = \"toy\", description = \"Toys operations\"),       openapi_tag(name = \"toy space\", description = \"Toys operations\")     )   ))"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example-4","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* Sample Pet Store App #* #* This is a sample server for a pet store. #* #* @tos http://example.com/terms/ #* @contact list(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\") #* @license list(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\") #* @version 1.0.1 #* @tag pet Pets operations #* @tag toy Toys operations #* @tag \"toy space\" Toys operations \"_API\""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-4","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"api() |>   api_doc_add(     openapi(     info = openapi_info(       title = \"Sample Pet Store App\",       description = \"This is a sample server for a pet store.\",       terms_of_service = \"http://example.com/terms/\",       contact = openapi_contact(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\"),       license = openapi_license(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\"),       version = \"1.0.1\"     ),     tags = list(       openapi_tag(name = \"pet\", description = \"Pets operations\"),       openapi_tag(name = \"toy\", description = \"Toys operations\"),       openapi_tag(name = \"toy space\", description = \"Toys operations\")     )   ))"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"handler-annotations","dir":"Articles","previous_headings":"","what":"Handler annotations","title":"Annotations reference","text":"Handler annotation describe aspects request handler always proceeds function considered handler function. following tags can used handler block. first line, unless tag considered title handler proceeding lines first tag considered long-form description. Annotation Argument Description/References @get, @head, @post, @put, @delete, @connect, @options, @trace, @patch, @Path Endpoints, Dynamic Routes, Typed Dynamic Routes @header None handler attached header router @serializer Alias[{Args list]}] Mime Function serializers accept arguments. See serializers article serializers reference. Aliases : r paste0(“<code>”, registered_serializers(), “<\/code>”, collapse = “,”) registered_serializers(). @serializerStrict None Turn strict content negotiation. default, first serializer chosen client requests response type isnt supported. using strict content negotiation 406 response sent requested response type available @parser Alias[{Args list}] Mime Function parsers accept arguments. See parsers reference. Can repeated allow multiple parsers endpoint. Aliases : r paste0(“<code>”, registered_parsers(), “<\/code>”, collapse = “,”) registered_parsers(). @param, @query, @body Name[:Type][(Default)][*][Description] Adding asterix indicates parameter required. Can repeated define different parameters. single @body tag used Name can omitted indicate body named object simply instance given Type @response Status[:Type] Description Simple Response object. Can repeated define different responses. @download [Filename] Mark response something downloaded, optionally setting default filename file @tag Tag Can repeated add multiple tags. Quote use non word character (like spaces) Tag. Tag field @message None Marks handler WebSocket message handler. tags effect tag present (except @async) @async [engine] Marks handler running asynchronously. default uses mirai, different registered engine can specified well @None Chains handler preceeding message request handler handler asynchronous @cors [Origin] Add CORS endpoints handler. Origin can comma separated list allowed origins @rip [Allowed Site] Adds resource isolation policy get endpoints handler. Allowed Site can used change allowance level @noDoc None Dont generate OpenAPI documentation block Types used define API inputs outputs. path parameters can given @param inside handler path. given places must agreement. query body parameters given respective @query @body tags. types can nested structure also supported, type spec can quickly become difficult read recurse use care Types can default value, given parentheses type specification, e.g. integer(10). objects arrays use JSON notation describe default value (e.g. [integer]([2, 6, 1])). integer number types also possible specify lower /upper bounds value. done putting | like : integer|3, 7|. Omitting one remove bound requirement (e.g. integer|,7| requires input equal 7). combining default value range comes first (integer|3,7|(5)). enum type factor type must provide valid values type |, separated comma optional whitespace. pattern type string type must match regular expression given |. date date-time types require use specific format date time described RFC 3339, section 5.6. date must given full-date notation, e.g. 2017-07-21 date-time must given date-time notation, e.g. 2017-07-21T17:32:28Z parameters can specified optional required type notation. Path parameters always required setting ignored . parameter can marked required adding * suffix type description, e.g. arg1:integer* indicate arg1 required integer. parameter required default value (reasons logic). Apart used documentation API, type information provide parameters also used cast incoming values correct type add defaults missing. , missing required parameters result error. response type checked conform specification provide.","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL } text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = openapi_operation(       parameters = list(         openapi_parameter(           name = \"name\",           location = \"query\",           required = TRUE,           schema = openapi_schema(character())         ),         openapi_parameter(           name = \"age\",           location = \"query\",           required = TRUE,           schema = openapi_schema(integer())         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = openapi_operation(       responses = list(          \"200\" = openapi_response(           description = \"A sentence\",           content = openapi_content(             \"text/plain\" = openapi_schema(character())           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = openapi_operation(       description = \"Upload an rds file and return the object\",       request_body = openapi_request_body(         content = openapi_content(           \"multipart/form-data\" = openapi_schema(list(file = raw()))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"endpoint-block-annotations","dir":"Articles","previous_headings":"","what":"Endpoint","title":"Annotations reference","text":"Annotation Argument Description/References @get, @head, @post, @put, @delete, @connect, @options, @trace, @patch, @Path Endpoints, Dynamic Routes, Typed Dynamic Routes @header None handler attached header router @serializer Alias[{Args list]}] Mime Function serializers accept arguments. See serializers article serializers reference. Aliases : r paste0(“<code>”, registered_serializers(), “<\/code>”, collapse = “,”) registered_serializers(). @serializerStrict None Turn strict content negotiation. default, first serializer chosen client requests response type isnt supported. using strict content negotiation 406 response sent requested response type available @parser Alias[{Args list}] Mime Function parsers accept arguments. See parsers reference. Can repeated allow multiple parsers endpoint. Aliases : r paste0(“<code>”, registered_parsers(), “<\/code>”, collapse = “,”) registered_parsers(). @param, @query, @body Name[:Type][(Default)][*][Description] Adding asterix indicates parameter required. Can repeated define different parameters. single @body tag used Name can omitted indicate body named object simply instance given Type @response Status[:Type] Description Simple Response object. Can repeated define different responses. @download [Filename] Mark response something downloaded, optionally setting default filename file @tag Tag Can repeated add multiple tags. Quote use non word character (like spaces) Tag. Tag field @message None Marks handler WebSocket message handler. tags effect tag present (except @async) @async [engine] Marks handler running asynchronously. default uses mirai, different registered engine can specified well @None Chains handler preceeding message request handler handler asynchronous @cors [Origin] Add CORS endpoints handler. Origin can comma separated list allowed origins @rip [Allowed Site] Adds resource isolation policy get endpoints handler. Allowed Site can used change allowance level @noDoc None Dont generate OpenAPI documentation block Types used define API inputs outputs. path parameters can given @param inside handler path. given places must agreement. query body parameters given respective @query @body tags. types can nested structure also supported, type spec can quickly become difficult read recurse use care Types can default value, given parentheses type specification, e.g. integer(10). objects arrays use JSON notation describe default value (e.g. [integer]([2, 6, 1])). integer number types also possible specify lower /upper bounds value. done putting | like : integer|3, 7|. Omitting one remove bound requirement (e.g. integer|,7| requires input equal 7). combining default value range comes first (integer|3,7|(5)). enum type factor type must provide valid values type |, separated comma optional whitespace. pattern type string type must match regular expression given |. date date-time types require use specific format date time described RFC 3339, section 5.6. date must given full-date notation, e.g. 2017-07-21 date-time must given date-time notation, e.g. 2017-07-21T17:32:28Z parameters can specified optional required type notation. Path parameters always required setting ignored . parameter can marked required adding * suffix type description, e.g. arg1:integer* indicate arg1 required integer. parameter required default value (reasons logic). Apart used documentation API, type information provide parameters also used cast incoming values correct type add defaults missing. , missing required parameters result error. response type checked conform specification provide.","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL } text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = openapi_operation(       parameters = list(         openapi_parameter(           name = \"name\",           location = \"query\",           required = TRUE,           schema = openapi_schema(character())         ),         openapi_parameter(           name = \"age\",           location = \"query\",           required = TRUE,           schema = openapi_schema(integer())         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = openapi_operation(       responses = list(          \"200\" = openapi_response(           description = \"A sentence\",           content = openapi_content(             \"text/plain\" = openapi_schema(character())           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = openapi_operation(       description = \"Upload an rds file and return the object\",       request_body = openapi_request_body(         content = openapi_content(           \"multipart/form-data\" = openapi_schema(list(file = raw()))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"more-details-on-type","dir":"Articles","previous_headings":"","what":"More details on Type","title":"Annotations reference","text":"Types used define API inputs outputs. path parameters can given @param inside handler path. given places must agreement. query body parameters given respective @query @body tags. types can nested structure also supported, type spec can quickly become difficult read recurse use care Types can default value, given parentheses type specification, e.g. integer(10). objects arrays use JSON notation describe default value (e.g. [integer]([2, 6, 1])). integer number types also possible specify lower /upper bounds value. done putting | like : integer|3, 7|. Omitting one remove bound requirement (e.g. integer|,7| requires input equal 7). combining default value range comes first (integer|3,7|(5)). enum type factor type must provide valid values type |, separated comma optional whitespace. pattern type string type must match regular expression given |. date date-time types require use specific format date time described RFC 3339, section 5.6. date must given full-date notation, e.g. 2017-07-21 date-time must given date-time notation, e.g. 2017-07-21T17:32:28Z parameters can specified optional required type notation. Path parameters always required setting ignored . parameter can marked required adding * suffix type description, e.g. arg1:integer* indicate arg1 required integer. parameter required default value (reasons logic). Apart used documentation API, type information provide parameters also used cast incoming values correct type add defaults missing. , missing required parameters result error. response type checked conform specification provide.","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL } text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = openapi_operation(       parameters = list(         openapi_parameter(           name = \"name\",           location = \"query\",           required = TRUE,           schema = openapi_schema(character())         ),         openapi_parameter(           name = \"age\",           location = \"query\",           required = TRUE,           schema = openapi_schema(integer())         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = openapi_operation(       responses = list(          \"200\" = openapi_response(           description = \"A sentence\",           content = openapi_content(             \"text/plain\" = openapi_schema(character())           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = openapi_operation(       description = \"Upload an rds file and return the object\",       request_body = openapi_request_body(         content = openapi_content(           \"multipart/form-data\" = openapi_schema(list(file = raw()))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example-5","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-5","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = openapi_operation(       parameters = list(         openapi_parameter(           name = \"name\",           location = \"query\",           required = TRUE,           schema = openapi_schema(character())         ),         openapi_parameter(           name = \"age\",           location = \"query\",           required = TRUE,           schema = openapi_schema(integer())         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = openapi_operation(       responses = list(          \"200\" = openapi_response(           description = \"A sentence\",           content = openapi_content(             \"text/plain\" = openapi_schema(character())           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = openapi_operation(       description = \"Upload an rds file and return the object\",       request_body = openapi_request_body(         content = openapi_content(           \"multipart/form-data\" = openapi_schema(list(file = raw()))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"static-block-annotations","dir":"Articles","previous_headings":"","what":"Asset annotation","title":"Annotations reference","text":"two ways serve static content plumber2 differ subtle ways. @assets tag instruct plumber create regular handler matches mount path (defaults /) serve files Path. @statics tag works , rather create handler instructs httpuv (low-level package powering plumber2) serve files request even reaches R process. makes much faster also limited flexibility since request never reaches code unable modify . general, use @statics unless need provide additional handling request, authentication logging.","code":"#* @assets ./assets/files NULL  #* @assets ./assets/files /assets NULL  #* @statics ./assets/static_files #* @except /secret_files NULL api() %>%   api_assets(\"/\", \"./assets/files\")  api() %>%   api_assets(\"/assets\", \"./assets/files\")  api() %>%   api_statics(\"/\", \"./assets/static_files\", except = \"/secret_files\")"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example-6","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @assets ./assets/files NULL  #* @assets ./assets/files /assets NULL  #* @statics ./assets/static_files #* @except /secret_files NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-note-that-argument-order-is-reversed","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage (note that argument order is reversed)","title":"Annotations reference","text":"","code":"api() %>%   api_assets(\"/\", \"./assets/files\")  api() %>%   api_assets(\"/assets\", \"./assets/files\")  api() %>%   api_statics(\"/\", \"./assets/static_files\", except = \"/secret_files\")"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"plumber-block-annotations","dir":"Articles","previous_headings":"","what":"plumber2 annotation","title":"Annotations reference","text":"","code":"#* @plumber function(api) {   api %>%     api_doc_setting(\"swagger\") }  # Named function use_swagger <- function(api) {   api %>%     api_doc_setting(\"swagger\") }  #* @plumber use_swagger api() |>   api_doc_setting(\"swagger\")"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotations-example-7","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @plumber function(api) {   api %>%     api_doc_setting(\"swagger\") }  # Named function use_swagger <- function(api) {   api %>%     api_doc_setting(\"swagger\") }  #* @plumber use_swagger"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-6","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"api() |>   api_doc_setting(\"swagger\")"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"forwards-and-redirects","dir":"Articles","previous_headings":"","what":"Forwards and redirects","title":"Annotations reference","text":"plumber2 allows orchestrate requests ultimately handled elsewhere. two approaches . Either return redirect response let client follow new location, handle directly forwarding request another origin passing along response client (called reverse proxy). considered somewhat advanced use.","code":"#* @redirect !any old/<path> new/<path> #* @redirect get main/<path> temp/main/<path> NULL  #* @forward proxy/server http://127.0.0.1:56789 NULL api() |>   api_redirect(\"any\", \"old/<path>\", \"new/<path>\", permanent = TRUE) |>   api_redirect(\"get\", \"main/*\", \"temp/main/*\") |>   api_forward(\"proxy/server\", \"http://127.0.0.1:56789\")"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotation-example","dir":"Articles","previous_headings":"","what":"Annotation example","title":"Annotations reference","text":"","code":"#* @redirect !any old/<path> new/<path> #* @redirect get main/<path> temp/main/<path> NULL  #* @forward proxy/server http://127.0.0.1:56789 NULL"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-7","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"api() |>   api_redirect(\"any\", \"old/<path>\", \"new/<path>\", permanent = TRUE) |>   api_redirect(\"get\", \"main/*\", \"temp/main/*\") |>   api_forward(\"proxy/server\", \"http://127.0.0.1:56789\")"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"shiny","dir":"Articles","previous_headings":"","what":"Shiny","title":"Annotations reference","text":"plumber2 can serve one shiny apps specified paths. works launching shiny app defined block separate process forward requests defined path process. shiny app automatically launched stopped along main plumber2 api.","code":"#* @shiny app/ shinyAppDir(\"path/to/shiny/app\") api() |>   api_shiny(\"app/\", shinyAppDir(\"path/to/shiny/app\"))"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotation-example-1","dir":"Articles","previous_headings":"","what":"Annotation example","title":"Annotations reference","text":"","code":"#* @shiny app/ shinyAppDir(\"path/to/shiny/app\")"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-8","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"api() |>   api_shiny(\"app/\", shinyAppDir(\"path/to/shiny/app\"))"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"reports","dir":"Articles","previous_headings":"","what":"Reports","title":"Annotations reference","text":"plumber2 can automatically serve Rmarkdown Quarto reports. report rendered upon request cached future. Different output formats can selected Content-Type request header long matching format specified reports yaml header. Query parameters automatically passed parameters report support parameterized reports natively. Reports can annotated just like standard request handlers OpenAPI documentation generated . Rendering performed asynchronously api blocked someone requesting report takes render Note programmatic usage doesn’t add documentation ","code":"#* Access the quarterly report #* #* @query quarter:enum|spring, summer, autumn, winter| The quarter to generate the report for #* #* @report quarterly/ \"my_amazing_report.qmd\" api() |>   api_add_route(routr::report_route(\"quarterly/\", \"my_amazing_report.qmd\"))"},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"annotation-example-2","dir":"Articles","previous_headings":"","what":"Annotation example","title":"Annotations reference","text":"","code":"#* Access the quarterly report #* #* @query quarter:enum|spring, summer, autumn, winter| The quarter to generate the report for #* #* @report quarterly/ \"my_amazing_report.qmd\""},{"path":"https://plumber2.posit.co/articles/annotations.html","id":"equivalent-programmatic-usage-9","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"Note programmatic usage doesn’t add documentation ","code":"api() |>   api_add_route(routr::report_route(\"quarterly/\", \"my_amazing_report.qmd\"))"},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"execution-model","dir":"Articles","previous_headings":"","what":"Execution Model","title":"Runtime","text":"plumb() file, plumber2 calls source() file evaluate top-level code defined. include file call api(), counter variable created live environment created API route. However, endpoint defined evaluated invoked response incoming request. endpoint uses <<-, “double-assignment” operator, mutates counter variable previously defined file parsed. technique allows endpoints filters share data defined top-level API.","code":"# Global code; gets executed at plumb() time. counter <- 0  #* @get / function() {   # Only gets evaluated when this endpoint is requested.   counter <<- counter + 1 }"},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"environments","dir":"Articles","previous_headings":"","what":"Environments","title":"Runtime","text":"create plumber API using api() can provide environment env argument. default calling environment (often global environment) used. environment used parent environment parsing files, file parsed ’s environment avoid interfering . means share objects files. handlers different files need access data sign need advanced data store object defined plumber file.","code":""},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"performance-request-processing","dir":"Articles","previous_headings":"","what":"Performance & Request Processing","title":"Runtime","text":"R single-threaded programming language, meaning can one task time. still true serving APIs using plumber2, single endpoint takes two seconds generate response, every time endpoint requested, R process unable respond additional incoming requests two seconds. Incoming HTTP requests serviced order appeared, requests coming quickly can processed API, backlog requests accrue. common solutions problem either : Keep API performant. filters endpoints complete quickly long-running complicated tasks done outside API process. Run multiple R processes redundantly host single plumber2 API load-balance incoming requests available processes.","code":""},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"managing-state","dir":"Articles","previous_headings":"","what":"Managing State","title":"Runtime","text":"Often, plumber2 APIs require coordination state. state may need shared multiple endpoints API (e.g. counter increments every time endpoint invoked). Alternatively, information needs persisted across requests single client (e.g. storing preference setting user). Lastly, might require coordinating multiple plumber2 processes running independently behind load-balancer. scenarios unique properties determine solution might appropriate. previously discussed, R single-threaded. Therefore ’s important consider fact may eventually need multiple R processes running parallel handle incoming traffic API. may seem important initially, may thank later designing “horizontally scalable” API (one can scaled adding R processes parallel). key building horizontally scalable API ensure plumber2 process “stateless,” meaning persistent state lives outside plumber2 process. hosting environments exist today, guaranteed two subsequent requests single client served process. Thus ’s never safe assume information stored -memory available requests horizontally scaled app. options consider coordinate state plumber2 API. shown previous Execution Model section, possible share state using environment associated plumber2 router. one approach presented allow plumber2 process stateless. approach sufficient coordinating state within single route single process, scale API adding processes routes, state longer coordinated . Therefore approach can effective “read-” data – load single, large dataset memory API starts, allow filters endpoints reference dataset moving forward – allow share state across multiple processes scale. want build scalable, stateless application, avoid relying -memory R environment coordinate state pieces API. Writing files disk often next obvious choice storing state. plumber2 APIs modify data frame use write.csv() save data disk, use writeLines() append new data existing file. approaches enable R process stateless, always resilient concurrency issues. instance, ’ve horizontally scaled API five R processes two go write.csv() simultaneously, either see one process’s data get immediately overwritten ’s, – even worse – may end corrupted CSV file can’t read. Unless otherwise stated, ’s safe assume R function writes data disk resilient concurrency contention, rely filesystem coordinate shared state single R process running concurrently. ’s also important ask whether hosting platform ’ll using supports persistent storage disk. instance, Docker may insulate R process hardware allow write outside container. RStudio Connect, , provision new directory every time deploy updated version API discard data written disk point. ’re considering writing state disk long-term, sure hosting environment supports persistent -disk storage ’ve considered concurrency implications code. HTTP cookies convention allow web servers send state client expectation client include state future requests. See Setting Cookies section details leverage cookies plumber2. modern web browsers support cookies (unless configured ) many clients , well, though clients require additional configuration order . ’re confident intended clients API support cookies consider storing state cookies. approach mitigates concerns horizontal scalability, state written client independently included subsequent requests client. also minimizes infrastructure requirements hosting plumber2 APIs since don’t need setup system capable storing state; instead, ’ve commissioned clients store state. One issue maintaining state cookies size kept minimum. Clients impose restrictions differently, plan store 4kB information cookie. realize whatever information gets placed cookie must retransmitted client every request. can significantly increase size HTTP request clients make. notable concern considering using cookies store state since clients responsible storing sending state, expect state tampered . Thus, may acceptable store user preferences like preferredColor=\"blue\", store authentication information like userID=1493, since user trivially change cookie another user’s ID impersonate . ’d like use cookies store information guarantees user either read modify state, see Encrypted Cookies section). final option consider coordinating state API leveraging external data store. relational database (like MySQL Amazon RedShift), non-relational database (like MongoDB), transactional data store like Redis. One important consideration options ensure “transactional,” meaning two plumber2 processes trying write time won’t overwrite one another. ’re interested pursuing option see solutions.rstudio.com/db/ look resources put together Shiny pertains dealing databases web-accessible R platform.","code":"# Global code; gets executed at plumb() time. counter <- 0  #* @get / function() {   # Only gets evaluated when this endpoint is requested.   counter <<- counter + 1 }"},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"in-memory","dir":"Articles","previous_headings":"","what":"In-Memory","title":"Runtime","text":"shown previous Execution Model section, possible share state using environment associated plumber2 router. one approach presented allow plumber2 process stateless. approach sufficient coordinating state within single route single process, scale API adding processes routes, state longer coordinated . Therefore approach can effective “read-” data – load single, large dataset memory API starts, allow filters endpoints reference dataset moving forward – allow share state across multiple processes scale. want build scalable, stateless application, avoid relying -memory R environment coordinate state pieces API.","code":"# Global code; gets executed at plumb() time. counter <- 0  #* @get / function() {   # Only gets evaluated when this endpoint is requested.   counter <<- counter + 1 }"},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"file-system","dir":"Articles","previous_headings":"","what":"File System","title":"Runtime","text":"Writing files disk often next obvious choice storing state. plumber2 APIs modify data frame use write.csv() save data disk, use writeLines() append new data existing file. approaches enable R process stateless, always resilient concurrency issues. instance, ’ve horizontally scaled API five R processes two go write.csv() simultaneously, either see one process’s data get immediately overwritten ’s, – even worse – may end corrupted CSV file can’t read. Unless otherwise stated, ’s safe assume R function writes data disk resilient concurrency contention, rely filesystem coordinate shared state single R process running concurrently. ’s also important ask whether hosting platform ’ll using supports persistent storage disk. instance, Docker may insulate R process hardware allow write outside container. RStudio Connect, , provision new directory every time deploy updated version API discard data written disk point. ’re considering writing state disk long-term, sure hosting environment supports persistent -disk storage ’ve considered concurrency implications code.","code":""},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"state-cookies","dir":"Articles","previous_headings":"","what":"Cookies","title":"Runtime","text":"HTTP cookies convention allow web servers send state client expectation client include state future requests. See Setting Cookies section details leverage cookies plumber2. modern web browsers support cookies (unless configured ) many clients , well, though clients require additional configuration order . ’re confident intended clients API support cookies consider storing state cookies. approach mitigates concerns horizontal scalability, state written client independently included subsequent requests client. also minimizes infrastructure requirements hosting plumber2 APIs since don’t need setup system capable storing state; instead, ’ve commissioned clients store state. One issue maintaining state cookies size kept minimum. Clients impose restrictions differently, plan store 4kB information cookie. realize whatever information gets placed cookie must retransmitted client every request. can significantly increase size HTTP request clients make. notable concern considering using cookies store state since clients responsible storing sending state, expect state tampered . Thus, may acceptable store user preferences like preferredColor=\"blue\", store authentication information like userID=1493, since user trivially change cookie another user’s ID impersonate . ’d like use cookies store information guarantees user either read modify state, see Encrypted Cookies section).","code":""},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"external-data-store","dir":"Articles","previous_headings":"","what":"External Data Store","title":"Runtime","text":"final option consider coordinating state API leveraging external data store. relational database (like MySQL Amazon RedShift), non-relational database (like MongoDB), transactional data store like Redis. One important consideration options ensure “transactional,” meaning two plumber2 processes trying write time won’t overwrite one another. ’re interested pursuing option see solutions.rstudio.com/db/ look resources put together Shiny pertains dealing databases web-accessible R platform.","code":""},{"path":"https://plumber2.posit.co/articles/execution-model.html","id":"exit-handlers","dir":"Articles","previous_headings":"","what":"Exit Handlers","title":"Runtime","text":"may useful define function want run API closing – instance, pool database connections need cleaned plumber2 process terminated. can add handler \"end\" event . interrupt API (instance pressing Ctrl+C (blocking sessions) calling api_stop() (non-blocking sessions)) ’ll see Bye bye! printed console. can even register multiple end handlers ’ll run order registered.","code":"api(\"plumber.R\") |>   api_on(\"end\", function(){     print(\"Bye bye!\")   }) |>   api_run()"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"what-does-it-mean-to-extend-plumber2","dir":"Articles","previous_headings":"","what":"What does it mean to extend plumber2","title":"Extending plumber2","text":"continue qualify mean extending plumber2. course involves adding new functionality plumber2 way, specifically entails adding functionality way feels native plumber2. Consider function: extend plumber2’ API, non-native way. First, function name prefixed api_, second, function pipe-friendly. However, importantly plumber2 function associated tag can used add functionality annotation. certain functionality isn’t accessible tags, try hardest allow users create APIs. another type extension discuss end well, add new parsers, serializers, async engines. revolves around registering new functions can accessed relevant tags.","code":"say_hi <- function(language, api) {   hi <- c(     \"english\" = \"hi\",     \"danish\" = \"hej\",     \"french\" = \"salut\",     \"spanish\" = \"hola\",     \"japanese\" = \"konnichiwa\"   )[tolower(language)]   api$on(\"start\", function(...) cat(hi, \"\\n\")) }"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"adding-new-tags","dir":"Articles","previous_headings":"","what":"Adding new tags","title":"Extending plumber2","text":"Central plumber2’ api annotation tags. Thankfully, tags exclusive functionality provided plumber2 package can provided packages somehow extends plumber2 can . Adding new tags relatively simple require bit knowledge plumber2 parses file. single annotation block, process roughly like : annotation parsed split ’s constituents. tag point made tag name optional text string contains anything followed tag. point, expression follows annotation block also parsed evaluated. plumber2 determine , , basic block types , e.g. handler block, shiny block, something else plumber2 recognises block type create S3 object name following plumber2_*_block class name structure. object contain information necessary apply annotation Plumber2 object. , plumber2 go tags block see one handlers registered tag call handlers one one. handlers option modify block object, either adding modifying elements (allowed delete ). , may choose subclass object (remove class). annotation file converted list objects one one applied Plumber2 object calling apply_plumber2_block() generic block passing block object created 3 4 along Plumber2 object. follows two places concerned comes extending plumber2 tags: tag registration apply_plumber2_block methods. Depending need ’ll add one potentially . ’ll go : adding new tag, , want add functionality already existing tag, ’ll add new handler tag. done add_plumber2_tag() function takes tag name handler function. general, can add handler already existing tag (tag can mutliple handlers called turn), exert caution mess original behaviour tag. adding handler new tag control, focus . additional aspect think whether tag meant fit already existing block type (e.g. standard handler block) basis new block type. show . example want create new type annotation block sets simple recurring message server. call tag tictoc allow take single additional parameter interval seconds message. , allow user add actual message string annotation block. define two new tags, tictoc logType. tictoc associated handler handler uses tags. logType tag still registered ensure plumber2/roxygen2 knows existence. handler function can see two different modes input annotation block: tags/values arguments call argument. tags contains character vector tags block, values list additional arguments supplied tag. values provided single, unprocessed, strings means tag additional arguments values empty string. , string may contain one new-line characters end etc. provider tag () make sense argument tag takes parsing associated value however chose. call argument contains whatever comes annotation block, parsed evaluated. handler first check see block plumber2_empty_block object. strictly necessary implementing new block type check mixed block types. Apart , handler mainly parsing relevant tags collecting new object gives class plumber2_tictoc_block. may want augment already existing block type new tag. proces similar , considerations take account handler function. example look @cors tag implemented extension inside plumber2 : handler , adding existing block type, create new block object rather modifies one passed . case add new class (replace , disallowed), add new element well. check block class case exact requirement block type use , since @cors can used together block type defines endpoint don’t bother . examples doesn’t really anything Plumber2 object, rather, gather information annotations later use. “later use” comes form apply_plumber2_block methods block object classes created (examples , plumber2_tictoc_block plumber2_cors_block). method must take following arguments: block, object constructed tag parsing api, Plumber2 object constructed route_name, name route created given file root, root endpoints file ..., currently always ignored future use , block api always relevant whereas others can ignored unless add endpoints way interact route annotation file defines. different things keep mind depending whether subclass existing block . example method block object single class return tictoc block . apply_plumber2_block() method look like : can see, little magic goes apply_plumber2_block method. take information gathered tags whatever need Plumber2 object put effect. use time() method Plumber2 object add recurring timed logging expression. method returns Plumber2 object. strictly necessary due reference semantics object good clarity. Especially given Plumber2 object returned, even different one passed , take original object. course important don’t pull carpet feet user something completely unpredictable. However, mean can cast Plumber2 object subclass, extension require . example apply_plumber2_block() method block object subclassed, look @cors tag implemented: important takeaway starts calling NextMethod() thus ensuring parent methods called first. Another thing note method using programmatic api hood support annotation functionality (use api_security_cors()). good design ensures annotation programmtic interface stays aligned. didn’t tictoc tag yet created programmatic interface get second.","code":"add_plumber2_tag(\"tictoc\", function(block, call, tags, values, env) {   if (!inherits(block, \"plumber2_empty_block\")) {     cli::cli_abort(       \"{.field @tictoc} cannot be used with other types of annotation blocks\"     )   }   if (!rlang::is_string(call)) {     cli::cli_abort(       \"The expression following a {.field tictoc} block must be a string\"     )   }    interval <- as.integer(values[[which(tags == \"tictoc\")[1]]])   if (is.na(interval)) interval <- 5   message <- call    type <- \"message\"   if (any(tags == \"logType\") && values[[which(tags == \"logType\")[1]]] != \"\") {     type <- values[[which(tags == \"logType\")[1]]]   }    structure(     list(       interval = interval,       message = message,       type = type     ),     class = \"plumber2_tictoc_block\"   ) }) add_plumber2_tag(\"logType\") add_plumber2_tag(\"cors\", function(block, call, tags, values, env) {   class(block) <- c(\"plumber2_cors_block\", class(block))   block$cors <- trimws(strsplit(values[[which(tags == \"cors\")[1]]], \",\")[[1]])   if (block$cors == \"\") {     block$cors <- \"*\"   }   block }) apply_plumber2_block.plumber2_tictoc_block <- function(   block,    api,    route_name,    root,    ... ) {   api$time(     api$log(event = block$type, message = block$message),     after = block$interval,     loop = TRUE   )   api } apply_plumber2_block.plumber2_cors_block <- function(   block,   api,   route_name,   root,   ... ) {   NextMethod()   for (i in seq_along(block$endpoints)) {     for (path in block$endpoints[[i]]$path) {       api <- api_security_cors(         api,         paste0(root, path),         block$cors,         methods = block$endpoints[[i]]$method       )     }   }   api }"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"tag-registration","dir":"Articles","previous_headings":"","what":"Tag registration","title":"Extending plumber2","text":"adding new tag, , want add functionality already existing tag, ’ll add new handler tag. done add_plumber2_tag() function takes tag name handler function. general, can add handler already existing tag (tag can mutliple handlers called turn), exert caution mess original behaviour tag. adding handler new tag control, focus . additional aspect think whether tag meant fit already existing block type (e.g. standard handler block) basis new block type. show . example want create new type annotation block sets simple recurring message server. call tag tictoc allow take single additional parameter interval seconds message. , allow user add actual message string annotation block. define two new tags, tictoc logType. tictoc associated handler handler uses tags. logType tag still registered ensure plumber2/roxygen2 knows existence. handler function can see two different modes input annotation block: tags/values arguments call argument. tags contains character vector tags block, values list additional arguments supplied tag. values provided single, unprocessed, strings means tag additional arguments values empty string. , string may contain one new-line characters end etc. provider tag () make sense argument tag takes parsing associated value however chose. call argument contains whatever comes annotation block, parsed evaluated. handler first check see block plumber2_empty_block object. strictly necessary implementing new block type check mixed block types. Apart , handler mainly parsing relevant tags collecting new object gives class plumber2_tictoc_block. may want augment already existing block type new tag. proces similar , considerations take account handler function. example look @cors tag implemented extension inside plumber2 : handler , adding existing block type, create new block object rather modifies one passed . case add new class (replace , disallowed), add new element well. check block class case exact requirement block type use , since @cors can used together block type defines endpoint don’t bother .","code":"add_plumber2_tag(\"tictoc\", function(block, call, tags, values, env) {   if (!inherits(block, \"plumber2_empty_block\")) {     cli::cli_abort(       \"{.field @tictoc} cannot be used with other types of annotation blocks\"     )   }   if (!rlang::is_string(call)) {     cli::cli_abort(       \"The expression following a {.field tictoc} block must be a string\"     )   }    interval <- as.integer(values[[which(tags == \"tictoc\")[1]]])   if (is.na(interval)) interval <- 5   message <- call    type <- \"message\"   if (any(tags == \"logType\") && values[[which(tags == \"logType\")[1]]] != \"\") {     type <- values[[which(tags == \"logType\")[1]]]   }    structure(     list(       interval = interval,       message = message,       type = type     ),     class = \"plumber2_tictoc_block\"   ) }) add_plumber2_tag(\"logType\") add_plumber2_tag(\"cors\", function(block, call, tags, values, env) {   class(block) <- c(\"plumber2_cors_block\", class(block))   block$cors <- trimws(strsplit(values[[which(tags == \"cors\")[1]]], \",\")[[1]])   if (block$cors == \"\") {     block$cors <- \"*\"   }   block })"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"new-block-type","dir":"Articles","previous_headings":"","what":"New block type","title":"Extending plumber2","text":"example want create new type annotation block sets simple recurring message server. call tag tictoc allow take single additional parameter interval seconds message. , allow user add actual message string annotation block. define two new tags, tictoc logType. tictoc associated handler handler uses tags. logType tag still registered ensure plumber2/roxygen2 knows existence. handler function can see two different modes input annotation block: tags/values arguments call argument. tags contains character vector tags block, values list additional arguments supplied tag. values provided single, unprocessed, strings means tag additional arguments values empty string. , string may contain one new-line characters end etc. provider tag () make sense argument tag takes parsing associated value however chose. call argument contains whatever comes annotation block, parsed evaluated. handler first check see block plumber2_empty_block object. strictly necessary implementing new block type check mixed block types. Apart , handler mainly parsing relevant tags collecting new object gives class plumber2_tictoc_block.","code":"add_plumber2_tag(\"tictoc\", function(block, call, tags, values, env) {   if (!inherits(block, \"plumber2_empty_block\")) {     cli::cli_abort(       \"{.field @tictoc} cannot be used with other types of annotation blocks\"     )   }   if (!rlang::is_string(call)) {     cli::cli_abort(       \"The expression following a {.field tictoc} block must be a string\"     )   }    interval <- as.integer(values[[which(tags == \"tictoc\")[1]]])   if (is.na(interval)) interval <- 5   message <- call    type <- \"message\"   if (any(tags == \"logType\") && values[[which(tags == \"logType\")[1]]] != \"\") {     type <- values[[which(tags == \"logType\")[1]]]   }    structure(     list(       interval = interval,       message = message,       type = type     ),     class = \"plumber2_tictoc_block\"   ) }) add_plumber2_tag(\"logType\")"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"existing-block-type","dir":"Articles","previous_headings":"","what":"Existing block type","title":"Extending plumber2","text":"may want augment already existing block type new tag. proces similar , considerations take account handler function. example look @cors tag implemented extension inside plumber2 : handler , adding existing block type, create new block object rather modifies one passed . case add new class (replace , disallowed), add new element well. check block class case exact requirement block type use , since @cors can used together block type defines endpoint don’t bother .","code":"add_plumber2_tag(\"cors\", function(block, call, tags, values, env) {   class(block) <- c(\"plumber2_cors_block\", class(block))   block$cors <- trimws(strsplit(values[[which(tags == \"cors\")[1]]], \",\")[[1]])   if (block$cors == \"\") {     block$cors <- \"*\"   }   block })"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"apply_plumber2_block-methods","dir":"Articles","previous_headings":"","what":"apply_plumber2_block methods","title":"Extending plumber2","text":"examples doesn’t really anything Plumber2 object, rather, gather information annotations later use. “later use” comes form apply_plumber2_block methods block object classes created (examples , plumber2_tictoc_block plumber2_cors_block). method must take following arguments: block, object constructed tag parsing api, Plumber2 object constructed route_name, name route created given file root, root endpoints file ..., currently always ignored future use , block api always relevant whereas others can ignored unless add endpoints way interact route annotation file defines. different things keep mind depending whether subclass existing block . example method block object single class return tictoc block . apply_plumber2_block() method look like : can see, little magic goes apply_plumber2_block method. take information gathered tags whatever need Plumber2 object put effect. use time() method Plumber2 object add recurring timed logging expression. method returns Plumber2 object. strictly necessary due reference semantics object good clarity. Especially given Plumber2 object returned, even different one passed , take original object. course important don’t pull carpet feet user something completely unpredictable. However, mean can cast Plumber2 object subclass, extension require . example apply_plumber2_block() method block object subclassed, look @cors tag implemented: important takeaway starts calling NextMethod() thus ensuring parent methods called first. Another thing note method using programmatic api hood support annotation functionality (use api_security_cors()). good design ensures annotation programmtic interface stays aligned. didn’t tictoc tag yet created programmatic interface get second.","code":"apply_plumber2_block.plumber2_tictoc_block <- function(   block,    api,    route_name,    root,    ... ) {   api$time(     api$log(event = block$type, message = block$message),     after = block$interval,     loop = TRUE   )   api } apply_plumber2_block.plumber2_cors_block <- function(   block,   api,   route_name,   root,   ... ) {   NextMethod()   for (i in seq_along(block$endpoints)) {     for (path in block$endpoints[[i]]$path) {       api <- api_security_cors(         api,         paste0(root, path),         block$cors,         methods = block$endpoints[[i]]$method       )     }   }   api }"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"single-main-class","dir":"Articles","previous_headings":"","what":"Single main class","title":"Extending plumber2","text":"example method block object single class return tictoc block . apply_plumber2_block() method look like : can see, little magic goes apply_plumber2_block method. take information gathered tags whatever need Plumber2 object put effect. use time() method Plumber2 object add recurring timed logging expression. method returns Plumber2 object. strictly necessary due reference semantics object good clarity. Especially given Plumber2 object returned, even different one passed , take original object. course important don’t pull carpet feet user something completely unpredictable. However, mean can cast Plumber2 object subclass, extension require .","code":"apply_plumber2_block.plumber2_tictoc_block <- function(   block,    api,    route_name,    root,    ... ) {   api$time(     api$log(event = block$type, message = block$message),     after = block$interval,     loop = TRUE   )   api }"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"subclass","dir":"Articles","previous_headings":"","what":"Subclass","title":"Extending plumber2","text":"example apply_plumber2_block() method block object subclassed, look @cors tag implemented: important takeaway starts calling NextMethod() thus ensuring parent methods called first. Another thing note method using programmatic api hood support annotation functionality (use api_security_cors()). good design ensures annotation programmtic interface stays aligned. didn’t tictoc tag yet created programmatic interface get second.","code":"apply_plumber2_block.plumber2_cors_block <- function(   block,   api,   route_name,   root,   ... ) {   NextMethod()   for (i in seq_along(block$endpoints)) {     for (path in block$endpoints[[i]]$path) {       api <- api_security_cors(         api,         paste0(root, path),         block$cors,         methods = block$endpoints[[i]]$method       )     }   }   api }"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"adding-a-programmatic-interface","dir":"Articles","previous_headings":"","what":"Adding a programmatic interface","title":"Extending plumber2","text":"annotations makes plumber2 stand , ensure whatever functionality extension provides also available users build api programmatically. need one--one correspondance annotations functions keep closely aligned possible. ensure programmatic interface feels native need make pipe-friendly, meaning take Plumber2 object first argument (generally named api) return back modified end. Apart ask prefix function name api_ align rest interface. tictoc example created look something like:","code":"api_tictoc <- function(api, interval, message, type = \"message\") {   api$time(     api$log(event = type, message = message),     after = interval,     loop = TRUE   )   api }"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"new-parsers-serializers-and-async-engines","dir":"Articles","previous_headings":"","what":"New parsers, serializers, and async engines","title":"Extending plumber2","text":"simple way expand plumber2 can provide new parsers serializers , even new async backend (though one provided intend purposes best choice). go approach Serializers responsible converting return value functions format requested client. plumber2 supports content negotiation client can ask specific format (priority different formats) plumber2 serve best abilities. provide additional details serializers support, plumber2 use set default serializers cover common use cases: serializers besides defaults registered, usually niche situations. can accessed name, either annotation programmatic interface: can always pass function directly serializer, registering name makes much easier reuse, making default makes serializer instantly available endpoints (providing using defaults). follows providing additional serializers, defaults non-defaults, increases ways plumber2 can interact client. Creating registering new serializer involved go process creating toml serializer based tomledit package. first thing create serializer function: can see, create function returns actual serializer (unary function taking data serialize). two reasons: First, allows us run one-time code every time something needs serialized (shown ), allows us pass arguments modify behavior serializer, e.g. like rds serializer: serializer hand can now proceed registering . need name, serializer , well mime type output produces. default register serializer default since makes sense . latter can sometimes bit guessing game since mime types evolving thing, especially new formats. one registered IANA use , otherwise try see developer format community around suggests. toml, application/toml mime type registered IANA ’ll use . can convince ourself works trying fetch name: can also see part defaults: special category output requires breed serializers, namely graphics output. produces image files side-effect rendering serializer needs know capture . Graphics serializers part default serializers specifically request . request graphics serializer “png” explicitly use ... ask remainder type. Since act capturing graphics output formalized R graphics device interface relatively straightforward add new graphics serializer using helper function plumber2. create PostScript serializer based postscript() device: can now registered way toml serializer . plumber2 can see serializer graphics serializer, special thing need differently. Parsers like serializers direction communication, , converting body request R object. process similar showcase creating toml parser well. Like serializers also concept default parsers, get_parsers() function retrieve parsers registry. looks lot like toml serializer. function returning function use outer function time-consuming one-code ensure inner function lean possible. One difference inner function takes two arguments: x (body request raw vector), directives. last argument additional parameters passed client part Content-Type header. can often ignore last argument parsers important. Registering parser done like serializer. difference can register parser multiple mime types rather single one, can respond matter client decides call . general good idea include kind mime type, official otherwise, can find since control client decides use. plumber2 comes build support asynchronous evaluation based mirai. strongly believe best choice async eval R, may still use another engine se desire registering new one. , show create asynch evaluator based future package parsers serializers start creating evaluator function , , function returning function. inner function takes two arguments: expression evaluate, environment holds variables use expression. inner function must return promise (based promises package). evaluator place can registered name: last argument holds package dependencies engine. can now use engine, either annotation (@async future) programmatically get_async(\"future\").","code":"names(get_serializers()) #> [1] \"application/json\"          \"text/html\" #> [3] \"application/rds\"           \"text/csv\" #> [5] \"text/tab-separated-values\" \"text/xml\" #> [7] \"text/plain\"                \"text/yaml\" get_serializers(\"geojson\") #> $`application/geo+json` #> function (x) #> { #>     if (inherits(x, \"sfc\")) { #>         return(geojsonsf::sfc_geojson(x, ...)) #>     } #>     if (inherits(x, \"sf\")) { #>         return(geojsonsf::sf_geojson(x, ...)) #>     } #>     cli::cli_abort(\"{.fun format_geojson} did not receive an `sf` or `sfc` object.\") #> } #> <bytecode: 0x55928ec022e8> #> <environment: 0x55928d21f328> format_toml <- function() {   rlang::check_installed(\"tomledit\")   function(x) {     tomledit::to_toml(x)   } } print(format_rds) #> function (version = \"3\", ascii = FALSE, ...) #> { #>     function(x) { #>         serialize(x, NULL, ascii = ascii, version = version, #>             ...) #>     } #> } #> <bytecode: 0x55928ebcb340> #> <environment: namespace:plumber2> register_serializer(\"toml\", format_toml, \"application/toml\") get_serializers(\"toml\") #> $`application/toml` #> function (x) #> { #>     tomledit::to_toml(x) #> } #> <environment: 0x55928dd8df90> names(get_serializers()) #> [1] \"application/json\"          \"text/html\" #> [3] \"application/rds\"           \"text/csv\" #> [5] \"text/tab-separated-values\" \"text/xml\" #> [7] \"text/plain\"                \"text/yaml\" #> [9] \"application/toml\" names(get_serializers(c(\"png\", \"...\"))) #> [1] \"image/png\"       \"image/jpeg\"      \"image/tiff\"      \"image/svg+xml\" #> [5] \"image/bmp\"       \"application/pdf\" format_postscript <- device_formatter(postscript) register_serializer(   \"postscript\",    format_postscript,    \"application/postscript\",   default = FALSE ) parse_toml <- function() {   rlang::check_installed(\"tomledit\")   function(x, directives) {     tomledit::read_toml(rawToChar(x))   } } register_parser(   \"toml\",    parse_toml,    c(\"application/toml\", \"text/x-toml\", \"text/toml\") ) future_async <- function(...) {   rlang::check_installed(\"promises\")   function(expr, envir) {     promises::future_promise(       expr = expr,       envir = envir,       substitute = FALSE,       ...     )   } } register_async(\"future\", future_async, c(\"promises\", \"future\"))"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"serializers","dir":"Articles","previous_headings":"","what":"Serializers","title":"Extending plumber2","text":"Serializers responsible converting return value functions format requested client. plumber2 supports content negotiation client can ask specific format (priority different formats) plumber2 serve best abilities. provide additional details serializers support, plumber2 use set default serializers cover common use cases: serializers besides defaults registered, usually niche situations. can accessed name, either annotation programmatic interface: can always pass function directly serializer, registering name makes much easier reuse, making default makes serializer instantly available endpoints (providing using defaults). follows providing additional serializers, defaults non-defaults, increases ways plumber2 can interact client. Creating registering new serializer involved go process creating toml serializer based tomledit package. first thing create serializer function: can see, create function returns actual serializer (unary function taking data serialize). two reasons: First, allows us run one-time code every time something needs serialized (shown ), allows us pass arguments modify behavior serializer, e.g. like rds serializer: serializer hand can now proceed registering . need name, serializer , well mime type output produces. default register serializer default since makes sense . latter can sometimes bit guessing game since mime types evolving thing, especially new formats. one registered IANA use , otherwise try see developer format community around suggests. toml, application/toml mime type registered IANA ’ll use . can convince ourself works trying fetch name: can also see part defaults: special category output requires breed serializers, namely graphics output. produces image files side-effect rendering serializer needs know capture . Graphics serializers part default serializers specifically request . request graphics serializer “png” explicitly use ... ask remainder type. Since act capturing graphics output formalized R graphics device interface relatively straightforward add new graphics serializer using helper function plumber2. create PostScript serializer based postscript() device: can now registered way toml serializer . plumber2 can see serializer graphics serializer, special thing need differently.","code":"names(get_serializers()) #> [1] \"application/json\"          \"text/html\" #> [3] \"application/rds\"           \"text/csv\" #> [5] \"text/tab-separated-values\" \"text/xml\" #> [7] \"text/plain\"                \"text/yaml\" get_serializers(\"geojson\") #> $`application/geo+json` #> function (x) #> { #>     if (inherits(x, \"sfc\")) { #>         return(geojsonsf::sfc_geojson(x, ...)) #>     } #>     if (inherits(x, \"sf\")) { #>         return(geojsonsf::sf_geojson(x, ...)) #>     } #>     cli::cli_abort(\"{.fun format_geojson} did not receive an `sf` or `sfc` object.\") #> } #> <bytecode: 0x55928ec022e8> #> <environment: 0x55928d21f328> format_toml <- function() {   rlang::check_installed(\"tomledit\")   function(x) {     tomledit::to_toml(x)   } } print(format_rds) #> function (version = \"3\", ascii = FALSE, ...) #> { #>     function(x) { #>         serialize(x, NULL, ascii = ascii, version = version, #>             ...) #>     } #> } #> <bytecode: 0x55928ebcb340> #> <environment: namespace:plumber2> register_serializer(\"toml\", format_toml, \"application/toml\") get_serializers(\"toml\") #> $`application/toml` #> function (x) #> { #>     tomledit::to_toml(x) #> } #> <environment: 0x55928dd8df90> names(get_serializers()) #> [1] \"application/json\"          \"text/html\" #> [3] \"application/rds\"           \"text/csv\" #> [5] \"text/tab-separated-values\" \"text/xml\" #> [7] \"text/plain\"                \"text/yaml\" #> [9] \"application/toml\" names(get_serializers(c(\"png\", \"...\"))) #> [1] \"image/png\"       \"image/jpeg\"      \"image/tiff\"      \"image/svg+xml\" #> [5] \"image/bmp\"       \"application/pdf\" format_postscript <- device_formatter(postscript) register_serializer(   \"postscript\",    format_postscript,    \"application/postscript\",   default = FALSE )"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"graphics-output","dir":"Articles","previous_headings":"","what":"Graphics output","title":"Extending plumber2","text":"special category output requires breed serializers, namely graphics output. produces image files side-effect rendering serializer needs know capture . Graphics serializers part default serializers specifically request . request graphics serializer “png” explicitly use ... ask remainder type. Since act capturing graphics output formalized R graphics device interface relatively straightforward add new graphics serializer using helper function plumber2. create PostScript serializer based postscript() device: can now registered way toml serializer . plumber2 can see serializer graphics serializer, special thing need differently.","code":"names(get_serializers(c(\"png\", \"...\"))) #> [1] \"image/png\"       \"image/jpeg\"      \"image/tiff\"      \"image/svg+xml\" #> [5] \"image/bmp\"       \"application/pdf\" format_postscript <- device_formatter(postscript) register_serializer(   \"postscript\",    format_postscript,    \"application/postscript\",   default = FALSE )"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"parsers","dir":"Articles","previous_headings":"","what":"Parsers","title":"Extending plumber2","text":"Parsers like serializers direction communication, , converting body request R object. process similar showcase creating toml parser well. Like serializers also concept default parsers, get_parsers() function retrieve parsers registry. looks lot like toml serializer. function returning function use outer function time-consuming one-code ensure inner function lean possible. One difference inner function takes two arguments: x (body request raw vector), directives. last argument additional parameters passed client part Content-Type header. can often ignore last argument parsers important. Registering parser done like serializer. difference can register parser multiple mime types rather single one, can respond matter client decides call . general good idea include kind mime type, official otherwise, can find since control client decides use.","code":"parse_toml <- function() {   rlang::check_installed(\"tomledit\")   function(x, directives) {     tomledit::read_toml(rawToChar(x))   } } register_parser(   \"toml\",    parse_toml,    c(\"application/toml\", \"text/x-toml\", \"text/toml\") )"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"asynchronous-engines","dir":"Articles","previous_headings":"","what":"Asynchronous engines","title":"Extending plumber2","text":"plumber2 comes build support asynchronous evaluation based mirai. strongly believe best choice async eval R, may still use another engine se desire registering new one. , show create asynch evaluator based future package parsers serializers start creating evaluator function , , function returning function. inner function takes two arguments: expression evaluate, environment holds variables use expression. inner function must return promise (based promises package). evaluator place can registered name: last argument holds package dependencies engine. can now use engine, either annotation (@async future) programmatically get_async(\"future\").","code":"future_async <- function(...) {   rlang::check_installed(\"promises\")   function(expr, envir) {     promises::future_promise(       expr = expr,       envir = envir,       substitute = FALSE,       ...     )   } } register_async(\"future\", future_async, c(\"promises\", \"future\"))"},{"path":"https://plumber2.posit.co/articles/extending.html","id":"the-plumber2-object-and-its-extension-points","dir":"Articles","previous_headings":"","what":"The Plumber2 object and its extension points","title":"Extending plumber2","text":"TBD","code":""},{"path":"https://plumber2.posit.co/articles/hosting.html","id":"the-_server-yml-file","dir":"Articles","previous_headings":"","what":"The _server.yml file","title":"Hosting","text":"Since plumber2 API specifications can spread multiple files need single file source truth API based . plumber2 uses _server.yml specification can create scaffold file using create_server_yml(). _server.yml file contains R files make API, can also holds options modify API constructed (see get_opts()). _server.yml file can verify works passing api() testing constructed API:","code":"# Create _server.yml in the working directory create_server_yml(...) # Various settings to capture your server  # Test that it works api(\"_server.yml\") |>    api_run()"},{"path":"https://plumber2.posit.co/articles/hosting.html","id":"posit-connect","dir":"Articles","previous_headings":"","what":"Posit Connect","title":"Hosting","text":"Posit Connect enterprise publishing platform Posit. supports push-button publishing RStudio IDE variety R content types including plumber2 APIs. Unlike options listed , Posit Connect automatically manages dependent packages files API recreates environment closely mimicking local development environment server. Posit Connect automatically manages number R processes necessary handle current load balances incoming traffic across available processes. can also shut idle processes ’re use. allows run appropriate number R processes scale capacity accommodate current load.","code":""},{"path":"https://plumber2.posit.co/articles/introduction.html","id":"web-apis","dir":"Articles","previous_headings":"","what":"Web APIs","title":"Introduction","text":"Hypertext Transfer Protocol (HTTP) dominant medium information exchanged Internet. Application Programming Interface (API) broad term defines rules guide interaction software. case HTTP APIs, defined set endpoints accept particular inputs. Plumber2 translates annotations place functions HTTP API can called machines network. execute Plumber API public server, can even make API available public Internet. HTTP APIs become predominant language software communicates. creating HTTP API, ’ll empower R code leveraged services – whether ’re housed inside organization hosted side world. just ideas doors opened wrap R code Plumber API: Software written languages organization can run R code. company’s Java application now pull custom ggplot2 graph generate -demand, Python client query predictive model defined R. can third-party receive emails behalf notify Plumber service new messages arrive. register “Slash Command” Slack, enabling execute R function response command entered Slack. can write JavaScript code queries Plumber API visitor’s web browser. Even , use Plumber exclusively back-end interactive web application.","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"moving-from-plumber","dir":"Articles","previous_headings":"","what":"Moving from plumber","title":"Upgrading From Plumber","text":"Plumber2 designed way make familiar long-time plumber users. However, created explicit intend API-compatible old plumber code plumber files, except simplest cases. done allow us learn many years experience plumber keep work shedding proven suboptimal. coming plumber document may serve starting ground recalibrating ways plumber2, well aid updating old plumber APIs plumber2.","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"pr_-to-api_","dir":"Articles","previous_headings":"","what":"pr_*() to api_*()","title":"Upgrading From Plumber","text":"One first changes may recognise functional interface gotten prefix change. done, partly avoid namespace conflicts plumber, partly avoid users assuming functions worked 100% equivalently, partly pr prefix descriptive. acronym Plumber Route, API much router (especially plumber2) general prefix doesn’t make sense. new prefix, api, well-known acronym (Application Programming Interface) single meaning fits plumber2 meant help creates. plumber object creating also referred Plumber API underscore . functional interface match 1--1 substitute prefix shouldn’t expect find-replace needed.","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"only-path-arguments-are-passed-as-named-arguments-to-your-handler","dir":"Articles","previous_headings":"","what":"Only path arguments are passed as named arguments to your handler","title":"Upgrading From Plumber","text":"plumber, path argument, query parameters, potentially body parts used named arguments calling handler function. presented multiple problems, first foremost one win name clashes . also meant query string always parsed even handler didn’t use anything, adding unnecessary overhead. plumber2 avoid confusion supplying path arguments handler function named arguments. Query parameters request body passed function query body argument respectively. , passed way means function doesn’t touch never parsed. change means handler contains arguments meant come query string request body update accept query /body argument grab need .","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"no-more-filter-and-preempt","dir":"Articles","previous_headings":"","what":"No more filter and preempt","title":"Upgrading From Plumber","text":"Filters preempt removed completely plumber2. existed mainly plumber way letting users perform multiple chained operations requests. plumber2 possible many routes want, one tried sequence. possible routes called request completely recieved. can used inspect headers request reject even enters main router chain. functionality default filters plumber moved. body, query, cookie parsing now handled reqres fully automated way. shared-secret filter automatically created handler header route shared secret found options.","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"forward-replaced-by-next-and-break","dir":"Articles","previous_headings":"","what":"forward replaced by Next and Break","title":"Upgrading From Plumber","text":"Since filters , forward filter specific construct also gone. However, since every handler might now one chain handlers, added new ways control flow request handling. handler assumed pass handling next () handler chain. can make explicit returning Next handler, required. ’d often like instead return object assigned response body can well. Basically returning anything Break allow handling chain continue execution. However, returning Break inform plumber2 handler specifically wants return response right now modification (except serializing). useful header route handlers reject requests early , can also used normal request handling e.g. know resource moved want return redirect response immediately. might also want use Break handler catches error need abort. However, plumber2 offers much better way utilising abort_*() functions reqres. Throwing exception immediately stop handling request, set response according abort content log error.","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"new-request-and-response-objects","dir":"Articles","previous_headings":"","what":"New Request and Response objects","title":"Upgrading From Plumber","text":"Plumber provided objects working HTTP request responses. plumber2 now uses Request Response objects reqres. highly capable classes removed lot internal logic plumber2. responsible content negotiation, cookies, headers, etc. support encrypted session data storage like used plumber.","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"new-plumber-object","dir":"Articles","previous_headings":"","what":"New Plumber object","title":"Upgrading From Plumber","text":"main class encapsulating API , unsurprisingly, also changed plumber2. Fiery now used backbone plumber2 Plumber class now subclass powerful Fire class offers many capabilities advanced use, wish level plumber API","code":""},{"path":"https://plumber2.posit.co/articles/migration.html","id":"added-query-and-body-tags","dir":"Articles","previous_headings":"","what":"Added @query and @body tags","title":"Upgrading From Plumber","text":"plumber @param tag used document path parameters, query parameters request body. line making handler function arguments explicit also want apply documentation , now document query body explicit @query @body tags. syntax tags @param","code":""},{"path":"https://plumber2.posit.co/articles/plumber.html","id":"specifying-the-inputs","dir":"Articles","previous_headings":"","what":"Specifying the Inputs","title":"Get Started","text":"may noticed functions define endpoints accept parameters. parameters allow us customize behavior endpoints. example use two different ways specifying outputs. /echo/... handler take variable part path use argument. can see “test” used resulting json object provided different path, e.g. /echo/plumber “plumber” used instead. handler rely “query string” pass optional argument. visit http://localhost:8080/plot?spec=Adelie, see similar graph one saw , now dataset filtered include “Adelie” species palmerpenguins dataset.  might guessed, spec=Adelie portion URL sets spec element query Adelie. details Plumber processes inputs available Routing & Input article.","code":""},{"path":"https://plumber2.posit.co/articles/plumber.html","id":"customizing-the-output","dir":"Articles","previous_headings":"","what":"Customizing The Output","title":"Get Started","text":"previous example, saw one endpoint rendered JSON one produced image. However, visited /echo/test path web browser probably saw result rendered HTML. Plumber2 comes many different serializers can convert result R code variety formats. possible client (e.g. web browser) request specific format, server knows format generally oblige. browser usually prefers HTML, request wins default JSON representation plumber2 uses. wish ensure JSON always returned can make explicit using @serializer json sets JSON known output format. graphical output always explicit plumber knows set graphic device capture output. example use @serializer png graphic serializers available well, e.g. @serializer jpeg. neat able provide results variety formats unlikely formats makes sense output produce generally mindful serializers provide handler always produce HTML called. can even provide custom serializers define translate R object produced handler bits produce Plumber’s HTTP response. can find details Rendering & Output article.","code":"#* @get /hello #* @serializer html function() {   list(     body = list(       h1 = \"hello world\"     )   ) } <html><body><h1>hello world<\/h1><\/body><\/html>"},{"path":"https://plumber2.posit.co/articles/programmatic-usage.html","id":"creating-and-controlling-routers","dir":"Articles","previous_headings":"","what":"Creating and Controlling routers","title":"Programmatic Usage","text":"work plumber2 API related request router. router entity funnels requests correct handler based path. router used plumber2 provided routr package can interacted directly request_router field plumber API object. Often though, interact indirectly functions methods. router can contain multiple routes route can contain multiple path handlers. request received router pass route turn. route select handler (one exist) request execute handler request. possible handler signal processing happen case remaining routes router skipped response send immediately. create plumber api based multiple files file define route named file routes ordered order inputs. instead create API programmatically can create new route calling api_add_route() naming non-existing route add handler. latter case route placed end stack whereas adding explicitly former approach allows insert location router wish. may also use api_add_route() add already defined routr route api.","code":""},{"path":"https://plumber2.posit.co/articles/programmatic-usage.html","id":"defining-handlers","dir":"Articles","previous_headings":"","what":"Defining handlers","title":"Programmatic Usage","text":"can add handlers router using api_get(), api_post(), one handler functions. instance, define Plumber API responds GET requests / POST requests /submit, use following code: handler functions define calls identical code defined annotated file using annotations define API. handler functions take additional arguments allow control nuanced behavior handler like serializer(s) use. instance, following endpoint use default HTML serializer plumber2. worth noting difference adding handlers handler functions provided plumber2 routr::Route$add_handler() even though former based latter. latter approach handler added -’ll use routr’s syntax path variables (prefixing path element : rather enclosing <>). former handler wrapped another function talkes care much plumber2 “magic”, setting parsers serializers, providing type casting, supporting graphic output. Unless specifically want opt ’d best served using plumber2 provided handler functions. One place may want consider foregoing plumber API altogether writing plugin want plugin usable fiery apps plumber APIs.","code":"api() |>   api_get(\"/\", function(req, res){     # ...   }) |>   api_post(\"/submit\", function(req, res){     # ...   }) api() %>%   api_get(     path = \"/\",     handler = function(){       list(         body = list(           h1 = \"Programmatic Plumber!\"         )       )     },     serializers = get_serializers(\"html\")   )"},{"path":"https://plumber2.posit.co/articles/programmatic-usage.html","id":"listening-for-and-triggering-events","dir":"Articles","previous_headings":"","what":"Listening for and triggering events","title":"Programmatic Usage","text":"Plumber2 build upon fiery event-driven web server framework. course running several events fire event handlers triggered (e.g. router listening \"request\" events). generally rely router handling request event ensure requests handled structured manner, might want attach handlers events, e.g. \"start\" \"end\" events. can using api_on() function: can read event cycle fiery app fiery website. restricted listening predefined events. can add handlers event wish, ’ll need trigger event manually one predefined ones.","code":"api() |>   api_on(\"start\", function() {     print(\"Yay! I'm starting up\")   }) pa <- api() |>   api_on(\"hello\", function(name) {     print(\"Hello\", name)   })  ## Somewhere in your server code pa$trigger(\"hello\", name = \"Thomas\")"},{"path":"https://plumber2.posit.co/articles/programmatic-usage.html","id":"mount-static","dir":"Articles","previous_headings":"","what":"Static File Routers","title":"Programmatic Usage","text":"Static files can served two different manners. Either using specialized route attached router, completely circumventing R session serving files directly. former approach flexible, latter performant make files directories stored ./myfiles directory available API /assets/ path.","code":"# Serving files as a standard route api() |>   api_assets(\"/assets\", \"./myfiles\") |>   api_run()  # Serving files directly api() |>   api_statics(\"/assets\", \"./myfiles\") |>   api_run()"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"response-object","dir":"Articles","previous_headings":"","what":"The Response Object","title":"Rendering Output","text":"plumber2 response object , like request object, provided reqres implemented R6 class object. Please consult reqres documentation -depth overview class can . response object accessible within handler provides response argument, since based R6, change happening handler persist. necessary handler interact directly response. Returning “classic” value handler function set response body value, often providing everything needed particular handler. return values differ : Returning NULL Next: Returning either modify response body, allow request handled next route stack Returning Break: modify response short-circuit handling, returning response -Returning response: may return response handler alter ’s body . Like returning NULL Next allow handling continue next route Using graphics serializer: graphics serializer use body set graphic captured serializer return value function ignored Returning ggplot object: ggplot object returned plotted graphics serializer may capture output wish make use powerful features reqres likely want interact response object directly. features include, accessing setting session cookie data, setting headers, taking full control content negotiation serializing.","code":""},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"serializers","dir":"Articles","previous_headings":"","what":"Serializers","title":"Rendering Output","text":"order send response R API client, object must “serialized” format client can understand. JavaScript Object Notation (JSON) one standard commonly used web APIs. JSON serialization translates R objects like list(=123, b=\"hi!\") JSON text resembling {: 123, b: \"hi!\"}. JSON appropriate every situation, however. want API render HTML page might viewed browser, instance, need different serializer. Likewise, want return image rendered R, likely want use standard image format like PNG JPEG rather JSON. required decide single serializer front. server can provide different representations client can prefer specific representations. server can provide result different ways perform something called server-driven content negotiation, inspects request get client preferences chooses best serializer based . order use multiple serializers provide multiple @serializer tags, order determining server priority. two special values: none .... former instructs plumber2 serialization , leaving handler prepare response body set Content-Type header. latter insert non-selected serializers list position. e.g. : make YAML preferred response format still remaining serializers fall back client understand yaml. default, plumber2 uses registered serializers performs content negotiation based want ensure single output type set explicitly. Another reason set explicitly modify behavior providing arguments : may noticed JSON API responses generated Plumber render singular values (“scalars”) arrays. instance: value element, though ’s singular, still rendered array. may surprise initially, done keep output consistent. JSON differentiates scalar vector objects, R . creates ambiguity serializing R object JSON since unclear whether particular element rendered atomic value JSON array. Consider following API returns letters lexicographically “higher” given letter. example API , instance, produces scalar, instances produces vector. Visiting http://localhost:8080/boxed?letter=U http://localhost:8080/unboxed?letter=U return identical responses: However, http://localhost:8080/boxed?letter=Y produce: http://localhost:8080/unboxed?letter=Y produce: /boxed endpoint, name implies, produces “boxed” JSON output length-1 vectors still rendered array. Conversely, /unboxed endpoint sets auto_unbox=TRUE call jsonlite::toJSON, causing length-1 R vectors rendered JSON scalars. R doesn’t distinguish scalars vectors, API clients may respond differently encountering JSON array versus atomic value. may find API clients respond gracefully object expected vector becomes scalar one call. reason, Plumber inherits jsonlite::toJSON default setting auto_unbox=FALSE result length-1 vectors still rendered JSON arrays. can configure endpoint use unboxedJSON serializer (shown ) want alter behavior particular endpoint. couple functions aware around feature set. using boxed JSON serialization, jsonlite::unbox() can used force length-1 object R presented JSON scalar. using unboxed JSON serialization, () cause length-1 R object present JSON array. Graphics serializers special need setup teardown around handler order capture graphics output. mixed standard serializers. omitted using ... unless graphics serializer selected explicitly case ... refer remaining graphics serializers omit standard ones. standard serializers behaviour can modified specifying additional arguments serializer. Many arguments well-known using graphics devices R including width, height, bg among others. Arguments inside curly braces evaluated environment handler R expression valid. However, evaluated , parsing file, possible provide dynamic serializer settings way. wish dynamically size images, need render capture graphical output return contents appropriate Content-Type header. See existing image renderers model . instances may desirable return value directly R without serialization. can settings @serializer none turn automatic serialization plumber. Consider following handler: response returned endpoint contain body Literal text ! Content-Type header without additional serialization. similar vein can set Content-Type otherwise leave body unchanged providing mime type @serializer. can use annotation want control response send. Running API visiting http://localhost:8080/pdf download PDF generated R (display PDF natively, client supports ). plumber2 comes serializers cover use cases may want provide . can two ways. Either registering serializer refering name native serializer, specifying inline. may want serve toml files plumber doesn’t (yet) ship serializer . quickly create using blogdown::write_toml(). Serializers plumber2 factory functions take range arguments return unary function capable formatting response body: use directly handler @serializer application/toml format_toml() register : use like serializer: @serializer toml","code":"#* @serializer yaml #* @serializer ... #* @serializer json{na=\"string\"} jsonlite::toJSON(list(a=5)) #> {\"a\":[5]} #* Get letters after a given letter #* @serializer json #* @get /boxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] }  #* Get letters after a given letter #* @serializer unboxedJSON #* @get /unboxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] } [   \"V\",   \"W\",   \"X\",   \"Y\",   \"Z\" ] [   \"Z\" ] \"Z\" #* Example of customizing graphical output #* @serializer png{width = 400, height = 500} #* @get / function() {   plot(1:10) } #* Endpoint that bypasses serialization #* @get / #* @serializer none function(response) {   response$body <- \"Literal text here!\" } #* @serializer application/pdf #* @get /pdf function() {   tmp <- tempfile()   pdf(tmp)   plot(1:10, type=\"b\")   text(4, 8, \"PDF from plumber!\")   text(6, 2, paste(\"The time is\", Sys.time()))   dev.off()    readBin(tmp, \"raw\", n=file.info(tmp)$size) } format_toml <- function(...) {   function(x) {     blogdown::write_toml(x)   } } register_serializer(\"toml\", format_toml, \"application/toml\")"},{"path":[]},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"boxed-vs-unboxed-json","dir":"Articles","previous_headings":"","what":"Boxed vs Unboxed JSON","title":"Rendering Output","text":"may noticed JSON API responses generated Plumber render singular values (“scalars”) arrays. instance: value element, though ’s singular, still rendered array. may surprise initially, done keep output consistent. JSON differentiates scalar vector objects, R . creates ambiguity serializing R object JSON since unclear whether particular element rendered atomic value JSON array. Consider following API returns letters lexicographically “higher” given letter. example API , instance, produces scalar, instances produces vector. Visiting http://localhost:8080/boxed?letter=U http://localhost:8080/unboxed?letter=U return identical responses: However, http://localhost:8080/boxed?letter=Y produce: http://localhost:8080/unboxed?letter=Y produce: /boxed endpoint, name implies, produces “boxed” JSON output length-1 vectors still rendered array. Conversely, /unboxed endpoint sets auto_unbox=TRUE call jsonlite::toJSON, causing length-1 R vectors rendered JSON scalars. R doesn’t distinguish scalars vectors, API clients may respond differently encountering JSON array versus atomic value. may find API clients respond gracefully object expected vector becomes scalar one call. reason, Plumber inherits jsonlite::toJSON default setting auto_unbox=FALSE result length-1 vectors still rendered JSON arrays. can configure endpoint use unboxedJSON serializer (shown ) want alter behavior particular endpoint. couple functions aware around feature set. using boxed JSON serialization, jsonlite::unbox() can used force length-1 object R presented JSON scalar. using unboxed JSON serialization, () cause length-1 R object present JSON array.","code":"jsonlite::toJSON(list(a=5)) #> {\"a\":[5]} #* Get letters after a given letter #* @serializer json #* @get /boxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] }  #* Get letters after a given letter #* @serializer unboxedJSON #* @get /unboxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] } [   \"V\",   \"W\",   \"X\",   \"Y\",   \"Z\" ] [   \"Z\" ] \"Z\""},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"graphics-serializers","dir":"Articles","previous_headings":"","what":"Graphics serializers","title":"Rendering Output","text":"Graphics serializers special need setup teardown around handler order capture graphics output. mixed standard serializers. omitted using ... unless graphics serializer selected explicitly case ... refer remaining graphics serializers omit standard ones. standard serializers behaviour can modified specifying additional arguments serializer. Many arguments well-known using graphics devices R including width, height, bg among others. Arguments inside curly braces evaluated environment handler R expression valid. However, evaluated , parsing file, possible provide dynamic serializer settings way. wish dynamically size images, need render capture graphical output return contents appropriate Content-Type header. See existing image renderers model .","code":"#* Example of customizing graphical output #* @serializer png{width = 400, height = 500} #* @get / function() {   plot(1:10) }"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"bypassing-serialization","dir":"Articles","previous_headings":"","what":"Bypassing Serialization","title":"Rendering Output","text":"instances may desirable return value directly R without serialization. can settings @serializer none turn automatic serialization plumber. Consider following handler: response returned endpoint contain body Literal text ! Content-Type header without additional serialization. similar vein can set Content-Type otherwise leave body unchanged providing mime type @serializer. can use annotation want control response send. Running API visiting http://localhost:8080/pdf download PDF generated R (display PDF natively, client supports ).","code":"#* Endpoint that bypasses serialization #* @get / #* @serializer none function(response) {   response$body <- \"Literal text here!\" } #* @serializer application/pdf #* @get /pdf function() {   tmp <- tempfile()   pdf(tmp)   plot(1:10, type=\"b\")   text(4, 8, \"PDF from plumber!\")   text(6, 2, paste(\"The time is\", Sys.time()))   dev.off()    readBin(tmp, \"raw\", n=file.info(tmp)$size) }"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"custom-serializers","dir":"Articles","previous_headings":"","what":"Custom serializers","title":"Rendering Output","text":"plumber2 comes serializers cover use cases may want provide . can two ways. Either registering serializer refering name native serializer, specifying inline. may want serve toml files plumber doesn’t (yet) ship serializer . quickly create using blogdown::write_toml(). Serializers plumber2 factory functions take range arguments return unary function capable formatting response body: use directly handler @serializer application/toml format_toml() register : use like serializer: @serializer toml","code":"format_toml <- function(...) {   function(x) {     blogdown::write_toml(x)   } } register_serializer(\"toml\", format_toml, \"application/toml\")"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"error-handling","dir":"Articles","previous_headings":"","what":"Error Handling","title":"Rendering Output","text":"Plumber wraps endpoint invocation can gracefully capture errors. run API interactive mode visit http://localhost:8080/simple, ’ll notice two things: HTTP response status code 500 (“internal server error”) sent client. response give clues nature error error printed console means possible intentionally use stop() handler way communicate problem user. However, since information stripped away response, may preferable provide bit detail user. reqres, provides set abort calls works like stop() also carry information status code message send client. Read reqres website. Visiting second handler can see action:","code":"#* Example of throwing an error #* @get /simple function() {   stop(\"I'm an error!\") }  #* Generate a friendly error #* @get /friendly function() {   abort_bad_request(     \"Your request could not be parsed\"   ) } {   \"type\": \"https://datatracker.ietf.org/doc/html/rfc9110#section-15.5.1\",   \"title\": \"Bad Request\",   \"status\": 400,   \"detail\": \"Your request could not be parsed\" }"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"setting-cookies","dir":"Articles","previous_headings":"","what":"Setting Cookies","title":"Rendering Output","text":"part fulfilling request, Plumber API can choose set HTTP cookies client. HTTP APIs don’t implicitly contain notion “session.” Without additional information, Plumber way ascertaining whether two HTTP requests come associated user. Cookies offer way commission client store state behalf selected data can outlive single HTTP request; full implications using cookies track state API discussed . two forms Plumber cookies – plain-text encrypted – discussed following sections. make cookies important part API’s security model, sure understand section security considerations working cookies. Plumber can set receive plaint-text cookies. API endpoint return random letter, remembers preferences whether like capitalized lower-case letters. Since API using PUT request test API, ’ll use curl command line test . (’s nothing cookies necessitates PUT requests; just easily modify API use GET request.) can start visiting /letter endpoint ’ll see API defaults lower-case alphabet. curl http://localhost:8080/letter send PUT request specify capital parameter, cookie set client allow server accommodate preference future requests. curl, need specify file want save cookies using -c option. good reminder clients handle cookies differently – won’t support – sure clients intend support API play nicely cookies want use . send PUT request, setting parameter capital 1, invoke: curl -c cookies.txt -X PUT --data 'capital=1' \"http://localhost:8800/preferences\". print cookies.txt file, now see contains single cookie called capitalize value 1. can make another GET request /letter see accommodates preferences. ’ll need tell curl use cookies file just created sending request using -b switch: curl -b cookies.txt http://localhost:8080/letter. now see API returning random capitalized letter. set_cookie method accepts variety additional options customize cookie handled client. default, cookies set session lifetime, meaning cookie persist user’s browser client closes tab point cookie deleted. can customize setting expires max_age parameter set_cookie using either date number seconds future cookie expire. options can set cookie include path (path domain cookie installed client); http_only (controls whether cookie accessible JavaScript running domain – TRUE means cookie HTTP-, accessible JavaScript); secure (TRUE, instructs browser send cookie HTTPS, insecure HTTP. ’re using cookies infer security-sensitive properties (identify user, determine resources client access ), sure see Security article – particular section security implications cookies. addition storing plain-text cookies, Plumber also supports handling cookies encrypted. Encrypted cookies prevent users seeing stored inside also sign contents users can’t modify stored. use feature, must explicitly add router constructing . example, run following sequence commands create router supports encrypted session cookies. used api_session_cookie(), ’ll able use request$session response$session object (point data) read set data transmitted encrypted cookie named cookie_name. example, key used encrypt data \"my_secret_here\", work since 32-bit key required security reasons. can construct compliant key reqres::random_key store securely using keyring package. Unlike response$set_header(), values attached session data serialized via jsonlite; ’re free use complex data structures like lists session. However, deserializing done “blindly” using jsonlite::fromJSON() always verify type conversion done correctly storing ambiguous values (e.g. storing \"5\" (string) get deserialized 5 (number) next request). example, ’ll store encrypted cookie counts many times client visited particular endpoint: , need setup api using api_session_cookie() function code work. inspect cookie set browser, ’ll find value encrypted time gets client. time arrives Plumber, cookie available regular R list can read modified. session cookies great way store state without setting additional facilities server, aware session cookie transmitted request/response need encrypted decrypted every time (last part happens try read though). Using thus adds server load weigh pros cons managing session state .","code":"#* @put /preferences #* @body capital:integer* function(response, body) {   response$set_cookie(\"capitalize\", body$capital) }  #* @get /letter function(request) {   capitalize <- request$cookies$capitalize    # Default to lower-case unless user preference is capitalized   alphabet <- letters    # The capitalize cookie will initially be empty (NULL)   if (!is.null(capitalize) && capitalize == \"1\"){     alphabet <- LETTERS   }    list(     letter = sample(alphabet, 1)   ) } {   \"letter\": [     \"k\"   ] } api(\"myfile.R\") %>%   api_session_cookie(\"my_secret_here\", \"cookie_name\", ...) %>%   api_run() #* @get /sessionCounter function(request){   count <- 0   if (!is.null(request$session$counter)){     count <- as.numeric(request$session$counter)   }   request$session$counter <- count + 1   paste0(\"This is visit #\", count) }"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"setting-unencrypted-cookies","dir":"Articles","previous_headings":"","what":"Setting Unencrypted Cookies","title":"Rendering Output","text":"Plumber can set receive plaint-text cookies. API endpoint return random letter, remembers preferences whether like capitalized lower-case letters. Since API using PUT request test API, ’ll use curl command line test . (’s nothing cookies necessitates PUT requests; just easily modify API use GET request.) can start visiting /letter endpoint ’ll see API defaults lower-case alphabet. curl http://localhost:8080/letter send PUT request specify capital parameter, cookie set client allow server accommodate preference future requests. curl, need specify file want save cookies using -c option. good reminder clients handle cookies differently – won’t support – sure clients intend support API play nicely cookies want use . send PUT request, setting parameter capital 1, invoke: curl -c cookies.txt -X PUT --data 'capital=1' \"http://localhost:8800/preferences\". print cookies.txt file, now see contains single cookie called capitalize value 1. can make another GET request /letter see accommodates preferences. ’ll need tell curl use cookies file just created sending request using -b switch: curl -b cookies.txt http://localhost:8080/letter. now see API returning random capitalized letter. set_cookie method accepts variety additional options customize cookie handled client. default, cookies set session lifetime, meaning cookie persist user’s browser client closes tab point cookie deleted. can customize setting expires max_age parameter set_cookie using either date number seconds future cookie expire. options can set cookie include path (path domain cookie installed client); http_only (controls whether cookie accessible JavaScript running domain – TRUE means cookie HTTP-, accessible JavaScript); secure (TRUE, instructs browser send cookie HTTPS, insecure HTTP. ’re using cookies infer security-sensitive properties (identify user, determine resources client access ), sure see Security article – particular section security implications cookies.","code":"#* @put /preferences #* @body capital:integer* function(response, body) {   response$set_cookie(\"capitalize\", body$capital) }  #* @get /letter function(request) {   capitalize <- request$cookies$capitalize    # Default to lower-case unless user preference is capitalized   alphabet <- letters    # The capitalize cookie will initially be empty (NULL)   if (!is.null(capitalize) && capitalize == \"1\"){     alphabet <- LETTERS   }    list(     letter = sample(alphabet, 1)   ) } {   \"letter\": [     \"k\"   ] }"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"encrypted-cookies","dir":"Articles","previous_headings":"","what":"Setting Encrypted Cookies","title":"Rendering Output","text":"addition storing plain-text cookies, Plumber also supports handling cookies encrypted. Encrypted cookies prevent users seeing stored inside also sign contents users can’t modify stored. use feature, must explicitly add router constructing . example, run following sequence commands create router supports encrypted session cookies. used api_session_cookie(), ’ll able use request$session response$session object (point data) read set data transmitted encrypted cookie named cookie_name. example, key used encrypt data \"my_secret_here\", work since 32-bit key required security reasons. can construct compliant key reqres::random_key store securely using keyring package. Unlike response$set_header(), values attached session data serialized via jsonlite; ’re free use complex data structures like lists session. However, deserializing done “blindly” using jsonlite::fromJSON() always verify type conversion done correctly storing ambiguous values (e.g. storing \"5\" (string) get deserialized 5 (number) next request). example, ’ll store encrypted cookie counts many times client visited particular endpoint: , need setup api using api_session_cookie() function code work. inspect cookie set browser, ’ll find value encrypted time gets client. time arrives Plumber, cookie available regular R list can read modified. session cookies great way store state without setting additional facilities server, aware session cookie transmitted request/response need encrypted decrypted every time (last part happens try read though). Using thus adds server load weigh pros cons managing session state .","code":"api(\"myfile.R\") %>%   api_session_cookie(\"my_secret_here\", \"cookie_name\", ...) %>%   api_run() #* @get /sessionCounter function(request){   count <- 0   if (!is.null(request$session$counter)){     count <- as.numeric(request$session$counter)   }   request$session$counter <- count + 1   paste0(\"This is visit #\", count) }"},{"path":"https://plumber2.posit.co/articles/rendering-output.html","id":"documenting-responses","dir":"Articles","previous_headings":"","what":"Documenting responses","title":"Rendering Output","text":"TBD","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"endpoints","dir":"Articles","previous_headings":"","what":"Handlers","title":"Routing & Input","text":"Handlers standard R functions gets executed request received matches ’s path (assuming specific handler present route). create endpoint annotating function like : annotation specifies function responsible generating response GET request /hello. value returned function used response request (run serializer e.g. convert response JSON). case, GET response /hello return content [\"hello world\"] application/json Content-Type (unless request include preference another return format). annotations generate endpoint include: @get @post @put @delete @head map HTTP methods API client might send along request. default open page web browser, sends GET request API. can use API clients (even JavaScript inside web browser) form HTTP requests using methods listed . conventions around methods used can read . Note conventions carry security implications, ’s good idea follow recommended uses method fully understand might deviate . Note single endpoint can support multiple verbs. following function used service incoming GET, POST, PUT request /cars. also special method @make handler respond method matches path. can useful e.g. authentication handler needs called every request comes .","code":"#* Return \"hello world\" #* @get /hello function() {   \"hello world\" } #* @get /cars #* @post /cars #* @put /cars function(){   ... }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"handler-methods","dir":"Articles","previous_headings":"","what":"Handler methods","title":"Routing & Input","text":"annotations generate endpoint include: @get @post @put @delete @head map HTTP methods API client might send along request. default open page web browser, sends GET request API. can use API clients (even JavaScript inside web browser) form HTTP requests using methods listed . conventions around methods used can read . Note conventions carry security implications, ’s good idea follow recommended uses method fully understand might deviate . Note single endpoint can support multiple verbs. following function used service incoming GET, POST, PUT request /cars. also special method @make handler respond method matches path. can useful e.g. authentication handler needs called every request comes .","code":"#* @get /cars #* @post /cars #* @put /cars function(){   ... }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"paths","dir":"Articles","previous_headings":"","what":"Paths","title":"Routing & Input","text":"heart routing path handler gets assigned . Apart static paths /cars saw selected exact match, possible create dynamic paths responds set paths sharing common structure. Dynamic paths allow handlers define flexible set paths match. common REST convention include identifier object API paths associated . lookup information user #13, might make GET request path /users/13. Rather register handlers every user API might possibly encounter, can use dynamic path associate handler variety paths. API uses dynamic path /users/<id> match request form /users/ followed path element like number letters. case, return information user user associated ID found, empty object . can name dynamic path elements however ’d like, note name used dynamic path must match name argument handler (case, id). can even complex dynamic routes like: Often path parameters need allow provide dynamic structured path extract parameters input. However, plumber2 also support path wildcards can match anything pass . Conceptually works like * file globbing .* regular expressions. example , handler match /images/index.html, /images/february/img_03.png, /images/metadata/ path starts /images/. Wildcards needs , .e. can’t path like /imag* match anything starts /imag (like /images/ /imaginary). However, need end, path like /*/robot.txt matches path ends robot.txt. fact “unspecific” well doesn’t give rise argument input handler means wildcards used much less frequently can indispensable tool belt situations. discussed , every route select one handler request. However, existence path parameters path wildcards means route can easily contain multiple handlers can match given request. route decide one wins? Internally route order handlers based three metrics: specificity (.e. number elements path) - higher better, number path parameters - lower better, number wildcards - lower better. Consider following paths /path//something/specific /path//<name>/specific /path//<name>/<setting> /path//something/* /path/* ordered route order , highest priority top. means request /path//something/specific get matched first path, even though matches given paths. /path//anything/specific get matched second path even though matches second, third fifth, . may seem complicated figure handler gets request, priority ordering designed way generally matches ’d rank specificity set paths.","code":"users <- data.frame(   uid = c(12, 13),   username = c(\"kim\", \"john\") )  #* Lookup a user #* @get /users/<id> function(id) {   subset(users, uid %in% id) } #* @get /user/<from>/connect/<to> function(from, to){   # Do something with the `from` and `to` variables... } #* @get /images/* function() {   # do something }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"path-parameters","dir":"Articles","previous_headings":"","what":"Path parameters","title":"Routing & Input","text":"common REST convention include identifier object API paths associated . lookup information user #13, might make GET request path /users/13. Rather register handlers every user API might possibly encounter, can use dynamic path associate handler variety paths. API uses dynamic path /users/<id> match request form /users/ followed path element like number letters. case, return information user user associated ID found, empty object . can name dynamic path elements however ’d like, note name used dynamic path must match name argument handler (case, id). can even complex dynamic routes like:","code":"users <- data.frame(   uid = c(12, 13),   username = c(\"kim\", \"john\") )  #* Lookup a user #* @get /users/<id> function(id) {   subset(users, uid %in% id) } #* @get /user/<from>/connect/<to> function(from, to){   # Do something with the `from` and `to` variables... }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"path-wildcard","dir":"Articles","previous_headings":"","what":"Path wildcard","title":"Routing & Input","text":"Often path parameters need allow provide dynamic structured path extract parameters input. However, plumber2 also support path wildcards can match anything pass . Conceptually works like * file globbing .* regular expressions. example , handler match /images/index.html, /images/february/img_03.png, /images/metadata/ path starts /images/. Wildcards needs , .e. can’t path like /imag* match anything starts /imag (like /images/ /imaginary). However, need end, path like /*/robot.txt matches path ends robot.txt. fact “unspecific” well doesn’t give rise argument input handler means wildcards used much less frequently can indispensable tool belt situations.","code":"#* @get /images/* function() {   # do something }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"path-priority","dir":"Articles","previous_headings":"","what":"Path priority","title":"Routing & Input","text":"discussed , every route select one handler request. However, existence path parameters path wildcards means route can easily contain multiple handlers can match given request. route decide one wins? Internally route order handlers based three metrics: specificity (.e. number elements path) - higher better, number path parameters - lower better, number wildcards - lower better. Consider following paths /path//something/specific /path//<name>/specific /path//<name>/<setting> /path//something/* /path/* ordered route order , highest priority top. means request /path//something/specific get matched first path, even though matches given paths. /path//anything/specific get matched second path even though matches second, third fifth, . may seem complicated figure handler gets request, priority ordering designed way generally matches ’d rank specificity set paths.","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"input-handling","dir":"Articles","previous_headings":"","what":"Handler input","title":"Routing & Input","text":"Plumber routes requests based exclusively path method incoming HTTP request, requests can contain much information just . might include additional HTTP headers, query string, request body. fields may viewed “inputs” Plumber API. general think inputs function R think arguments function. plumber2 certain rules around arguments handler function determines kind input handler gets access . importantly perhaps, path parameters provided directly handler named arguments. example, given following handler request /user/123/setting/security call handler function user = \"123\" type = \"security\". Path arguments documented @param tag may also know roxygen documentation. Path parameters type variable handler arguments. predefined can included leisure handler needs access . following ’ll get overview : query string may appended URL order convey additional information beyond just request route. Query strings allow encoding character string keys values. example, URL https://duckduckgo.com/?q=bread&pretty=1, everything following ? constitutes query string. case, two variables (q pretty) set (bread 1, respectively). Plumber automatically parse query string make available query argument handler function. following example defines search API mimics example DuckDuckGo merely prints receives. Visiting http://localhost:8080/?q=bread&pretty=1 print: handler use %||% provide fallback value case query parameter weren’t provided. Later ’ll learn provide default values mark parameters required. Since query string “open” sense user can send anything along query value can contain multitude values handler isn’t expecting. values may meant handlers routes may included error. open nature good practice document query parameters handler understand. done @query tag works much like @param. API may need array-like input query string. plumber2 understands two forms providing array data: Either providing parameter multiple times, e.g. ?arg=1&arg=2&arg=3, separating values comma, e.g. ?arg=1,2,3. latter approach condensed become quite unwieldy large amount data. top web browsers impose limitations length URL. Internet Explorer, particular, caps query string 2,048 characters. , larger amount data better served request body. Another way provide additional information inside HTTP request using message body. Effectively, client specifies metadata request (path ’s trying reach, HTTP headers, etc.) can provide message body. maximum size request body depends largely technologies involved (client, proxies, etc.) typically least 2MB – much larger query string. approach commonly seen PUT, POST, PATCH requests, though encounter HTTP methods. Plumber attempt parse request body using best matching parser provided handler one @parser tags. parsers provided plumber2 try registered parsers. result parsing made available body argument. can document expectations around request body using @body tag works much like @param @query. Plumber2 comes selection parsers common data transfer formats: can also provide parsers register can reference name. two special names can use: none .... setting @parser none parsing request body attempted. can still done manually request later stage. may seem like good idea set @parser none intend use request body handler order speed processing, necessary since body parsed code tries access . Setting @parser ... selects parsers yet referenced handler block. can useful registered alternative parser specific mime type wish move top list selected one provided plumber. example : give handler access parsers registered plumber2 select artisinal_json_parser json content type application/json. register new parsers using register_parser(), can also provide directly block annotation like : However, probably better registering parser rather redefine every time need Unfortunately, crafting request message body requires bit work making GET request query string web browser, can use tools like curl command line httr2 R package. ’ll use curl examples . Running curl --data \"id=123&name=Jennifer\" -H \"Content-Type: application/x-www-form-urlencoded\" \"http://localhost:8080/user\" return: Alternatively, echo {\"id\":123, \"name\": \"Jennifer\"} > call.json & curl --data @call.json \"http://localhost:8080/user\" -H \"content-type: application/json\" (formatting body JSON) effect. request argument contains request object. plumber2 object provided reqres package thedocumentation gives great overview information contains. special interest headers, cookies, session field gives access additional input otherwise available handler arguments. cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session. HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name. Like request argument, response argument holds object encapsulates response constructed. also provided reqres extensive documentation . See article rendering output various way may want interact response. server argument handler populated Plumber API object. can use logging, accessing server data store, etc. See documentation fiery webpage get overview possible Plumber automatically tries keep track clients tries access ’s API. setting cookie first time request comes new client giving unique id. id passed handlers client_id argument.","code":"#* @get /user/<user>/setting/<type> function(user, type) {   # ... } #* @get / function(query) {   paste0(\"The q parameter is '\", query$q %||% \"\", \"'. \",          \"The pretty parameter is '\", query$pretty %||% 0, \"'.\") } [   \"The q parameter is 'bread'. The pretty parameter is '1'.\" ] #* @parser artisinal_json_parser #* @parser ... #* @parser application/toml function(x, ...) blogdown::read_toml(x = rawToChar(x)) #* @post /user function(body) {   list(     id = body$id,     name = body$name   ) } {   \"id\": [     \"123\"   ],   \"name\": [     \"Jennifer\\n\"   ] } #* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"handler-arguments","dir":"Articles","previous_headings":"","what":"Handler arguments","title":"Routing & Input","text":"general think inputs function R think arguments function. plumber2 certain rules around arguments handler function determines kind input handler gets access . importantly perhaps, path parameters provided directly handler named arguments. example, given following handler request /user/123/setting/security call handler function user = \"123\" type = \"security\". Path arguments documented @param tag may also know roxygen documentation. Path parameters type variable handler arguments. predefined can included leisure handler needs access . following ’ll get overview : query string may appended URL order convey additional information beyond just request route. Query strings allow encoding character string keys values. example, URL https://duckduckgo.com/?q=bread&pretty=1, everything following ? constitutes query string. case, two variables (q pretty) set (bread 1, respectively). Plumber automatically parse query string make available query argument handler function. following example defines search API mimics example DuckDuckGo merely prints receives. Visiting http://localhost:8080/?q=bread&pretty=1 print: handler use %||% provide fallback value case query parameter weren’t provided. Later ’ll learn provide default values mark parameters required. Since query string “open” sense user can send anything along query value can contain multitude values handler isn’t expecting. values may meant handlers routes may included error. open nature good practice document query parameters handler understand. done @query tag works much like @param. API may need array-like input query string. plumber2 understands two forms providing array data: Either providing parameter multiple times, e.g. ?arg=1&arg=2&arg=3, separating values comma, e.g. ?arg=1,2,3. latter approach condensed become quite unwieldy large amount data. top web browsers impose limitations length URL. Internet Explorer, particular, caps query string 2,048 characters. , larger amount data better served request body. Another way provide additional information inside HTTP request using message body. Effectively, client specifies metadata request (path ’s trying reach, HTTP headers, etc.) can provide message body. maximum size request body depends largely technologies involved (client, proxies, etc.) typically least 2MB – much larger query string. approach commonly seen PUT, POST, PATCH requests, though encounter HTTP methods. Plumber attempt parse request body using best matching parser provided handler one @parser tags. parsers provided plumber2 try registered parsers. result parsing made available body argument. can document expectations around request body using @body tag works much like @param @query. Plumber2 comes selection parsers common data transfer formats: can also provide parsers register can reference name. two special names can use: none .... setting @parser none parsing request body attempted. can still done manually request later stage. may seem like good idea set @parser none intend use request body handler order speed processing, necessary since body parsed code tries access . Setting @parser ... selects parsers yet referenced handler block. can useful registered alternative parser specific mime type wish move top list selected one provided plumber. example : give handler access parsers registered plumber2 select artisinal_json_parser json content type application/json. register new parsers using register_parser(), can also provide directly block annotation like : However, probably better registering parser rather redefine every time need Unfortunately, crafting request message body requires bit work making GET request query string web browser, can use tools like curl command line httr2 R package. ’ll use curl examples . Running curl --data \"id=123&name=Jennifer\" -H \"Content-Type: application/x-www-form-urlencoded\" \"http://localhost:8080/user\" return: Alternatively, echo {\"id\":123, \"name\": \"Jennifer\"} > call.json & curl --data @call.json \"http://localhost:8080/user\" -H \"content-type: application/json\" (formatting body JSON) effect. request argument contains request object. plumber2 object provided reqres package thedocumentation gives great overview information contains. special interest headers, cookies, session field gives access additional input otherwise available handler arguments. cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session. HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name. Like request argument, response argument holds object encapsulates response constructed. also provided reqres extensive documentation . See article rendering output various way may want interact response. server argument handler populated Plumber API object. can use logging, accessing server data store, etc. See documentation fiery webpage get overview possible Plumber automatically tries keep track clients tries access ’s API. setting cookie first time request comes new client giving unique id. id passed handlers client_id argument.","code":"#* @get /user/<user>/setting/<type> function(user, type) {   # ... } #* @get / function(query) {   paste0(\"The q parameter is '\", query$q %||% \"\", \"'. \",          \"The pretty parameter is '\", query$pretty %||% 0, \"'.\") } [   \"The q parameter is 'bread'. The pretty parameter is '1'.\" ] #* @parser artisinal_json_parser #* @parser ... #* @parser application/toml function(x, ...) blogdown::read_toml(x = rawToChar(x)) #* @post /user function(body) {   list(     id = body$id,     name = body$name   ) } {   \"id\": [     \"123\"   ],   \"name\": [     \"Jennifer\\n\"   ] } #* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"query","dir":"Articles","previous_headings":"","what":"query","title":"Routing & Input","text":"query string may appended URL order convey additional information beyond just request route. Query strings allow encoding character string keys values. example, URL https://duckduckgo.com/?q=bread&pretty=1, everything following ? constitutes query string. case, two variables (q pretty) set (bread 1, respectively). Plumber automatically parse query string make available query argument handler function. following example defines search API mimics example DuckDuckGo merely prints receives. Visiting http://localhost:8080/?q=bread&pretty=1 print: handler use %||% provide fallback value case query parameter weren’t provided. Later ’ll learn provide default values mark parameters required. Since query string “open” sense user can send anything along query value can contain multitude values handler isn’t expecting. values may meant handlers routes may included error. open nature good practice document query parameters handler understand. done @query tag works much like @param. API may need array-like input query string. plumber2 understands two forms providing array data: Either providing parameter multiple times, e.g. ?arg=1&arg=2&arg=3, separating values comma, e.g. ?arg=1,2,3. latter approach condensed become quite unwieldy large amount data. top web browsers impose limitations length URL. Internet Explorer, particular, caps query string 2,048 characters. , larger amount data better served request body.","code":"#* @get / function(query) {   paste0(\"The q parameter is '\", query$q %||% \"\", \"'. \",          \"The pretty parameter is '\", query$pretty %||% 0, \"'.\") } [   \"The q parameter is 'bread'. The pretty parameter is '1'.\" ]"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"body","dir":"Articles","previous_headings":"","what":"body","title":"Routing & Input","text":"Another way provide additional information inside HTTP request using message body. Effectively, client specifies metadata request (path ’s trying reach, HTTP headers, etc.) can provide message body. maximum size request body depends largely technologies involved (client, proxies, etc.) typically least 2MB – much larger query string. approach commonly seen PUT, POST, PATCH requests, though encounter HTTP methods. Plumber attempt parse request body using best matching parser provided handler one @parser tags. parsers provided plumber2 try registered parsers. result parsing made available body argument. can document expectations around request body using @body tag works much like @param @query. Plumber2 comes selection parsers common data transfer formats: can also provide parsers register can reference name. two special names can use: none .... setting @parser none parsing request body attempted. can still done manually request later stage. may seem like good idea set @parser none intend use request body handler order speed processing, necessary since body parsed code tries access . Setting @parser ... selects parsers yet referenced handler block. can useful registered alternative parser specific mime type wish move top list selected one provided plumber. example : give handler access parsers registered plumber2 select artisinal_json_parser json content type application/json. register new parsers using register_parser(), can also provide directly block annotation like : However, probably better registering parser rather redefine every time need Unfortunately, crafting request message body requires bit work making GET request query string web browser, can use tools like curl command line httr2 R package. ’ll use curl examples . Running curl --data \"id=123&name=Jennifer\" -H \"Content-Type: application/x-www-form-urlencoded\" \"http://localhost:8080/user\" return: Alternatively, echo {\"id\":123, \"name\": \"Jennifer\"} > call.json & curl --data @call.json \"http://localhost:8080/user\" -H \"content-type: application/json\" (formatting body JSON) effect.","code":"#* @parser artisinal_json_parser #* @parser ... #* @parser application/toml function(x, ...) blogdown::read_toml(x = rawToChar(x)) #* @post /user function(body) {   list(     id = body$id,     name = body$name   ) } {   \"id\": [     \"123\"   ],   \"name\": [     \"Jennifer\\n\"   ] }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"request","dir":"Articles","previous_headings":"","what":"request","title":"Routing & Input","text":"request argument contains request object. plumber2 object provided reqres package thedocumentation gives great overview information contains. special interest headers, cookies, session field gives access additional input otherwise available handler arguments. cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session. HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name.","code":"#* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"read-cookies","dir":"Articles","previous_headings":"","what":"Cookies","title":"Routing & Input","text":"cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session.","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"headers","dir":"Articles","previous_headings":"","what":"Headers","title":"Routing & Input","text":"HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name.","code":"#* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"response","dir":"Articles","previous_headings":"","what":"response","title":"Routing & Input","text":"Like request argument, response argument holds object encapsulates response constructed. also provided reqres extensive documentation . See article rendering output various way may want interact response.","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"server","dir":"Articles","previous_headings":"","what":"server","title":"Routing & Input","text":"server argument handler populated Plumber API object. can use logging, accessing server data store, etc. See documentation fiery webpage get overview possible","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"client_id","dir":"Articles","previous_headings":"","what":"client_id","title":"Routing & Input","text":"Plumber automatically tries keep track clients tries access ’s API. setting cookie first time request comes new client giving unique id. id passed handlers client_id argument.","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"typed-dynamic-routes","dir":"Articles","previous_headings":"","what":"Type casting input","title":"Routing & Input","text":"Path query paramters comes text string, provided string handler. However, can provide type hints plumber automatically cast expected type providing handler. Consider following API. Visiting http://localhost:8080/type/14 return: intend support particular data type particular parameter dynamic route, can specify desired type path , @param field. syntax : Anything following first : name parameter. Anything following type specification. following details mapping scalar type names can use dynamic types map R data types. can also specify array, enclosing [...], (e.g. [integer] array integers). Arrays can even nested (e.g. [[integer]] array arrays integers). Lastly, possible specify “object”, cast lists R. syntax {name:Type, ...} (e.g. {eruptions:[number], waiting:[number]} faithful dataset) allows provide concise specifications complex data structures. unlikely ’ll need objects path query parameters, request bodies often form object. R used providing default values function arguments. plumber can adding default value parenthesis type specification, e.g. integer(10). type caster automatically ensure value inserted missing query body request can assume always present code. Path parameters always required. , can’t arrive handler path parameter missing. query body parameters assumed optional, can mark required well adding * type, like [number]*. required parameter missing type converter automatically throw error return 400 client. aware required parameter default value logical fallacy.","code":"#* @get /type/<id> function(id) {   list(     id = id,     type = typeof(id)   ) } {   \"id\": [     \"14\"   ],   \"type\": [     \"character\"   ] } #* @get /user/<id:integer> function(id){   next <- id + 1   # ... }  #* @post /user/activated/<active> #* @param active:boolean Whether the user is active function(active){   if (!active){     # ...   } }"},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"defaults","dir":"Articles","previous_headings":"","what":"Defaults","title":"Routing & Input","text":"R used providing default values function arguments. plumber can adding default value parenthesis type specification, e.g. integer(10). type caster automatically ensure value inserted missing query body request can assume always present code.","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"required-parameters","dir":"Articles","previous_headings":"","what":"Required parameters","title":"Routing & Input","text":"Path parameters always required. , can’t arrive handler path parameter missing. query body parameters assumed optional, can mark required well adding * type, like [number]*. required parameter missing type converter automatically throw error return 400 client. aware required parameter default value logical fallacy.","code":""},{"path":"https://plumber2.posit.co/articles/routing-and-input.html","id":"static-file-handler","dir":"Articles","previous_headings":"","what":"Static File Handler","title":"Routing & Input","text":"Plumber includes static file server can used host directories static assets JavaScript, CSS, HTML files. servers fairly simple configure integrate plumber application. example expose local directory ./files/static root / path server. file ./files/static/branding.html, available Plumber server /branding.html. can optionally provide additional argument configure path used server. instance expose local directory files/static /, /static.","code":"#* @assets ./files/static NULL #* @assets ./files/static /static NULL"},{"path":"https://plumber2.posit.co/articles/security.html","id":"networking","dir":"Articles","previous_headings":"","what":"Networking & Firewalls","title":"Security","text":"networking standpoint, two fundamentally different approaches developing R code. can develop locally using tool like RStudio Desktop. case, R session (Plumber APIs run()) housed local machine. can develop remote machine using tool like RStudio Server. , R session running remote server accessed across network. first case, ’s typically little consider networking perspective. APIs accessible http://127.0.0.1:8080 default (localhost synonymous local IP address 127.0.0.1) likely won’t need concern firewalls network proxies. second case, however, may need consider network environment server running API. considerations ’ll need make hosting API server production use. particular, investigate whether firewalls server hosting Plumber API clients want able connect. Firewalls way block undesired network traffic. desktop computers many servers come firewalls enabled ---box. means want expose API running port 8080, need configure firewall accept incoming connections port. Firewalls can also configured network intermediaries, may need configure multiple firewalls allow traffic order expose desired port API clients.","code":""},{"path":"https://plumber2.posit.co/articles/security.html","id":"https","dir":"Articles","previous_headings":"","what":"HTTPS","title":"Security","text":"HTTPS secure form HTTP. Many people now aware check browser displays padlock associated HTTPS enter sensitive information like credit card number. HTTPS important consider developing Plumber APIs, well. HTTPS primarily offers two protections: encrypts information sent API client Plumber process using TLS (often still referred predecessor, “SSL”). prevents others network able read information sent back forth. gives API client confidence ’s communicating Plumber process, opposed imposter. two assurances critical API handling sensitive data performing actions intended authenticated users. hosting options support serving HTTP HTTPS simultaneously. secure configuration redirect incoming HTTP traffic HTTPS hosting option. added layer protection, can consider enabling HTTP Strict Transport Security (HSTS). HSTS way instruct clients – future – refuse connect server unsecure HTTP. ensures imposter server able trick client connecting insecure HTTP future. Unfortunately, Plumber implement HTTPS support natively, hosting options offer ways deploy HTTPS HSTS front Plumber API.","code":""},{"path":"https://plumber2.posit.co/articles/security.html","id":"dos","dir":"Articles","previous_headings":"","what":"Denial Of Service (DoS)","title":"Security","text":"Denial service (DoS) attacks employed order temporarily shut server service overwhelming traffic. DoS scenario caused single ignorant user unintentionally making request ask server impossible task, intentionally introduced malicious actor leveraging vast number machines repeatedly make requests expensive server respond . later form often called distributed denial service attack (DDoS) typically requires special infrastructure network capacity beyond scope ’ll discuss . However, practices employ designing Plumber API put safety guards around work API request might instigate. expected output harmless plot.  plot takes negligible amount time create. However, plots points take time create.  plot, 10,000 points added, took 0.202 seconds generate. doesn’t sound like much, exposed API publicly Internet, attacker easily generate enough traffic endpoint overwhelm Plumber process. Even worse, attacker make request endpoint millions billions points might cause server run memory consume much CPU deprives important system resources. Either case result Plumber process crashing altogether. solution, case, ensure reasonable safety guards place user input. can see allow user request graph 1,000 points. requests exceeding limit immediately terminated without computation. attentive resources consumed filters endpoints. Consider various values user provide API endpoint’s parameters ensure behavior system reasonable cases. API endpoints require extensive computation, consider protect endpoints (perhaps exposing authenticated users) prevent malicious user abusing system.","code":"#* This is an example of an UNSAFE endpoint which #* is vulnerable to a DOS attack. #* @get / #* @query pts:integer(10) #* @serializer png function(query) {   # An example of an UNSAFE endpoint.   plot(1:query$pts) } #* This is an example of an safe endpoint which #* checks user input to avoid a DOS attack #* @get / #* @query pts:integer(10) #* @serializer png function(query) {   if (query$pts > 1000 & query$pts < 1){     abort_bad_request(\"pts must be between 1 and 1,000\")   }   plot(1:pts) }"},{"path":"https://plumber2.posit.co/articles/security.html","id":"sanitization","dir":"Articles","previous_headings":"","what":"Sanitization & Injection","title":"Security","text":"time accept input user code, plan worst-case scenario. , example, API endpoint allows user specify name file read particular directory returns contents, might naively implement like . Unfortunately, API endpoint properly sanitize user input. user set file parameter ../plumber.R now endpoint return source code Plumber API. course just easy attempt read files might contain API keys sensitive data. One solution case strip special characters user input prevent users able escape different directory. File paths opportunity malicious input damage system, however. Another way user input can dangerous attack known “cross site scripting,” “XSS.” attack can leveraged whenever user input may rendered user’s browser. instance endpoint allows users comment page later displays comments users, attacked craft comment : can see, comment JavaScript embedded within , case used popup message user. course JavaScript used harmful way redirecting users malicious site, instance, uploading data special access server destination. user input might included HTML page properly escaped (see htmltools::html_escape help). Lastly, user input can used “injection attack,” user injects malicious commands might sent another system. best known family SQL injection attacks, user input meant included SQL query executed database might contain additional SQL commands leak data damage database. details SQL injection attacks mitigation strategies R available . summary, sure separate “trusted” “untrusted” objects API implementation. Anything user provides considered “untrusted” escaped sanitized. point can consider object “trusted” proceed take actions .","code":"#* This is an example of an UNSAFE endpoint which #* does not sanitize user input #* @get / #* @query file:string* function(query) {    # An example of an UNSAFE endpoint.   path <- file.path(\"./datasets\", query$file)   readLines(path) } #* This is an example of an endpoint which #* checks user input. #* @get / #* @query file:string* function(query) {   # Strip all \"non-word\" characters from user input   sanitizedFile <- gsub(\"\\\\W\", \"\", query$file)    path <- file.path(\"./datasets\", sanitizedFile)   readLines(path) } \"This is a comment with JavaScript! <script>alert('I could do something bad here!');<\/script>"},{"path":"https://plumber2.posit.co/articles/security.html","id":"security-headers","dir":"Articles","previous_headings":"","what":"Security Headers","title":"Security","text":"plumber2 API use HTTP protocol communicate client. cause internets existence cat--mouse game going bad actors wish scam otherwise harm users, people developing internet safe experience. lot improvements security implemented specific HTTP headers server opt certain behavior safer client. plumber2 provides easy way set headers provides good sensible defaults well. code apply default settings API. However, urge developer spend time getting acquainted concepts around various headers. Especially, relevant API serving HTML pages, many plumber2 APIs aren’t, can thus turned save bit packet size thus improve latency. can read headers well understand relevant reading documentation firesafety::SecurityHeaders.","code":"pa <- api() |>    api_security_headers()"},{"path":"https://plumber2.posit.co/articles/security.html","id":"cross-origin-resource-sharing-cors","dir":"Articles","previous_headings":"","what":"Cross-Origin Resource Sharing (CORS)","title":"Security","text":"Cross-Origin Resource Sharing technology control webpages allowed access resources hosted another domain. general, try limit much possible avoid webpages imitating webpages spoof end user, reasons. Since generally good idea, CORS turned default. means webpage needs communicate API (API hosted another domain), need allow CORS. Setting CORS can done annotation code. annotation approach easy allows keep CORS settings close endpoint defined. set adding @cors tag annotation followed allowed interact endpoint. can either * allow everyone, specific origin whitelist. annotation somewhat limited need power define CORS specification can programmatically api_security_cors() function. can also specify headers allowed exposed, along allowing credentials pass set maximum time CORS agreement can kept cache. can read CORS documentation firesafety::CORS.","code":"#* @get /sensitive/info #* @cors https://I-trust-you.com function(...) {   # endpoint logic }"},{"path":"https://plumber2.posit.co/articles/security.html","id":"resource-isolation-policies","dir":"Articles","previous_headings":"","what":"Resource Isolation Policies","title":"Security","text":"Setting resource isolation policies can complement CORS denying access resources protected CORS. prevents, server level, access resources thus technology relies browser implementations (CORS ). ’s important state decision CORS resource isolation two sides coin. Like CORS, resource isolation can set annotation using @rip. Rather providing allowed origin like CORS, specify allowance level (cross-site, -site, -origin). Also, like CORS, even control using programmatically api_security_resource_isolation(). can read resource isolation policies documentation firesafety::ResourceIsolation.","code":""},{"path":"https://plumber2.posit.co/articles/security.html","id":"security-cookies","dir":"Articles","previous_headings":"","what":"Cookies","title":"Security","text":"section setting cookies, discussed mechanics setting cookies. However, intend use cookies security-sensitive purpose, aware ways cookies can exploited. First foremost, recognize client ability modify fabricate cookies send API. storing preferences user provided cookie concern. Storing something security implications – like identity user making requests – however, ; malicious user just need modify user ID saved cookie order trick API thinking someone ’re . two common workarounds concern. can store session information server identified long, cryptographically random IDs rely cookie store ID (Plumber provides ID client_id argument handler). can use signed/encrypted cookies, detailed section setting encrypted cookies. also aware cookies handled managed clients. can manage properties providing different parameters set_cookie() method response. expires - cookie expire. provide POSIXt object gives time explicitly. value provided (max_age set), cookie session cookie, meaning persist user closes tab/browser. Remember, however, client may accidentally maliciously retain cookie beyond assigned expiration time. security standpoint, rely client well-behaved delete cookie assigned time. max_age - alternative strategy defining life-time cookie. sets number seconds cookie kept active, instead setting termination date/time. concerns expires apply setting. http_only - HttpOnly property cookie determines whether cookie accessible JavaScript running domain. using cookie persist user settings host JavaScript may also leverage preferences stored cookie, want http parameter FALSE, indicating cookie HttpOnly, available JavaScript. storing session ID cookie interpretable server, set http TRUE. variety attacks (“cross-site scripting”) enable attacker run malicious JavaScript clients’ machines, ’s wise limit amount information accessible JavaScript. plumber2, session data cookie client id cookie http-. secure - TRUE, instructs clients send cookie connecting server HTTPS. HTTPS mechanism clients can gain assurance server ’re connected indeed server intended communicating . API uses HTTPS, using secure cookies protects use case attacker tricks one clients connecting HTTP server impersonating API. scenario, client may send cookies malicious server, point attacker use cookies server impersonate actual user. Note shouldn’t enable API stably running HTTPS. Additionally, bear mind attacker gets physical access client valid cookie, attacker copy cookie different machine begin using . Unfortunately, can’t perfectly protect attacks, can minimize impact 1.) using shorter session lifetimes (perhaps hours instead days), 2.) invalidating sessions period user inactivity, 3.) rotating session ID periodically; way ’d able detect multiple clients trying use session take action. can also consider adding additional layer security around security-sensitive endpoints (like changing user’s password). Lastly, using encrypted cookies store sensitive information, remember expiring cookie instruction ’re sending client may may honored. Thus set encrypted cookie client authenticate user user wishes log , can instruct client delete cookie. cookie stolen misbehaving client doesn’t delete cookie, ’s possible cookie still used continue making authenticated requests API.","code":""},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"the-standard","dir":"Articles","previous_headings":"","what":"The standard","title":"_server.yml for framework developers","text":"Recognizing practically impossible define comprehensive standard covers possible settings current future server frameworks R, propose “thin” standard put onus server frameworks give meaningful structure. core standard _server.yml file. file placed root server specification (unsurprisingly) contain YAML formatted definition server setup. required field engine appear first line. element names package responsible launching server installable server. _server.yml file plumber2 api : first line. file can (probably ) additional fields, package named engine interpret standard name additional requirements file. package valid engine _server.yml file must adhere one requirement: function, launch_server(settings, host = NULL, port = NULL, ...), takes path _server.yml file first argument, ip address launch server second, port serve third. function needs exported. launch_server() function responsible making sense provided _server.yml file error malformed according expectations engine sets. function launch server blocking fashion, .e. return control R long server runs. server support serving _server.yml-defined R servers, check existence file root deployment. read engine field install named package. use launch_server() function launch server. simple example logic provided error handling anything.","code":"engine: plumber2 if (file.exist(\"_server.yml\")) {   # Figure out the engine for the server   # You could probably easily do this without the yaml package   engine <- yaml::read_yaml(\"_server.yml\")$engine    # Install the engine if not already available   if (!requireNamespace(engine, quietly = TRUE)) {     install.packages(engine)   }      # Find the launch_server() function in the engine   launch_server <- get(     \"launch_server\",      envir = asNamespace(engine),      mode = \"function\"   )    # Use the function to launch the server   launch_server(     settings = \"_server.yml\",      host = HOST_ADDR, # Variable holding the ip address     port = PORT_NO    # Variable holding the port number   ) } else {   # Logic for other types of server specifications }"},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"the-_server-yml-file","dir":"Articles","previous_headings":"","what":"The _server.yml file","title":"_server.yml for framework developers","text":"core standard _server.yml file. file placed root server specification (unsurprisingly) contain YAML formatted definition server setup. required field engine appear first line. element names package responsible launching server installable server. _server.yml file plumber2 api : first line. file can (probably ) additional fields, package named engine interpret standard name additional requirements file.","code":"engine: plumber2"},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"the-engine","dir":"Articles","previous_headings":"","what":"The engine","title":"_server.yml for framework developers","text":"package valid engine _server.yml file must adhere one requirement: function, launch_server(settings, host = NULL, port = NULL, ...), takes path _server.yml file first argument, ip address launch server second, port serve third. function needs exported. launch_server() function responsible making sense provided _server.yml file error malformed according expectations engine sets. function launch server blocking fashion, .e. return control R long server runs.","code":""},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"the-server","dir":"Articles","previous_headings":"","what":"The server","title":"_server.yml for framework developers","text":"server support serving _server.yml-defined R servers, check existence file root deployment. read engine field install named package. use launch_server() function launch server. simple example logic provided error handling anything.","code":"if (file.exist(\"_server.yml\")) {   # Figure out the engine for the server   # You could probably easily do this without the yaml package   engine <- yaml::read_yaml(\"_server.yml\")$engine    # Install the engine if not already available   if (!requireNamespace(engine, quietly = TRUE)) {     install.packages(engine)   }      # Find the launch_server() function in the engine   launch_server <- get(     \"launch_server\",      envir = asNamespace(engine),      mode = \"function\"   )    # Use the function to launch the server   launch_server(     settings = \"_server.yml\",      host = HOST_ADDR, # Variable holding the ip address     port = PORT_NO    # Variable holding the port number   ) } else {   # Logic for other types of server specifications }"},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"recommendations-for-_server-yml-engines","dir":"Articles","previous_headings":"","what":"Recommendations for _server.yml engines","title":"_server.yml for framework developers","text":"content besides engine field completely discretion engine developer following recommendations: likely ’d want _server.yml file point one files. Make sure file folder paths interpreted relative location _server.yml path rather working directory R session. aim separation server logic (usually one R files), server settings. end, provide way user record settings _server.yml file need modify implementation files order change run time behavior.","code":""},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"file-paths","dir":"Articles","previous_headings":"","what":"File paths","title":"_server.yml for framework developers","text":"likely ’d want _server.yml file point one files. Make sure file folder paths interpreted relative location _server.yml path rather working directory R session.","code":""},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"options","dir":"Articles","previous_headings":"","what":"Options","title":"_server.yml for framework developers","text":"aim separation server logic (usually one R files), server settings. end, provide way user record settings _server.yml file need modify implementation files order change run time behavior.","code":""},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"case-study-plumber2","dir":"Articles","previous_headings":"","what":"Case study: plumber2","title":"_server.yml for framework developers","text":"plumber2 adheres _server.yml standard following go example engine developers wish support . plumber2 currently defines 3 fields besides engine field: routes: array R files folders contain server logic annotated functions objects. constructor: path single R file constructs Plumber2 object. options: list options use server. corresponds options can seen ?plumber2::all_opts(). plumber2 provide function (create_server_yml()) creates file user can confident formatted correctly. generally good idea also provides place document content file. launch_server() function quite simple plumber2 since api() constructor understands _server.yml files input. function looks like :","code":"plumber2:::launch_server #> function (settings, host = NULL, port = NULL, ...) #> { #>     pa <- api(settings) #>     if (!is.null(host)) { #>         pa$host <- host #>     } #>     if (!is.null(port)) { #>         pa$port <- port #>     } #>     api_run(pa) #> } #> <bytecode: 0x55a8385a1c08> #> <environment: namespace:plumber2>"},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"yaml-content","dir":"Articles","previous_headings":"","what":"YAML content","title":"_server.yml for framework developers","text":"plumber2 currently defines 3 fields besides engine field: routes: array R files folders contain server logic annotated functions objects. constructor: path single R file constructs Plumber2 object. options: list options use server. corresponds options can seen ?plumber2::all_opts(). plumber2 provide function (create_server_yml()) creates file user can confident formatted correctly. generally good idea also provides place document content file.","code":""},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"launch_server","dir":"Articles","previous_headings":"","what":"launch_server()","title":"_server.yml for framework developers","text":"launch_server() function quite simple plumber2 since api() constructor understands _server.yml files input. function looks like :","code":"plumber2:::launch_server #> function (settings, host = NULL, port = NULL, ...) #> { #>     pa <- api(settings) #>     if (!is.null(host)) { #>         pa$host <- host #>     } #>     if (!is.null(port)) { #>         pa$port <- port #>     } #>     api_run(pa) #> } #> <bytecode: 0x55a8385a1c08> #> <environment: namespace:plumber2>"},{"path":"https://plumber2.posit.co/articles/server_yml.html","id":"supported-frameworks","dir":"Articles","previous_headings":"","what":"Supported frameworks","title":"_server.yml for framework developers","text":"list R webserver frameworks known support _server.yml standard. developed framework support wish appear , please create pull request addition: plumber2 fiery","code":""},{"path":"https://plumber2.posit.co/articles/tips-and-tricks.html","id":"debugging","dir":"Articles","previous_headings":"","what":"Debugging","title":"Tips & Tricks","text":"’ve historically used R interactively, may find difficult define functions get executed without input Plumber requires. couple debugging techniques aware working Plumber APIs; techniques equally transferable debugging R scripts, packages, reports. programmers first approach debugging adding print statements code order inspect state point. R, print() cat() can used print state. instance, cat(\"currently: \", ) inserted code help ensure variable point code. approach equally viable Plumber. However, plumber comes dedicated logging infrastructure can leveraged well. handler can use server$log() log messages specific events. use logger backend like logger, can set log level allowing filter messages shown. Using warning() message() automatically ends log well also valid logging calls. Similar print debugging, can output plumber knows various stages processing pipeline using event handlers. e.g. add logging calls -request -request logs comes send . example, can add lines route file: execute GET request /stage_debug expect see output like: output shows route /stage_debug calculated value 42 value serialized using json. expect see received response status 200 body containing JSON matching [42]. Print debugging obvious starting point, developers eventually wish something powerful. R, capacity built browser() function. ’re unfamiliar, browser() pauses execution function gives interactive session can inspect current value internal variables even proceed function one statement time. can leverage browser() developing APIs locally adding browser() call one handlers. offers powerful technique use want inspect multiple different variables interact current state things inside function. also good way get hands dirty Plumber get better acquainted things behave low level. Consider following API endpoint: run API locally visit API web browser, ’ll see R session switch debug mode request arrives, allowing look objects contained inside req res objects. usually works, R session can become confused entering debugging mode running server. often better mock request. can create mocked request object using fiery::fake_request() can populate path, method, headers, body content. can take object send API using test_request() method Plumber API object: aware req res objects familiar handlers, rather formats plumber needs use interact httpuv.","code":"#* @plumber function(api) {   api |>     api_on(\"before-request\", function(request, ...) {       cli::cli_inform(request$as_message())     }) |>     api_on(\"after-request\", function(response, ...) {       cli::cli_inform(response$as_message())     }) } #* @get /stage_debug function() {   return(42) } GET /stage_debug HTTP/1.1 Host: localhost:8080 Cookie: fiery_id=e6a4290e84ddd3eb5c429275b24423c87fb8c9ffaee230008a1ae8863cb72760  <No Body>  HTTP/1.1 200 OK Vary: Accept Date: Fri, 21 Mar 2025 08:48:09 GMT Content-Length: 4 Content-Type: application/json  [42] #* @get / function(request, response){   browser()    list(a=123) } pa <- api(\"plumber.R\")  req <- fiery::fake_request(\"http://localhost:8080/path/to/handler\")  res <- pa$test_request(req)"},{"path":"https://plumber2.posit.co/articles/tips-and-tricks.html","id":"print-debugging","dir":"Articles","previous_headings":"","what":"Print Debugging","title":"Tips & Tricks","text":"programmers first approach debugging adding print statements code order inspect state point. R, print() cat() can used print state. instance, cat(\"currently: \", ) inserted code help ensure variable point code. approach equally viable Plumber. However, plumber comes dedicated logging infrastructure can leveraged well. handler can use server$log() log messages specific events. use logger backend like logger, can set log level allowing filter messages shown. Using warning() message() automatically ends log well also valid logging calls.","code":""},{"path":"https://plumber2.posit.co/articles/tips-and-tricks.html","id":"router-stage-debugging","dir":"Articles","previous_headings":"","what":"Router Stage Debugging","title":"Tips & Tricks","text":"Similar print debugging, can output plumber knows various stages processing pipeline using event handlers. e.g. add logging calls -request -request logs comes send . example, can add lines route file: execute GET request /stage_debug expect see output like: output shows route /stage_debug calculated value 42 value serialized using json. expect see received response status 200 body containing JSON matching [42].","code":"#* @plumber function(api) {   api |>     api_on(\"before-request\", function(request, ...) {       cli::cli_inform(request$as_message())     }) |>     api_on(\"after-request\", function(response, ...) {       cli::cli_inform(response$as_message())     }) } #* @get /stage_debug function() {   return(42) } GET /stage_debug HTTP/1.1 Host: localhost:8080 Cookie: fiery_id=e6a4290e84ddd3eb5c429275b24423c87fb8c9ffaee230008a1ae8863cb72760  <No Body>  HTTP/1.1 200 OK Vary: Accept Date: Fri, 21 Mar 2025 08:48:09 GMT Content-Length: 4 Content-Type: application/json  [42]"},{"path":"https://plumber2.posit.co/articles/tips-and-tricks.html","id":"interactive-debugging","dir":"Articles","previous_headings":"","what":"Interactive Debugging","title":"Tips & Tricks","text":"Print debugging obvious starting point, developers eventually wish something powerful. R, capacity built browser() function. ’re unfamiliar, browser() pauses execution function gives interactive session can inspect current value internal variables even proceed function one statement time. can leverage browser() developing APIs locally adding browser() call one handlers. offers powerful technique use want inspect multiple different variables interact current state things inside function. also good way get hands dirty Plumber get better acquainted things behave low level. Consider following API endpoint: run API locally visit API web browser, ’ll see R session switch debug mode request arrives, allowing look objects contained inside req res objects. usually works, R session can become confused entering debugging mode running server. often better mock request. can create mocked request object using fiery::fake_request() can populate path, method, headers, body content. can take object send API using test_request() method Plumber API object: aware req res objects familiar handlers, rather formats plumber needs use interact httpuv.","code":"#* @get / function(request, response){   browser()    list(a=123) } pa <- api(\"plumber.R\")  req <- fiery::fake_request(\"http://localhost:8080/path/to/handler\")  res <- pa$test_request(req)"},{"path":"https://plumber2.posit.co/articles/tips-and-tricks.html","id":"port-range","dir":"Articles","previous_headings":"","what":"Port Range","title":"Tips & Tricks","text":"can use [httpuv::randomPort()] define range port Plumber pick running API. programmatically","code":"# plumber.R options(\"plumber2.port\" = httpuv::randomPort(min = 4000, max = 7000, n = 100))  ### define the rest of your plumber router... api(port = httpuv::randomPort(min = 4000, max = 7000, n = 100)) |>   api_run()"},{"path":"https://plumber2.posit.co/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thomas Lin Pedersen. Author, maintainer. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"https://plumber2.posit.co/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pedersen T (2025). plumber2: Easy Powerful Web Servers. R package version 0.1.0.9000, https://plumber2.posit.co/.","code":"@Manual{,   title = {plumber2: Easy and Powerful Web Servers},   author = {Thomas Lin Pedersen},   year = {2025},   note = {R package version 0.1.0.9000},   url = {https://plumber2.posit.co/}, }"},{"path":"https://plumber2.posit.co/index.html","id":"plumber2-","dir":"","previous_headings":"","what":"Easy and Powerful Web Servers","title":"Easy and Powerful Web Servers","text":"complete rewrite plumber. purpose rewrite take everything ’ve learned plumber, shed bad decision inevitably make course development, start scratch. ’ll find plumber2 similar plumber lot ways, diverts key areas, resulting API incompatibility two packages. may need update plumber APIs switching plumber2.","code":""},{"path":"https://plumber2.posit.co/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Easy and Powerful Web Servers","text":"plumber2 can installed CRAN using install.packages(\"plumber2\"). Alternatively can install development version github using pak","code":"# install.packages(\"pak\") pak::pak(\"posit-dev/plumber2\")"},{"path":"https://plumber2.posit.co/index.html","id":"hello-world","dir":"","previous_headings":"","what":"Hello World","title":"Easy and Powerful Web Servers","text":"simple “hello world” API written plumber2 illustrates differences plumber: can see breaking changes new features action. biggest breaking change parameters coming path, query string, body now clearly separated. parameters path provided direct arguments handler function. Query body parameters accessible query body argument respectively. can seen also use different tags documentation. Speaking documentation, parsing plumber blocks greatly improved. now built upon roxygen2, follows convention, allowing multiline tags defaulting first line title proceeding untagged lines description. ability define input output types also greatly expanded, adding ability define nested objects, adding default values (seen ) define enum (factors) name . input get type checked default value imputed missing. /plot handler can also see specifies multiple serializers. allow client request preferred response format using Accept header. plumber2 perform content negotiation figure best response format based supports client prefers. Lastly, can see new tag (one many) /plot handler. @async allows convert handler async handler automatically. still possible create async handler manually returning promise, new tag significantly simplifies classic cases. still overhead involved handling requests asynchronously mainly good idea longer running handlers, shown example.","code":"#* Echo the parameter that was sent in #* #* @get /echo/<msg> #* #* @param msg:string The message to echo back. #* #* @response 200:{msg:string} A string containing the input message #* function(msg) {   list(     msg = paste0(\"The message is: '\", msg, \"'\")   ) }  #* Plot out data from the palmer penguins dataset #* #* @get /plot #* #* @query spec:enum|Adelie, Chinstrap, Gentoo| If provided, filter the #* data to only this species #* #* @serializer png{width = 700, height = 500} #* @serializer jpeg{width = 700, height = 500} #* #* @async function(query) {   myData <- penguins   title <- \"All Species\"    # Filter if the species was specified   if (!is.null(query$spec)){     title <- paste0(\"Only the '\", query$spec, \"' Species\")     myData <- subset(myData, species == query$spec)     if (nrow(myData) == 0) {       abort_internal_error(\"Missing data for {query$spec}\")     }   }    plot(     myData$flipper_len,     myData$bill_len,     main=title,     xlab=\"Flipper Length (mm)\",     ylab=\"Bill Length (mm)\"   ) }"},{"path":"https://plumber2.posit.co/reference/Next.html","id":null,"dir":"Reference","previous_headings":"","what":"Router control flow — Next","title":"Router control flow — Next","text":"plumber2 API can multiple middleware request passes . point can short-circuit remaining middleware returning Break, instructs plumber2 return response . Returning Next indicates opposite, ie request allowed pass next middleware chain. handler function return either assumed return value set response body implicitely continue next middleware.","code":""},{"path":"https://plumber2.posit.co/reference/Next.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Router control flow — Next","text":"","code":"Next  Break  should_break(x)"},{"path":"https://plumber2.posit.co/reference/Next.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Router control flow — Next","text":"x object test","code":""},{"path":"https://plumber2.posit.co/reference/Next.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Router control flow — Next","text":"boolean value","code":""},{"path":"https://plumber2.posit.co/reference/Next.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Router control flow — Next","text":"","code":"# should_break() only returns TRUE with Break  should_break(10) #> [1] FALSE  should_break(FALSE) #> [1] FALSE  should_break(Next) #> [1] FALSE  should_break(Break) #> [1] TRUE"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Plumber2 Class — Plumber2","title":"The Plumber2 Class — Plumber2","text":"class encapsulates logic plumber2 api, gets passed around functional api plumber2. Plumber2 class subclass fiery::Fire class. Please consult documentation additional information type server capable . Note Plumber2 objects reference objects, meaning change change instances object.","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"initialization","dir":"Reference","previous_headings":"","what":"Initialization","title":"The Plumber2 Class — Plumber2","text":"new Plumber2-object initialized using new() method generator: However, users use functional api package thus construct one using api()","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"copying","dir":"Reference","previous_headings":"","what":"Copying","title":"The Plumber2 Class — Plumber2","text":"Plumber2 objects using reference semantics new copies api made simply assigning new variable. true copy Plumber2 object desired, use clone() method.","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"The Plumber2 Class — Plumber2","text":"fiery::Fire -> Plumber2","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"The Plumber2 Class — Plumber2","text":"request_router router handling requests header_router router handling partial requests (request pass router prior reading body) doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation doc_args arguments documentation UI","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"The Plumber2 Class — Plumber2","text":"fiery::Fire$async() fiery::Fire$attach() fiery::Fire$close_ws_con() fiery::Fire$delay() fiery::Fire$exclude_static() fiery::Fire$extinguish() fiery::Fire$get_data() fiery::Fire$has_plugin() fiery::Fire$header() fiery::Fire$is_running() fiery::Fire$log() fiery::Fire$() fiery::Fire$() fiery::Fire$reignite() fiery::Fire$remove_async() fiery::Fire$remove_data() fiery::Fire$remove_delay() fiery::Fire$remove_time() fiery::Fire$resume() fiery::Fire$safe_call() fiery::Fire$send() fiery::Fire$serve_static() fiery::Fire$set_client_id_converter() fiery::Fire$set_data() fiery::Fire$set_logger() fiery::Fire$start() fiery::Fire$stop() fiery::Fire$test_header() fiery::Fire$test_message() fiery::Fire$test_request() fiery::Fire$test_websocket() fiery::Fire$time() fiery::Fire$trigger()","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"The Plumber2 Class — Plumber2","text":"Plumber2$new() Plumber2$format() Plumber2$ignite() Plumber2$add_route() Plumber2$request_handler() Plumber2$message_handler() Plumber2$redirect() Plumber2$parse_file() Plumber2$add_api_doc() Plumber2$add_shiny() Plumber2$add_report() Plumber2$forward() Plumber2$clone()","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"The Plumber2 Class — Plumber2","text":"Create new Plumber2 api","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$new(   host = get_opts(\"host\", \"127.0.0.1\"),   port = get_opts(\"port\", 8080),   doc_type = get_opts(\"docType\", \"rapidoc\"),   doc_path = get_opts(\"docPath\", \"__docs__\"),   reject_missing_methods = get_opts(\"rejectMissingMethods\", FALSE),   ignore_trailing_slash = get_opts(\"ignoreTrailingSlash\", TRUE),   max_request_size = get_opts(\"maxRequestSize\"),   shared_secret = get_opts(\"sharedSecret\"),   compression_limit = get_opts(\"compressionLimit\", 1000),   default_async = get_opts(\"async\", \"mirai\"),   env = caller_env() )"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"host string overriding default host port port number overriding default port doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation reject_missing_methods requests paths handler specific method automatically rejected 405 Method Allowed response correct Allow header informing client implemented methods. Assigning handler \"\" path later point overwrite functionality. aware setting TRUE prevent request falling routes might matching method path. setting anly affects handlers request router. ignore_trailing_slash Logical. trailing slash path ignored adding handlers handling requests. Setting change request path associated just ensure path//resource path//resource/ ends handler. setting affect routes created automatically. max_request_size Sets maximum size request bodies. Setting add handler header router automatically rejects requests based Content-Length header shared_secret Assigns shared secret api. Setting add handler header router automatically rejects requests Plumber-Shared-Secret header contain value. aware type authentication weak. Never put shared secret plain text rely e.g. keyring package storage. Even , requests send HTTP (HTTPS) anyone can read secret use compression_limit size threshold bytes trying compress response body (still dependant content negotiation) default_async default evaluator use async request handling env environment used default execution environment API","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"The Plumber2 Class — Plumber2","text":"Plumber2 object","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-format-","dir":"Reference","previous_headings":"","what":"Method format()","title":"The Plumber2 Class — Plumber2","text":"Human readable description api object","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$format(...)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"... ignored","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"The Plumber2 Class — Plumber2","text":"character vector","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-ignite-","dir":"Reference","previous_headings":"","what":"Method ignite()","title":"The Plumber2 Class — Plumber2","text":"Begin running server. trigger start event","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$ignite(   block = FALSE,   showcase = is_interactive(),   ...,   silent = FALSE )"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"block console blocked running (alternative run background) showcase default browser open server address. TRUE browser opens root api, unless api contains OpenAPI documentation case open location. string string used path add root opening. ... Arguments passed start handler silent startup messaging silenced","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-add-route-","dir":"Reference","previous_headings":"","what":"Method add_route()","title":"The Plumber2 Class — Plumber2","text":"Add new route either request header router","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$add_route(name, route = NULL, header = FALSE, after = NULL, root = \"\")"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"name name route add. route already present name provided route () merged route route add. NULL new empty route created header Logical. route added header router? location place new route stack. NULL place end. effect route given name already exists. root root path serve route .","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-request-handler-","dir":"Reference","previous_headings":"","what":"Method request_handler()","title":"The Plumber2 Class — Plumber2","text":"Add handler request. See api_request_handlers detailed information","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$request_handler(   method,   path,   handler,   serializers,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL,   header = FALSE )"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"method HTTP method attach handler path string giving path handler responds . handler handler function call request matched path serializers named list serializers can used format response sending back client. one selected based request Accept header parsers named list parsers can used parse request body passing body argument. one selected based request Content-Type header use_strict_serializer default, serializer respects requests Accept header found, first provided ones used. Setting TRUE instead send back 406 Acceptable response download response mark download instead shown inline? Setting TRUE set Content-Disposition header response attachment. Setting string equivalent setting TRUE addition also set default filename download string value async FALSE create regular handler. TRUE, use default async evaluator create async handler. string, async evaluator registered name used. function provided used async evaluator function call completion async handler doc OpenAPI documentation handler. added paths$<handler_path>$<handler_method> portion API. route route handler added . Defaults last route stack. route exist created last route stack. header Logical. handler added header router","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-message-handler-","dir":"Reference","previous_headings":"","what":"Method message_handler()","title":"The Plumber2 Class — Plumber2","text":"Add handler WebSocket message. See api_message detailed information","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$message_handler(handler, async = FALSE, then = NULL)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"handler function conforming specifications laid api_message() async FALSE create regular handler. TRUE, use default async evaluator create async handler. string, async evaluator registered name used. function provided used async evaluator function call completion async handler","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-redirect-","dir":"Reference","previous_headings":"","what":"Method redirect()","title":"The Plumber2 Class — Plumber2","text":"Add redirect header router. Depending value permanent respond 307 Temporary Redirect 308 Permanent Redirect. can contain path parameters wildcards matched two construct correct redirect path.","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$redirect(method, from, to, permanent = TRUE)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"method HTTP method redirect respond path redirect respond path/URL redirect incoming request towards. resolving path parameters wildcards used Location header permanent Logical. redirect considered permanent temporary? Determines type redirct status code use","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-parse-file-","dir":"Reference","previous_headings":"","what":"Method parse_file()","title":"The Plumber2 Class — Plumber2","text":"Parses plumber file updates app according ","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$parse_file(file, env = NULL)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"file path file parse env parent environment environment file evaluated . NULL environment provided construction used","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-add-api-doc-","dir":"Reference","previous_headings":"","what":"Method add_api_doc()","title":"The Plumber2 Class — Plumber2","text":"Add (partial) OpenAPI spec api docs","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$add_api_doc(doc, overwrite = FALSE, subset = NULL)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"doc list OpenAPI documentation overwrite Logical. already existing documentation removed merged together doc subset character vector giving path subset docs assign doc ","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-add-shiny-","dir":"Reference","previous_headings":"","what":"Method add_shiny()","title":"The Plumber2 Class — Plumber2","text":"Add shiny app api. See api_shiny() detailed information","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$add_shiny(path, app, except = NULL)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"path path serve app app shiny app object except Subpaths path forwarded shiny app. sure contains paths shiny app needs","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-add-report-","dir":"Reference","previous_headings":"","what":"Method add_report()","title":"The Plumber2 Class — Plumber2","text":"Render serve Quarto Rmarkdown document endpoint. See api_report() information.","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$add_report(   path,   report,   ...,   doc = NULL,   max_age = Inf,   async = TRUE,   finalize = NULL,   continue = FALSE,   cache_dir = tempfile(pattern = \"plumber2_report\"),   cache_by_id = FALSE,   route = NULL )"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"path base path serve report . Additional endpoints created addition . report path report serve ... arguments quarto::quarto_render() rmarkdown::render() doc openapi_operation() documentation report. query parameters used request body generated POST methods. max_age maximum age seconds keep rendered report initiating re-render async rendering happen asynchronously (using mirai) finalize optional function run sending response back. function receive request first argument, response second, server third. continue logical defines whether response returned directly rendering made available subsequent routes cache_dir location render cache. default temporary folder created . cache_by_id caching scoped user id. rendering dependent user-level access different data necessary avoid data leakage. route route handler added . Defaults last route stack. route exist created last route stack.","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-forward-","dir":"Reference","previous_headings":"","what":"Method forward()","title":"The Plumber2 Class — Plumber2","text":"Add reverse proxy path given URL. See api_forward() details","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$forward(path, url, except = NULL)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"path root forward url url forward except Subpaths path exempt forwarding","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"The Plumber2 Class — Plumber2","text":"objects class cloneable method.","code":""},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$clone(deep = FALSE)"},{"path":"https://plumber2.posit.co/reference/Plumber2.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"deep Whether make deep clone.","code":""},{"path":"https://plumber2.posit.co/reference/add_plumber2_tag.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a tag extension to plumber2 — add_plumber2_tag","title":"Add a tag extension to plumber2 — add_plumber2_tag","text":"Package authors can extend plumber2 functionalities. wish add new tag used writing annotated plumber2 routes can use function. , called package loaded.","code":""},{"path":"https://plumber2.posit.co/reference/add_plumber2_tag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a tag extension to plumber2 — add_plumber2_tag","text":"","code":"add_plumber2_tag(tag, handler = NULL)"},{"path":"https://plumber2.posit.co/reference/add_plumber2_tag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a tag extension to plumber2 — add_plumber2_tag","text":"tag name tag handler handler function tag. See Details","code":""},{"path":"https://plumber2.posit.co/reference/add_plumber2_tag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a tag extension to plumber2 — add_plumber2_tag","text":"function called side effects","code":""},{"path":"https://plumber2.posit.co/reference/add_plumber2_tag.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a tag extension to plumber2 — add_plumber2_tag","text":"handler argument must , provided, function arguments block, call, tags, values, env. block list currently parsed information block. can add modify values within suit need well subclass . remove values others might need . call parsed value whatever expression beneath plumber2 block. tags character vector tags block, values list values associated tags (, whatever comes tag block). values unparsed. assume tags relevant extension already handled incorporated block. env argument contains environment annotation file evaluated . function must return modified version block unless block class plumber2_empty_block case allowed construct new object scratch. add subclass block make sure method apply_plumber2_block() subclass exists. handler NULL tag registered associated handler added. can make sense new block type consists multiple tags want single handler . case register handler one required tags register remaining tags without handler.","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/add_plumber2_tag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a tag extension to plumber2 — add_plumber2_tag","text":"","code":"# Add a tag that says hello when used add_plumber2_tag(\"hello\", function(block, call, tags, values, env) {   message(\"Hello\")   class(block) <- c(\"hello_block\", class(block))   block })"},{"path":"https://plumber2.posit.co/reference/api.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new plumber API, optionally based on one or more plumber files — api","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"main way create new Plumber2 object encapsulates full api. also possible add files API creation using api_parse()","code":""},{"path":"https://plumber2.posit.co/reference/api.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"","code":"api(   ...,   host = get_opts(\"host\", \"127.0.0.1\"),   port = get_opts(\"port\", 8080),   doc_type = get_opts(\"docType\", \"rapidoc\"),   doc_path = get_opts(\"docPath\", \"__docs__\"),   reject_missing_methods = get_opts(\"rejectMissingMethods\", FALSE),   ignore_trailing_slash = get_opts(\"ignoreTrailingSlash\", TRUE),   max_request_size = get_opts(\"maxRequestSize\"),   shared_secret = get_opts(\"sharedSecret\"),   compression_limit = get_opts(\"compressionLimit\", 1000),   default_async = get_opts(\"async\", \"mirai\"),   env = caller_env() )  is_plumber_api(x)  api_parse(api, ...)"},{"path":"https://plumber2.posit.co/reference/api.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"... plumber files directories containing plumber files parsed given order. order parsing determines final order routes stack. ... contains _server.yml file files ... ignored _server.yml file used basis API host string valid IPv4 address owned server port number integer indicates server port listened . Note Unix-like systems including Linux macOS, port numbers smaller 1024 require root privileges. doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation reject_missing_methods requests paths handler specific method automatically rejected 405 Method Allowed response correct Allow header informing client implemented methods. Assigning handler \"\" path later point overwrite functionality. aware setting TRUE prevent request falling routes might matching method path. setting anly affects handlers request router. ignore_trailing_slash Logical. trailing slash path ignored adding handlers handling requests. Setting change request path associated just ensure path//resource path//resource/ ends handler. max_request_size Sets maximum size request bodies. Setting add handler header router automatically rejects requests based Content-Length header shared_secret Assigns shared secret api. Setting add handler header router automatically rejects requests Plumber-Shared-Secret header contain value. aware type authentication weak. Never put shared secret plain text rely e.g. keyring package storage. Even , requests send HTTP (HTTPS) anyone can read secret use compression_limit size threshold bytes trying compress response body (still dependant content negotiation) default_async default evaluator use async request handling env parent environment environment files evaluated . file evaluated environment interfere x object test whether plumber api api plumber2 api object parse files ","code":""},{"path":"https://plumber2.posit.co/reference/api.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"Plumber2 object","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/api.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"","code":"# When creating an API programmatically you'll usually initialise the object # without pointing to any route files or a _server.yml file pa <- api()  # You can pass it a directory and it will load up all recognised files it # contains example_dir <- system.file(\"plumber2\", \"quickstart\", package = \"plumber2\") pa <- api(example_dir) #> Creating main route in request router  # Or you can pass files directly pa <- api(list.files(example_dir, full.names = TRUE)[1]) #> Creating main route in request router"},{"path":"https://plumber2.posit.co/reference/api_add_route.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a new route to either the request or header router — api_add_route","title":"Add a new route to either the request or header router — api_add_route","text":"function allows explicit creation routes addition/merging predefined routr::Route router api. new route can also created route argument adding handler. However, way always add new routes end stack, whereas using api_add_route() allows full control placement.","code":""},{"path":"https://plumber2.posit.co/reference/api_add_route.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a new route to either the request or header router — api_add_route","text":"","code":"api_add_route(api, name, route = NULL, header = FALSE, after = NULL, root = \"\")"},{"path":"https://plumber2.posit.co/reference/api_add_route.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a new route to either the request or header router — api_add_route","text":"api plumber2 api object add route name name route add. route already present name provided route () merged route route add. NULL new empty route created header Logical. route added header router? location place new route stack. NULL place end. effect route given name already exists. root root path serve route .","code":""},{"path":"https://plumber2.posit.co/reference/api_add_route.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a new route to either the request or header router — api_add_route","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_add_route.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Add a new route to either the request or header router — api_add_route","text":"direct equivalent using annotated route files. However can name route file adding @routeName <name> first block file like .   relevant blocks file added route, even route already exist. way can split definition single route among multiple files needed.","code":"#* @routeName my_route NULL"},{"path":"https://plumber2.posit.co/reference/api_add_route.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a new route to either the request or header router — api_add_route","text":"","code":"# Add a new route and use it for a handler api() |>   api_add_route(\"logger_route\") |>   api_any(     \"/*\",     function() {       cat(\"I just handled a request!\")     },     route = \"logger_route\"   ) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_assets.html","id":null,"dir":"Reference","previous_headings":"","what":"Serve resources from your file system — api_assets","title":"Serve resources from your file system — api_assets","text":"plumber2 provides two ways serve files server. One (api_assets) goes R gives power expect modify work response. (api_statics) never hits R process result blazing fast. However comes price limited freedom modify response even basic authentication. place.","code":""},{"path":"https://plumber2.posit.co/reference/api_assets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serve resources from your file system — api_assets","text":"","code":"api_assets(   api,   at,   path,   default_file = \"index.html\",   default_ext = \"html\",   finalize = NULL,   continue = FALSE,   route = NULL )  api_statics(   api,   at,   path,   use_index = TRUE,   fallthrough = FALSE,   html_charset = \"utf-8\",   headers = list(),   validation = NULL,   except = NULL )"},{"path":"https://plumber2.posit.co/reference/api_assets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serve resources from your file system — api_assets","text":"api plumber2 api object add rossource serving path serve resources path location file system map default_file default file look path map file directly (see Details) default_ext default file extension add file file found provided path path extension (see Details) finalize optional function run file found. function receive request first argument, response second, anything passed ... dispatch method. return value function discarded. function must accept ... continue logical returned file found. Defaults FALSE indicating response send unmodified. route name route header router add asset route . Defaults last route stack. route exist created last route stack use_index index.html file served present client requests folder fallthrough requests match file enter request loop 404 response send directly html_charset charset report serving html files headers list headers add response. combined global headers app validation optional validation pattern. Presently, type validation supported exact string match header. example, validation '\"abc\" = \"xyz\"', HTTP requests must header named abc (case-insensitive) value xyz (case-sensitive). request matching header, httpuv give 403 Forbidden response. character(0) (default), validation check performed. except One url paths excluded route. Requests matching enter standard router dispatch. paths interpreted subpaths , e.g. final path exclude +exclude (see example)","code":""},{"path":"https://plumber2.posit.co/reference/api_assets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serve resources from your file system — api_assets","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_assets.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Serve resources from your file system — api_assets","text":"using annotated route files functionality api_assets() can achieved like :   using annotated route files functionality api_statics() can achieved like :","code":"#* @assets my_wd/ ./ NULL #* @statics my_docs/ ~/ #* @except my_secret_folder/ NULL"},{"path":"https://plumber2.posit.co/reference/api_assets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Serve resources from your file system — api_assets","text":"","code":"# Add asset serving through routr route api() |>   api_assets(\"my_wd/\", \"./\") #> Creating default route in header router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running  # Add asset serving directly api() |>   api_statics(\"my_docs\", \"~/\", except = \"my_secret_folder/\") #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_datastore.html","id":null,"dir":"Reference","previous_headings":"","what":"Persistent server-side data storage — api_datastore","title":"Persistent server-side data storage — api_datastore","text":"using session cookie convenient solution persistent data storage requests downside requiring data passed back forth server client every exchange. makes impractical smallest snippets data. alternative strategy use server-side storage function facilitates. uses firesale plugin hood provide list-like interface storr-backed key-value store. storr turn provides interfaces range backends redis, LMDB, databases supported DBI. provides simpler (setup-free) solutions using environment (obviously less persistent) folder rds files.","code":""},{"path":"https://plumber2.posit.co/reference/api_datastore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Persistent server-side data storage — api_datastore","text":"","code":"api_datastore(   api,   driver,   store_name = \"datastore\",   gc_interval = 3600,   max_age = gc_interval )"},{"path":"https://plumber2.posit.co/reference/api_datastore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Persistent server-side data storage — api_datastore","text":"api plumber2 api object add datastore setup driver storr compatible driver defines backend datastore store_name argument name datastore available request handlers gc_interval interval running garbage collection backend max_age time since last request pass session store cleared","code":""},{"path":"https://plumber2.posit.co/reference/api_datastore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Persistent server-side data storage — api_datastore","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_datastore.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Persistent server-side data storage — api_datastore","text":"turn datastore function request handlers gain access new argument (defaults datastore can changed store_name argument). datastore argument contain list holding two elements: global session turn list-like interfaces underlying key-value store. global element access store shared sessions whereas session element scoped current session. Depending value max_age session specific data purged certain amount time passed since last request session.","code":""},{"path":"https://plumber2.posit.co/reference/api_datastore.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Persistent server-side data storage — api_datastore","text":"Session cookie setup dedicated annotation tag, can set @plumber block","code":"#* @plumber function(api) {   api |>     api_datastore(storr::driver_dbi(...)) }"},{"path":"https://plumber2.posit.co/reference/api_datastore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Persistent server-side data storage — api_datastore","text":"","code":"api() |>   api_datastore(storr::driver_environment()) |>   api_get(\"hello\", function(datastore) {     if (length(datastore$session) == 0) {       datastore$global$count <- (datastore$global$count %||% 0) + 1       datastore$session$not_first_visit <- TRUE       paste0(\"Welcome. You are visitor #\", datastore$global$count)     } else {       \"Welcome back\"     }   }) #> Creating default route in request router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_docs.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure your API for serving documentation for itself — api_docs","title":"Configure your API for serving documentation for itself — api_docs","text":"OpenAPI standard offers way describe various endpoints api machine- human-readable way. top , various solutions build generate online documentation API based provided OpenAPI spec. plumber2 offers support RapiDoc, Redoc, Swagger UI frontend documentation also generate spec based tags parsed files. creating API programmatically wish add autogenerated docs can add docs manually, either adding handler (using doc argument), api_doc_add() function","code":""},{"path":"https://plumber2.posit.co/reference/api_docs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure your API for serving documentation for itself — api_docs","text":"","code":"api_doc_setting(api, doc_type, doc_path, ...)  api_doc_add(api, doc, overwrite = FALSE, subset = NULL)"},{"path":"https://plumber2.posit.co/reference/api_docs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure your API for serving documentation for itself — api_docs","text":"api plumber2 api object add docs doc settings doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation ... plumber files directories containing plumber files parsed given order. order parsing determines final order routes stack. ... contains _server.yml file files ... ignored _server.yml file used basis API doc list OpenAPI documentation, usually constructed one helper functions overwrite Logical. already existing documentation removed merged together doc subset character vector giving path subset docs assign doc ","code":""},{"path":"https://plumber2.posit.co/reference/api_docs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure your API for serving documentation for itself — api_docs","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_docs.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Configure your API for serving documentation for itself — api_docs","text":"using annotated route files documentation automatically generated based annotation. following tags contribute documentation: @title @description @details @tos @license @contact @tag @param @query @body @response @parsers @serializers Documentation generated annotations related global documentation (block followed \"_API\" sentinel), request handlers (block including one @get, @head, @post, @put, @delete, @connect, @options, @trace, @patch, @), report generation (block including @report)","code":""},{"path":"https://plumber2.posit.co/reference/api_docs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Configure your API for serving documentation for itself — api_docs","text":"","code":"# Serve the docs from a different path api() |>   api_doc_setting(doc_path = \"__man__\") #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running  # Add documentation to the api programmatically api() |>   api_doc_add(openapi(     info = openapi_info(       title = \"My awesome api\",       version = \"1.0.0\"     )   )) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running  # Add documentation to a subset of the docs api() |>   api_doc_add(     openapi_operation(       summary = \"Get the current date\",       responses = list(         \"200\" = openapi_response(           description = \"Current Date\",           content = openapi_content(             \"text/plain\" = openapi_schema(character())           )         )       )     ),     subset = c(\"paths\", \"/date\", \"get\")   ) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_forward.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up a plumber2 api to act as a reverse proxy — api_forward","title":"Set up a plumber2 api to act as a reverse proxy — api_forward","text":"can set plumber2 api act reverse proxy forward requests specific path (subpaths) different URL. contrast api_shiny(), api_forward() responsible launching whatever service proxied handled elsewhere. path stripped request forwarded url, meaning set proxy /proxy/ http://example.com, request /proxy/user/thomas end http://example.com/user/thomas. Proxying useful forwarding internal servers though free forward public URLs well. However, later usually use redirect instead (via api_redirect())","code":""},{"path":"https://plumber2.posit.co/reference/api_forward.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up a plumber2 api to act as a reverse proxy — api_forward","text":"","code":"api_forward(api, path, url, except = NULL)"},{"path":"https://plumber2.posit.co/reference/api_forward.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up a plumber2 api to act as a reverse proxy — api_forward","text":"api plumber2 api add shiny app path path serve shiny app url url forward except Subpaths path exempt forwarding","code":""},{"path":"https://plumber2.posit.co/reference/api_forward.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up a plumber2 api to act as a reverse proxy — api_forward","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_forward.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Set up a plumber2 api to act as a reverse proxy — api_forward","text":"can set reverse proxy annotated route file using @forward tag","code":"#* @forward /proxy http://127.0.0.1:56789 NULL"},{"path":"https://plumber2.posit.co/reference/api_forward.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set up a plumber2 api to act as a reverse proxy — api_forward","text":"","code":"# Serve wikipedia directly from your app api() |>   api_forward(\"my_wiki/\", \"https://www.wikipedia.org\") #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_logger.html","id":null,"dir":"Reference","previous_headings":"","what":"Set logging function and access log format for the API — api_logger","title":"Set logging function and access log format for the API — api_logger","text":"plumber2 build-logging facility takes care logging conditions caught, well access logs. possible log custom messages using log() method api object. However, actual logging handled customizable function can set. can read logging infrastructure fiery documentation. plumber2 reexports loggers provided fiery immediately available user.","code":""},{"path":"https://plumber2.posit.co/reference/api_logger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set logging function and access log format for the API — api_logger","text":"","code":"api_logger(api, logger = NULL, access_log_format = NULL)  logger_null()  logger_console(format = \"{time} - {event}: {message}\")  logger_file(file, format = \"{time} - {event}: {message}\")  logger_logger(default_level = \"INFO\")  logger_switch(..., default = logger_null())  common_log_format  combined_log_format"},{"path":"https://plumber2.posit.co/reference/api_logger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set logging function and access log format for the API — api_logger","text":"api plumber2 api object set logger logger logger function. NULL current logger kept access_log_format glue string giving format access logs. plumber2 (fiery) provides predefined common_log_format combined_log_format, can easily create . See fiery::loggers variables glue string access . format glue string specifying format log entry file file connection write default_level log level use events request, websocket, message, warning, error ... named list loggers use different events. semantics switch used possible let events fall e.g. logger_switch(error =, warning = logger_file('errors.log')). default catch-logger use events defined ...","code":""},{"path":"https://plumber2.posit.co/reference/api_logger.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Set logging function and access log format for the API — api_logger","text":"Logger setup dedicated annotation tag, can set @plumber block","code":"#* @plumber function(api) {   api |>     api_logger(logger = logger_null()) }"},{"path":"https://plumber2.posit.co/reference/api_logger.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set logging function and access log format for the API — api_logger","text":"","code":"# Use a different access log format api() |>   api_logger(access_log_format = combined_log_format) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running  # Turn off logging api() |>   api_logger(logger_null()) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_message.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler to a WebSocket message — api_message","title":"Add a handler to a WebSocket message — api_message","text":"WebSockets bidirectional communication channel can established request client. websocket communication really part standard REST api, many uses can easily used together one.","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler to a WebSocket message — api_message","text":"","code":"api_message(api, handler, async = NULL, then = NULL)"},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler to a WebSocket message — api_message","text":"api plumber2 api object add handler handler function conforming specifications laid Details async FALSE create regular handler. TRUE, use default async evaluator create async handler. string, async evaluator registered name used. function provided used async evaluator. See Async section detail list function called async handler done. functions chained using promises::(). See Async section detail","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler to a WebSocket message — api_message","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a handler to a WebSocket message — api_message","text":"handler websocket message much simpler requests general since concern methods, paths, responses. message handler registered get called sequence websocket message recieved client. Still, expectations apply","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"handler-arguments","dir":"Reference","previous_headings":"","what":"Handler Arguments","title":"Add a handler to a WebSocket message — api_message","text":"handler can take following arguments: message: Either raw vector message recieved binary form single string, giving message sent client server: Plumber2 object representing server implementation client_id: string uniquely identifying session request comes request: request initially used establish websocket connection client reqres::Request object","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"handler-return-value","dir":"Reference","previous_headings":"","what":"Handler Return Value","title":"Add a handler to a WebSocket message — api_message","text":"expected websocket message sends response thus handler required anything like . However, handler returns either raw vector single string taken signal send back client. return value silently ignored.","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"async","dir":"Reference","previous_headings":"","what":"Async","title":"Add a handler to a WebSocket message — api_message","text":"can handle websocket messages asynchronously needed. Like request handlers can either manually creating returning promise inside handler, letting plumber2 convert handler async handler using async argument. Due nature promises handler converted promise take request server arguments, need manipulate need use (shortly). conventions return value holds async message handlers regular ones.","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"async-chaining","dir":"Reference","previous_headings":"","what":"Async chaining","title":"Add a handler to a WebSocket message — api_message","text":"manipulate request server async handler may needed add operations perform async handler finished. can done argument. takes list functions chain promise using promises::(). chain executed return value async handler send back client string raw vector. call receive arguments standard message handler well result hold return value previous handler chain. first call result whatever main async handler returned. return value last call chain silently ignored.","code":""},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Add a handler to a WebSocket message — api_message","text":"websocket message handler can added API annotated route file using @message tag   can create async handlers chaining using annotation, @async @tags","code":"#* @message function(message) {   if (message == \"Hello\") {     return(\"Hello, you...\")   } } #* @message #* @async function(message) {   if (message == \"Hello\") {     return(\"Hello, you...\")   } } #* @then function(server) {   server$log(\"message\", \"websocket message received\") }"},{"path":"https://plumber2.posit.co/reference/api_message.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a handler to a WebSocket message — api_message","text":"","code":"api() |>   api_message(     function(message) {       if (message == \"Hello\") {         return(\"Hello, you...\")       }     }   ) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_on.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler to an event — api_on","title":"Add a handler to an event — api_on","text":"life cycle plumber API various events fired, either automatically manually. See article events fiery full overview. api_on() allows add handlers called specific events fire. api_off() can used remove handler necessary","code":""},{"path":"https://plumber2.posit.co/reference/api_on.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler to an event — api_on","text":"","code":"api_on(api, event, handler, id = NULL)  api_off(api, id)"},{"path":"https://plumber2.posit.co/reference/api_on.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler to an event — api_on","text":"api plumber2 api object launch stop event string naming event listen handler function call event fires id string uniquely identifying handler. NULL random id generated making impossible remove handler ","code":""},{"path":"https://plumber2.posit.co/reference/api_on.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler to an event — api_on","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_on.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Add a handler to an event — api_on","text":"Event handler setup dedicated annotation tag, can set @plumber block","code":"#* @plumber function(api) {   api |>     api_on(\"cycle-end\", function(server) {       server$log(\"message\", \"tick-tock\")     }) }"},{"path":"https://plumber2.posit.co/reference/api_on.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a handler to an event — api_on","text":"","code":"# Add a small console log to show the api is alive pa <- api() |>   api_on(\"cycle-end\", function(server) {     server$log(\"message\", \"tick-tock\")   }, id = \"lifesign\")  # Remove it again pa |>   api_off(\"lifesign\") #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_package.html","id":null,"dir":"Reference","previous_headings":"","what":"Load up an API distributed with a package — api_package","title":"Load up an API distributed with a package — api_package","text":"Packages can included one api specification(s) storing annotated route files /_server.yml file subfolders ./inst/plumber2. name subfolder name api","code":""},{"path":"https://plumber2.posit.co/reference/api_package.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load up an API distributed with a package — api_package","text":"","code":"api_package(package = NULL, name = NULL, ...)"},{"path":"https://plumber2.posit.co/reference/api_package.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load up an API distributed with a package — api_package","text":"package name package provides api. NULL list available apis across installed packages returned name name api. NULL list available apis given package returned ... Arguments passed api host string valid IPv4 address owned server port number integer indicates server port listened . Note Unix-like systems including Linux macOS, port numbers smaller 1024 require root privileges. doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation reject_missing_methods requests paths handler specific method automatically rejected 405 Method Allowed response correct Allow header informing client implemented methods. Assigning handler \"\" path later point overwrite functionality. aware setting TRUE prevent request falling routes might matching method path. setting anly affects handlers request router. ignore_trailing_slash Logical. trailing slash path ignored adding handlers handling requests. Setting change request path associated just ensure path//resource path//resource/ ends handler. max_request_size Sets maximum size request bodies. Setting add handler header router automatically rejects requests based Content-Length header shared_secret Assigns shared secret api. Setting add handler header router automatically rejects requests Plumber-Shared-Secret header contain value. aware type authentication weak. Never put shared secret plain text rely e.g. keyring package storage. Even , requests send HTTP (HTTPS) anyone can read secret use compression_limit size threshold bytes trying compress response body (still dependant content negotiation) default_async default evaluator use async request handling env parent environment environment files evaluated . file evaluated environment interfere ","code":""},{"path":"https://plumber2.posit.co/reference/api_package.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load up an API distributed with a package — api_package","text":"package name NULL data frame providing available apis filtered either package name (provided) returned. Otherwise Plumber2 object representing api returned","code":""},{"path":"https://plumber2.posit.co/reference/api_package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load up an API distributed with a package — api_package","text":"","code":"# Load one of the plumber2 examples api_package(\"plumber2\", \"quickstart\") #> Creating main route in request router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running  # List all available apis api_package() #>    package        api #> 1 plumber2 quickstart"},{"path":"https://plumber2.posit.co/reference/api_redirect.html","id":null,"dir":"Reference","previous_headings":"","what":"Redirect request to another resource — api_redirect","title":"Redirect request to another resource — api_redirect","text":"optimal API remains stable lifetime often fully attainable. order direct requests resources moved new location can add redirect ensures smooth transition clients still using old path. Depending value permanent redirect respond 307 Temporary Redirect 308 Permanent Redirect. can contain path parameters wildcards matched two construct correct redirect path. , can either path server fully qualified URL redirect requests another server alltogether.","code":""},{"path":"https://plumber2.posit.co/reference/api_redirect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Redirect request to another resource — api_redirect","text":"","code":"api_redirect(api, method, from, to, permanent = TRUE)"},{"path":"https://plumber2.posit.co/reference/api_redirect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Redirect request to another resource — api_redirect","text":"api plumber2 api object add redirect method HTTP method redirect respond path redirect respond path/URL redirect incoming request towards. resolving path parameters wildcards used Location header permanent Logical. redirect considered permanent temporary? Determines type redirct status code use","code":""},{"path":"https://plumber2.posit.co/reference/api_redirect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Redirect request to another resource — api_redirect","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_redirect.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Redirect request to another resource — api_redirect","text":"can specify redirects annotated plumber file using @redirect tag. Preceed method ! mark redirect permanent","code":"#* @redirect !get /old/data/* /new/data/* #* @redirect any /unstable/endpoint /stable/endpoint NULL"},{"path":"https://plumber2.posit.co/reference/api_redirect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Redirect request to another resource — api_redirect","text":"","code":"api() |>   api_redirect(\"get\", \"/old/data/*\", \"/new/data/*\") #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"can serve Quarto Rmarkdown documents plumber2 api automatically render report requested. Reports automatically cached reduce overhead. Parameterized reports supported parameters can provided either query string GET requests request body POST request. also possible delete cached render using DELETE request. See Details information","code":""},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"","code":"api_report(   api,   path,   report,   ...,   doc = NULL,   max_age = Inf,   async = TRUE,   finalize = NULL,   continue = FALSE,   cache_dir = tempfile(pattern = \"plumber2_report\"),   cache_by_id = FALSE,   route = NULL )"},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"api plumber2 api serve report . path base path serve report . Additional endpoints created addition . report path report serve ... arguments quarto::quarto_render() rmarkdown::render() doc openapi_operation() documentation report. query parameters used request body generated POST methods. max_age maximum age seconds keep rendered report initiating re-render async rendering happen asynchronously (using mirai) finalize optional function run sending response back. function receive request first argument, response second, server third. continue logical defines whether response returned directly rendering made available subsequent routes cache_dir location render cache. default temporary folder created . cache_by_id caching scoped user id. rendering dependent user-level access different data necessary avoid data leakage. route route handler added . Defaults last route stack. route exist created last route stack.","code":""},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"functions return api object allowing easy chaining pipe","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"parameterized-reports","dir":"Reference","previous_headings":"","what":"Parameterized reports","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"Parameters provided parameterized reports automatically type checked casted based default values report schema provided doc. query parameters used request body inferred . important understand Quarto documents, parameters passed yaml file thus type supported yaml arrive unchanged document. Python reports supported, type parameters inferred document want type checking provided schemas doc. POST request parameters provided body, must use JSON format.","code":""},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"multiple-outputs","dir":"Reference","previous_headings":"","what":"Multiple outputs","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"report multiple different output formats format accessible subpath name format. path provided path use content negotiation Content-Type header select format. addition, path file extension added path can also used select specific format. last two, multiple formats share mime type/file extension first one can selected.","code":""},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"caching","dir":"Reference","previous_headings":"","what":"Caching","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"Reports cached, default temporary folder. can chose different folder cache_dir argument. Cached versions can deleted, thus forcing rerender upon next request, sending DELETE request. DELETE request main path delete versions report, whereas DELETE request one subpaths (see ) delete versions specific output format. different parameterized versions always deleted together. Instead sending DELETE requests can also set max_age force rerender render older given argument. content report dependent different credentials given user can cache reports session id every user rendered uniquely . important prevent leakage confidential data, also ensures report looks expected user.","code":""},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"report can served using annotated route file using @report tag proceeding annotation block path report","code":"#* @report /quarterly \"my/awesome/report.qmd\""},{"path":"https://plumber2.posit.co/reference/api_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Serve Quarto and Rmarkdown documents from a plumber2 api — api_report","text":"","code":"if (FALSE) { # file.exists(\"my/awesome/report.qmd\") api() |>   api_report(\"/quarterly\", \"my/awesome/report.qmd\") }"},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler for a request — api_request_handlers","title":"Add a handler for a request — api_request_handlers","text":"family functions facilitates adding request handler specific HTTP method path.","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler for a request — api_request_handlers","text":"","code":"api_get(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_head(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_post(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_put(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_delete(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_connect(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_options(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_trace(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_patch(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )  api_any(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   doc = NULL,   route = NULL )"},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler for a request — api_request_handlers","text":"api plumber2 api object add handler path string giving path handler responds . See Details handler handler function call request matched path serializers named list serializers can used format response sending back client. one selected based request Accept header. See get_serializers() helper construct parsers named list parsers can used parse request body passing body argument. one selected based request Content-Type header. See get_parsers() helper construct use_strict_serializer default, serializer respects requests Accept header found, first provided ones used. Setting TRUE instead send back 406 Acceptable response download response mark download instead shown inline? Setting TRUE set Content-Disposition header response attachment. Setting string equivalent setting TRUE addition also set default filename download string value async FALSE create regular handler. TRUE, use default async evaluator create async handler. string, async evaluator registered name used. function provided used async evaluator. See Async section detail list function called async handler done. functions chained using promises::(). See Async section detail doc list OpenAPI spec endpoint route route handler added . Defaults last route stack. route exist created last route stack","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler for a request — api_request_handlers","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Add a handler for a request — api_request_handlers","text":"Handlers can specified annotated route file using one method tags followed path pertains . can use various tags descripe handler automatically converted OpenAPI documentation. , additional tags allow modify behaviour handler, reflecting arguments available functional approach.   Handlers can specified annotated route file using one method tags followed path pertains . can use various tags descripe handler automatically converted OpenAPI documentation. , additional tags allow modify behaviour handler, reflecting arguments available functional approach.   can create async handlers chaining using annotation, @async @tags","code":"#* A handler for /user/<username> #* #* @param username:string The name of the user to provide information on #* #* @get /user/<username> #* #* @response 200:{name:string, age:integer, hobbies:[string]} Important #* information about the user such as their name, age, and hobbies #* function(username) {   find_user_in_db(username) } #* A handler for /user/<username> #* #* @param username:string The name of the user to provide information on #* #* @get /user/<username> #* #* @response 200:{name:string, age:integer, hobbies:[string]} Important #* information about the user such as their name, age, and hobbies #* function(username) {   find_user_in_db(username) } #* A handler for /user/<username> #* #* @param username:string The name of the user to provide information on #* #* @get /user/<username> #* #* @response 200:{name:string, age:integer, hobbies:[string]} Important #* information about the user such as their name, age, and hobbies #* #* @async function(username) {   find_user_in_db(username) } #* @then function(server, response) {   server$log(\"message\", \"async operation completed\")   response$set_header(\"etag\", \"abcdef\")   Next }"},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"http-methods","dir":"Reference","previous_headings":"","what":"HTTP Methods","title":"Add a handler for a request — api_request_handlers","text":"HTTP specs provide selection specific methods clients can send server (plumber api). enforcement server follows conventions strive create server API adheres common expectations. required server understands methods, often opposite true. HTTP methods described , consider consulting MDN get acquainted HTTP spec general GET: method used request specific content perhaps ubiquitous method use. GET requests retrieve data contain body content HEAD: method identical GET, except response contain headers, body. Apart expected HEAD request identical GET request resource POST: method delivers content, form request body, server, potentially causing change server. context plumber2 often used call functions require input larger can put URL PUT: method used update specific resource server. context standard plumber2 server rarely relevant, though usage can come . PUT considered clients indemptotent meaning sending PUT request multiple times effect DELETE: method deletes resource opposite PUT. PUT method limited use standard plumber2 servers CONNECT: method request establishment proxy tunnel. considered advanced use unlikely usecase plumber2 api OPTIONS: method used clients query server methods settings supported server TRACE: method form ping send response containing request (stripped sensitive information). Many servers disallow method due security concerns PATCH: method like PUT allows partial modification resource Apart , plumber2 also understands method responds requests methods, assuming specific handler method found. semantics various methods quite different handler mainly used rejections setting specific broad headers response, main handler request","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"the-path","dir":"Reference","previous_headings":"","what":"The Path","title":"Add a handler for a request — api_request_handlers","text":"path defines URL request made root removed. plumber2 server runs http://example.com/api/ request made http://example.com/api/user/thomas/, path user/thomas/. Paths can static like prior example, dynamic described :","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"path-arguments","dir":"Reference","previous_headings":"","what":"Path arguments","title":"Add a handler for a request — api_request_handlers","text":"Consider bunch users. impractical register handler one . Instead can use dynamic path like following syntax: user/<username>/. path matched requests made user/..something../. actual value ..something.. (e.g. thomas) made available handler (see ). path can contain multiple arguments needed, user/<username>/settings/<setting>/","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"path-wildcards","dir":"Reference","previous_headings":"","what":"Path wildcards","title":"Add a handler for a request — api_request_handlers","text":"Apart path arguments also possible even less specific adding wildcard path. path user/* match user/thomas/, user/thomas/settings/interests/, anything path begins user/. arguments path can contain multiple wildcards use diminishing returns. Contrary path arguments value(s) corresponding * made available handler.","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"path-priority","dir":"Reference","previous_headings":"","what":"Path Priority","title":"Add a handler for a request — api_request_handlers","text":"existence path arguments wildcards possible multiple handlers route can matched single request. Since one can selected need determine one wins. priority based specificity path. Consider server containing following handler paths: user/thomas/, user/<username>/, user/<username>/settings/<setting>/, user/*. paths following priority: user/<username>/settings/<setting>/ user/thomas/ user/<username>/ user/* first spot due fact path elements deemed specific. remaining 3 number elements, static paths considered specific dynamic paths, path arguments considered specific wildcards. request made user/carl thus end third handler, request made user/thomas end second. ordering makes possible provide default handlers well specialisations specific paths.","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"the-handler","dir":"Reference","previous_headings":"","what":"The Handler","title":"Add a handler for a request — api_request_handlers","text":"handler standard R function called request made matches handlers path (unless specific handler path exists — see ). handler function can perform operation normal R function can , though consider strongly security implications handler functions. However, certain expectations plumber around arguments handler function takes return value provides","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"handler-arguments","dir":"Reference","previous_headings":"","what":"Handler Arguments","title":"Add a handler for a request — api_request_handlers","text":"handler function can take one following arguments. Path arguments: path arguments passed handler. handler registered following path user/<username>/settings/<setting>/ handles request user/thomas/settings/interests/ called username = \"thomas\", setting = \"interest\" request: request handler responding reqres::Request object response: response returned client reqres::Response object server: Plumber2 object representing server implementation client_id: string uniquely identifying session request comes query: list giving additional arguments passed handler part url query string body: request body, parsed specified provided parsers","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"handler-return-value","dir":"Reference","previous_headings":"","what":"Handler Return Value","title":"Add a handler for a request — api_request_handlers","text":"Handlers can return range different value types, inform plumber2 next:","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"returning-next-or-break","dir":"Reference","previous_headings":"","what":"Returning Next or Break","title":"Add a handler for a request — api_request_handlers","text":"two control objects informs plumber2 either proceed handling request (Next) return response , circumventing remaining routes (Break)","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"returning-null-or-the-response-object","dir":"Reference","previous_headings":"","what":"Returning NULL or the response object","title":"Add a handler for a request — api_request_handlers","text":"returning Next, .e. signals handling can proceed","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"returning-a-ggplot-object","dir":"Reference","previous_headings":"","what":"Returning a ggplot2 object","title":"Add a handler for a request — api_request_handlers","text":"return ggplot2 object get plotted (added response assuming graphics serializer provided) handling continues","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"returning-any-other-value","dir":"Reference","previous_headings":"","what":"Returning any other value","title":"Add a handler for a request — api_request_handlers","text":"kind value returned captured description set response body (overwriting already ) handling allowed continue","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"handler-conditions","dir":"Reference","previous_headings":"","what":"Handler conditions","title":"Add a handler for a request — api_request_handlers","text":"Like function R, handler may need signal something happened, either throwing error warning emitting message. can use stop(), warning(), message() used . , condition message end log. , stop() handling request end 500 Internal Error response returned. take control problems can use abort_*() family conditions reqres. Like stop() halt processing, also allow control kind response sent back, kind information issue communicated client, kind information logged internally. response send back (except abort_status()) adhere HTTP Problem spec defined RFC 9457. may feel like good idea send detailed error message back client often better inform client need change solve issue. much information internal implementation details can security risk forwarding internal errors client can help inform client server implemented.","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"async-handling","dir":"Reference","previous_headings":"","what":"Async handling","title":"Add a handler for a request — api_request_handlers","text":"plumber2 supports async handling requests one two ways: handler provide returns promise object set async = TRUE (name registered async evaluator) adding handler 1), . full custody created promise ()-chaining might added . 2) bit different. case provide regular function plumber2 takes care converting promise. Due nature promises handler converted promise take request, response, server arguments, need manipulate need use (shortly). async handler yield value response ultimately get assigned body plotting side effects (case plot get added response).","code":""},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"async-chaining","dir":"Reference","previous_headings":"","what":"Async chaining","title":"Add a handler for a request — api_request_handlers","text":"manipulate request response, server async handler may needed add operations perform async handler finished. can done argument (using @tag annotated route files). takes list functions chain promise using promises::(). chain executed response get return value main handler asigned body. call receive arguments standard request handler well result hold return value previous handler chain. first call result boolean signalling async handler wants request handling proceed next route terminate early. last call chain must return Next Break signal processing allowed continue next route.","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/api_request_handlers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a handler for a request — api_request_handlers","text":"","code":"# Standard use api() |>   api_get(\"/hello/<name:string>\", function(name) {     list(       msg = paste0(\"Hello \", name, \"!\")     )   }) #> Creating default route in request router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running  # Specify serializers api() |>   api_get(     \"/hello/<name:string>\",     function(name) {       list(         msg = paste0(\"Hello \", name, \"!\")       )     },     serializers = get_serializers(c(\"json\", \"xml\"))   ) #> Creating default route in request router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running  # Request a download and make it async api() |>   api_get(     \"/the_plot\",     function() {       plot(1:10, 1:10)     },     serializers = get_serializers(c(\"png\", \"jpeg\")),     download = TRUE,     async = TRUE   ) #> Creating default route in request router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_request_header_handlers.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler for a request header — api_request_header_handlers","title":"Add a handler for a request header — api_request_header_handlers","text":"handlers called request body recieved lets preemptively reject requests recieving full content. handler return Next request returned . logic, however, main handlers asked consult api_request_handlers docs -depth details use request handlers general.","code":""},{"path":"https://plumber2.posit.co/reference/api_request_header_handlers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler for a request header — api_request_header_handlers","text":"","code":"api_get_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_head_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_post_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_put_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_delete_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_connect_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_options_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_trace_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_patch_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )  api_any_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   then = NULL,   route = NULL )"},{"path":"https://plumber2.posit.co/reference/api_request_header_handlers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler for a request header — api_request_header_handlers","text":"api plumber2 api object add handler path string giving path handler responds . See Details handler handler function call request matched path serializers named list serializers can used format response sending back client. one selected based request Accept header. See get_serializers() helper construct parsers named list parsers can used parse request body passing body argument. one selected based request Content-Type header. See get_parsers() helper construct use_strict_serializer default, serializer respects requests Accept header found, first provided ones used. Setting TRUE instead send back 406 Acceptable response download response mark download instead shown inline? Setting TRUE set Content-Disposition header response attachment. Setting string equivalent setting TRUE addition also set default filename download string value async FALSE create regular handler. TRUE, use default async evaluator create async handler. string, async evaluator registered name used. function provided used async evaluator. See Async section detail list function called async handler done. functions chained using promises::(). See Async section detail route route handler added . Defaults last route stack. route exist created last route stack","code":""},{"path":"https://plumber2.posit.co/reference/api_request_header_handlers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler for a request header — api_request_header_handlers","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_request_header_handlers.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Add a handler for a request header — api_request_header_handlers","text":"Adding request header handler done way standard request handlers. difference include @header tag well. normal document header requests usually exist internal controls. can add @noDoc avoid generating OpenAPI docs handler","code":"#* A header handler authorizing users #* #* @get /* #* #* @header #* @noDoc function(client_id, response) {   if (user_is_allowed(username)) {     Next   } else {     response$status <- 404L     Break   } }"},{"path":[]},{"path":"https://plumber2.posit.co/reference/api_request_header_handlers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a handler for a request header — api_request_header_handlers","text":"","code":"# Simple size limit (better to use build-in functionality) api() |>   api_post_header(     \"/*\",     function(request, response) {       if (request$get_header(\"content-type\") > 1024) {         response$status <- 413L         Break       } else {         Next       }     }   ) #> Creating default route in header router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Launch the API — api_run","title":"Launch the API — api_run","text":"function starts api settings defined.","code":""},{"path":"https://plumber2.posit.co/reference/api_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Launch the API — api_run","text":"","code":"api_run(   api,   host = NULL,   port = NULL,   block = !is_interactive(),   showcase = is_interactive(),   ...,   silent = FALSE )  api_stop(api)"},{"path":"https://plumber2.posit.co/reference/api_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Launch the API — api_run","text":"api plumber2 api object launch stop host, port Host port run api . provided host port used creation Plumber2 api used block console blocked running (alternative run background). Defaults FALSE interactive sessions TRUE otherwise. showcase default browser open server address. TRUE browser opens root api, unless api contains OpenAPI documentation case open location. string string used path add root opening. ... Arguments passed start handler silent startup messaging silenced","code":""},{"path":"https://plumber2.posit.co/reference/api_run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Launch the API — api_run","text":"functions return api object allowing easy chaining pipe, even though often last part chain","code":""},{"path":"https://plumber2.posit.co/reference/api_run.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Launch the API — api_run","text":"","code":"pa <- api() |>   api_get(\"/\", function() {     list(msg = \"Hello World\")   }) |>   api_on(\"start\", function(...) {     cat(\"I'm alive\")   }) #> Creating default route in request router  # Start the server pa |> api_run(block = FALSE) #> plumber2 server started at http://127.0.0.1:8080 #> I'm alive  # Stop it again pa |> api_stop()"},{"path":"https://plumber2.posit.co/reference/api_security_cors.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up CORS for a path in your plumber2 API — api_security_cors","title":"Set up CORS for a path in your plumber2 API — api_security_cors","text":"function adds Cross-Origin Resource Sharing (CORS) path API. function can called multiple times set CORS multiple paths, potentially different settings path. CORS complex specification can read CORS plugin documentation.","code":""},{"path":"https://plumber2.posit.co/reference/api_security_cors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up CORS for a path in your plumber2 API — api_security_cors","text":"","code":"api_security_cors(   api,   path = \"/*\",   origin = \"*\",   methods = c(\"get\", \"head\", \"put\", \"patch\", \"post\", \"delete\"),   allowed_headers = NULL,   exposed_headers = NULL,   allow_credentials = FALSE,   max_age = NULL )"},{"path":"https://plumber2.posit.co/reference/api_security_cors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up CORS for a path in your plumber2 API — api_security_cors","text":"api plumber2 api object add plugin path path policy apply . routr path syntax applies, meaning wilcards path parameters allowed. origin origin allowed path. Can one : boolean. TRUE origins permitted preflight response Access-Control-Allow-Origin header reflect origin request. FALSE origins denied string \"*\" allow origins set Access-Control-Allow-Origin *. different setting TRUE * instructs browsers origin allowed may use information searching cache character vector giving allowed origins. request origin matches Access-Control-Allow-Origin header response reflect origin request function taking request returning TRUE origin permitted FALSE . permitted Access-Control-Allow-Origin header reflect request origin methods HTTP methods allowed path allowed_headers character vector request headers allowed making request. request contains headers permitted, response blocked browser. NULL allow header reflecting Access-Control-Request-Headers header value request Access-Control-Allow-Headers header response. exposed_headers character vector response headers made available client upon succesful request allow_credentials boolean indicating whether credentials allowed request. Credentials cookies HTTP authentication headers, normally stripped fetch() requests browser. TRUE origin * according spec max_age duration browsers allowed keep preflight response cache","code":""},{"path":"https://plumber2.posit.co/reference/api_security_cors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up CORS for a path in your plumber2 API — api_security_cors","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_security_cors.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Set up CORS for a path in your plumber2 API — api_security_cors","text":"add CORS path can add @cors <origin> handler annotation. <origin> must one URLs *, separated comma (meaning possible provide function using annotation). add CORS endpoints described block. annotation allow setting allowed_headers, exposed_headers, allow_credentials max_age default values used.","code":"#* A handler for /user/<username> #* #* @param username:string The name of the user to provide information on #* #* @get /user/<username> #* #* @response 200:{name:string, age:integer, hobbies:[string]} Important #* information about the user such as their name, age, and hobbies #* #* @cors https://example.com, https://another-site.com #* function(username) {   find_user_in_db(username) }"},{"path":[]},{"path":"https://plumber2.posit.co/reference/api_security_cors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set up CORS for a path in your plumber2 API — api_security_cors","text":"","code":"# Set up cors for your asset/ path for the https://examples.com origin  api() |>   api_security_cors(     path = \"asset/*\",     origin = \"https://examples.com\"   ) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_security_headers.html","id":null,"dir":"Reference","previous_headings":"","what":"Add various security related headers to your plumber2 API — api_security_headers","title":"Add various security related headers to your plumber2 API — api_security_headers","text":"function adds SecurityHeaders plugin plumber2 API. Please consult documentation plugin --date information behaviour.","code":""},{"path":"https://plumber2.posit.co/reference/api_security_headers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add various security related headers to your plumber2 API — api_security_headers","text":"","code":"api_security_headers(   api,   content_security_policy = csp(default_src = \"self\", script_src = \"self\",     script_src_attr = \"none\", style_src = c(\"self\", \"https:\", \"unsafe-inline\"), img_src =     c(\"self\", \"data:\"), font_src = c(\"self\", \"https:\", \"data:\"), object_src = \"none\",     base_uri = \"self\", form_action = \"self\", frame_ancestors = \"self\",     upgrade_insecure_requests = TRUE),   content_security_policy_report_only = NULL,   cross_origin_embedder_policy = NULL,   cross_origin_opener_policy = \"same-origin\",   cross_origin_resource_policy = \"same-origin\",   origin_agent_cluster = TRUE,   referrer_policy = \"no-referrer\",   strict_transport_security = sts(max_age = 63072000, include_sub_domains = TRUE),   x_content_type_options = TRUE,   x_dns_prefetch_control = FALSE,   x_download_options = TRUE,   x_frame_options = \"SAMEORIGIN\",   x_permitted_cross_domain_policies = \"none\",   x_xss_protection = FALSE )"},{"path":"https://plumber2.posit.co/reference/api_security_headers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add various security related headers to your plumber2 API — api_security_headers","text":"api plumber2 api object add plugin content_security_policy Set value Content-Security-Policy header. See firesafety::csp() documentation values content_security_policy_report_only Set value Content-Security-Policy-Report-header. See firesafety::csp() documentation values cross_origin_embedder_policy Set value Cross-Origin-Embedder-Policy. Possible values \"unsafe-none\", \"require-corp\", \"credentialless\" cross_origin_opener_policy Set value Cross-Origin-Opener-Policy. Possible values \"unsafe-none\", \"-origin-allow-popups\", \"-origin\", \"noopener-allow-popups\" cross_origin_resource_policy Set value Cross-Origin-Resource-Policy. Possible values \"-site\", \"-origin\", \"cross-origin\" origin_agent_cluster Set value Origin-Agent-Cluster. Possible values TRUE FALSE referrer_policy Set value Referrer-Policy. Possible values \"-referrer\", \"-referrer--downgrade\", \"origin\", \"origin--cross-origin\", \"-origin\", \"strict-origin\", \"strict-origin--cross-origin\", \"unsafe-url\" strict_transport_security Set value Strict-Transport-Security header. See firesafety::sts() documentation values x_content_type_options Set value X-Content-Type-Options. Possible values TRUE FALSE x_dns_prefetch_control Set value X-DNS-Prefetch-Control. Possible values TRUE FALSE x_download_options Set value X-Download-Options. Possible values TRUE FALSE x_frame_options Set value X-Frame-Options. Possible values \"DENY\" \"SAMEORIGIN\" x_permitted_cross_domain_policies Set value X-Permitted-Cross-Domain-Policies. Possible values \"none\", \"master-\", \"-content-type\", \"-ftp-filename\", \"\", \"none--response\" x_xss_protection Set value X-XSS-Protection. Possible values TRUE FALSE","code":""},{"path":"https://plumber2.posit.co/reference/api_security_headers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add various security related headers to your plumber2 API — api_security_headers","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_security_headers.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Add various security related headers to your plumber2 API — api_security_headers","text":"Security headers dedicated annotation tag, can set @plumber block","code":"#* @plumber function(api) {   api |>     api_security_headers() }"},{"path":[]},{"path":"https://plumber2.posit.co/reference/api_security_headers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add various security related headers to your plumber2 API — api_security_headers","text":"","code":"# Add default security headers to an API api() |>   api_security_headers() #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_security_resource_isolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up resource isolation for a path — api_security_resource_isolation","title":"Set up resource isolation for a path — api_security_resource_isolation","text":"function adds resource isolation path API. function can called multiple times set resource isolation multiple paths, potentially different settings path. can read depth resource isolation ResourceIsolation plugin documentation.","code":""},{"path":"https://plumber2.posit.co/reference/api_security_resource_isolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up resource isolation for a path — api_security_resource_isolation","text":"","code":"api_security_resource_isolation(   api,   path = \"/*\",   allowed_site = \"same-site\",   forbidden_navigation = c(\"object\", \"embed\"),   allow_cors = TRUE )"},{"path":"https://plumber2.posit.co/reference/api_security_resource_isolation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up resource isolation for a path — api_security_resource_isolation","text":"api plumber2 api object add plugin path path policy apply . routr path syntax applies, meaning wilcards path parameters allowed. allowed_site allowance level permit. Either cross-site, -site, -origin. forbidden_navigation vector destinations allowed navigational requests. See Sec-Fetch-Dest documentation description possible values. special value \"\" also permitted equivalent passing values. allow_cors Sec-Fetch-Mode: cors requests allowed","code":""},{"path":"https://plumber2.posit.co/reference/api_security_resource_isolation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up resource isolation for a path — api_security_resource_isolation","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_security_resource_isolation.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Set up resource isolation for a path — api_security_resource_isolation","text":"add resource isolation path can add @rip <allowed_site> handler annotation. add resource isolation endpoints described block. annotation allow setting forbidden_navigation allow_cors default values used.","code":"#* A handler for /user/<username> #* #* @param username:string The name of the user to provide information on #* #* @get /user/<username> #* #* @response 200:{name:string, age:integer, hobbies:[string]} Important #* information about the user such as their name, age, and hobbies #* #* @rip same-origin #* function(username) {   find_user_in_db(username) }"},{"path":[]},{"path":"https://plumber2.posit.co/reference/api_security_resource_isolation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set up resource isolation for a path — api_security_resource_isolation","text":"","code":"# Set up resource isolation for everything inside a user path api() |>   api_security_resource_isolation(     path = \"<user>/*\"   ) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_session_cookie.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn on session cookie data storage for your API — api_session_cookie","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"need keep data requests, want store server-side (see api_datastore()) can instead pass back forth encrypted session cookie. function sets api use can now access set session data request response $session field. aware session data send back forth requests thus kept minimal avoid congestion server.","code":""},{"path":"https://plumber2.posit.co/reference/api_session_cookie.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"","code":"api_session_cookie(   api,   key,   name = \"reqres\",   expires = NULL,   max_age = NULL,   path = NULL,   secure = NULL,   same_site = NULL )"},{"path":"https://plumber2.posit.co/reference/api_session_cookie.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"api plumber2 api object add session cookie setup key 32-bit secret key hex encoded string raw vector use encrypting session cookie. valid key can generated using reqres::random_key(). NEVER STORE KEY PLAIN TEXT. Optimally use keyring package store name name cookie expires POSIXct object given expiration time cookie max_age number seconds elapse cookie expires path URL path cookie related secure cookie send https same_site Either \"Lax\", \"Strict\", \"None\" indicating cookie can send cross-site requests. set \"None\" secure must also set TRUE","code":""},{"path":"https://plumber2.posit.co/reference/api_session_cookie.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_session_cookie.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"Session cookie setup dedicated annotation tag, can set @plumber block","code":"#* @plumber function(api) {   api |>     api_session_cookie(keyring::key_get(\"my_secret_plumber_key\")) }"},{"path":"https://plumber2.posit.co/reference/api_session_cookie.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"","code":"key <- reqres::random_key()  api() |>   api_session_cookie(key, secure = TRUE) |>   api_get(\"/\", function(request) {     if (isTRUE(request$session$foo)) {       msg <- \"You've been here before\"     } else {       msg <- \"You must be new here\"       request$session$foo <- TRUE     }     list(       msg = msg     )   }) #> Creating default route in request router #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/api_shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Serve a Shiny app from a plumber2 api — api_shiny","title":"Serve a Shiny app from a plumber2 api — api_shiny","text":"can serve one shiny apps part plumber2 api. shiny app launches background process api work reverse proxy forward requests path process relay response client. shiny app started along api shut api stopped. functionality requires shiny callr packages installed. aware requests subpaths path forwarded shiny process, thus end normal route","code":""},{"path":"https://plumber2.posit.co/reference/api_shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serve a Shiny app from a plumber2 api — api_shiny","text":"","code":"api_shiny(api, path, app, except = NULL)"},{"path":"https://plumber2.posit.co/reference/api_shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serve a Shiny app from a plumber2 api — api_shiny","text":"api plumber2 api add shiny app path path serve shiny app app shiny app object except Subpaths path forwarded shiny app. sure contains paths shiny app needs","code":""},{"path":"https://plumber2.posit.co/reference/api_shiny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serve a Shiny app from a plumber2 api — api_shiny","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://plumber2.posit.co/reference/api_shiny.html","id":"using-annotation","dir":"Reference","previous_headings":"","what":"Using annotation","title":"Serve a Shiny app from a plumber2 api — api_shiny","text":"shiny app can served using annotated route file using @shiny tag proceeding annotation block shiny app object","code":"#* @shiny /my_app/ shiny::shinyAppDir(\"./shiny\")"},{"path":"https://plumber2.posit.co/reference/api_shiny.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Serve a Shiny app from a plumber2 api — api_shiny","text":"","code":"blank_shiny <- shiny::shinyApp(   ui = shiny::fluidPage(),   server = shiny::shinyServer(function(...) {}) )  api() |>   api_shiny(\"my_app/\", blank_shiny) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/apply_plumber2_block.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic for applying information from a plumber2 block to an api — apply_plumber2_block","title":"Generic for applying information from a plumber2 block to an api — apply_plumber2_block","text":"order facilitate extensibility plumber2 file syntax can provide methods apply information plumber2 block api.","code":""},{"path":"https://plumber2.posit.co/reference/apply_plumber2_block.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic for applying information from a plumber2 block to an api — apply_plumber2_block","text":"","code":"apply_plumber2_block(block, api, route_name, root, ...)"},{"path":"https://plumber2.posit.co/reference/apply_plumber2_block.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic for applying information from a plumber2 block to an api — apply_plumber2_block","text":"block block parsed api Plumber2 api object apply route_name name route plumber2 file associated . Either name file value @routeName tag root root given potential @root tag file. @root tag present value null. value represents root path every endpoint defined file prepended URL path use. ... ignored","code":""},{"path":"https://plumber2.posit.co/reference/apply_plumber2_block.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic for applying information from a plumber2 block to an api — apply_plumber2_block","text":"api, modified","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/apply_plumber2_block.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic for applying information from a plumber2 block to an api — apply_plumber2_block","text":"","code":"# Add a method for a fictional \"hello_block\" that makes the api say hello when # it starts apply_plumber2_block.hello_block <- function(block, api, route_name, root, ...) {   api$on(\"start\", function(...) {     message(\"Hello\")   })   api }"},{"path":"https://plumber2.posit.co/reference/async_evaluators.html","id":null,"dir":"Reference","previous_headings":"","what":"Async evaluators provided by plumber — async_evaluators","title":"Async evaluators provided by plumber — async_evaluators","text":"functions support async request handling. can register well using register_async().","code":""},{"path":"https://plumber2.posit.co/reference/async_evaluators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Async evaluators provided by plumber — async_evaluators","text":"","code":"mirai_async(...)"},{"path":"https://plumber2.posit.co/reference/async_evaluators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Async evaluators provided by plumber — async_evaluators","text":"... argument passed internal async function. See Details information function handles formatting internally async evaluator","code":""},{"path":"https://plumber2.posit.co/reference/async_evaluators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Async evaluators provided by plumber — async_evaluators","text":"function taking expr envir. former expression evaluate latter environment additional variables made available evaluation","code":""},{"path":"https://plumber2.posit.co/reference/async_evaluators.html","id":"provided-evaluators","dir":"Reference","previous_headings":"","what":"Provided evaluators","title":"Async evaluators provided by plumber — async_evaluators","text":"mirai_async() uses mirai::mirai(). registered \"mirai\". aware evaluator performant start multiple persistent background processes. See mirai::daemons().","code":""},{"path":"https://plumber2.posit.co/reference/async_evaluators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Async evaluators provided by plumber — async_evaluators","text":"","code":"# Use the default mirai backend by setting `async = TRUE` with a handler  pa <- api() |>   api_get(\"/hello/<name:string>\", function(name) {     list(       msg = paste0(\"Hello \", name, \"!\")     )   }, async = TRUE) #> Creating default route in request router"},{"path":"https://plumber2.posit.co/reference/create_server_yml.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a _server.yml file to describe your API — create_server_yml","title":"Create a _server.yml file to describe your API — create_server_yml","text":"can manually create plumber2 API calling api(), often need deploy api somewhere else. facilitate can create _server.yml encapsulates settings plumber files. call api() path file API constructed according content.","code":""},{"path":"https://plumber2.posit.co/reference/create_server_yml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a _server.yml file to describe your API — create_server_yml","text":"","code":"create_server_yml(..., path = \".\", constructor = NULL, freeze_opt = TRUE)"},{"path":"https://plumber2.posit.co/reference/create_server_yml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a _server.yml file to describe your API — create_server_yml","text":"... path files /directories contain annotated plumber files used API path folder place generated _server.yml file constructor path file creates plumber2 API object. Can omitted case API object created freeze_opt Logical specifying whether options currently locally (either environment variables R options) written _server.yml file. Shared secret never written file must find different way move deployment server.","code":""},{"path":"https://plumber2.posit.co/reference/create_server_yml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a _server.yml file to describe your API — create_server_yml","text":"","code":"if (FALSE) { # file.exists(\"path/to/a/plumber/file.R\") create_server_yml(   \"path/to/a/plumber/file.R\" ) }"},{"path":"https://plumber2.posit.co/reference/device_formatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a graphics device formatter — device_formatter","title":"Create a graphics device formatter — device_formatter","text":"internal function facilitates creating formatter uses specific device rendering.","code":""},{"path":"https://plumber2.posit.co/reference/device_formatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a graphics device formatter — device_formatter","text":"","code":"device_formatter(dev_open, dev_close = grDevices::dev.off())"},{"path":"https://plumber2.posit.co/reference/device_formatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a graphics device formatter — device_formatter","text":"dev_open function opens device dev_close function closing device. Usually grDevices::dev.()","code":""},{"path":"https://plumber2.posit.co/reference/device_formatter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a graphics device formatter — device_formatter","text":"device formatter function","code":""},{"path":"https://plumber2.posit.co/reference/device_formatter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a graphics device formatter — device_formatter","text":"","code":"# Create a png formatter using the default png device device_formatter(png) #> function (...)  #> { #>     provided_args <- names(enquos(...)) #>     dev_args <- fn_fmls_names(dev_open) #>     extra_args <- setdiff(provided_args, dev_args) #>     if (length(extra_args) != 0 && !\"...\" %in% dev_args) { #>         cli::cli_abort(\"Provided arguments does not match arguments in {.fun {dev_name}}\") #>     } #>     init_dev <- function() { #>         output_file <- tempfile() #>         dev_open(filename = output_file, ...) #>         dev_id <- grDevices::dev.cur() #>         list(path = output_file, dev = dev_id) #>     } #>     close_dev <- function(info) { #>         grDevices::dev.set(info$dev) #>         grDevices::dev.off() #>         if (!file.exists(info$path)) { #>             return(NULL) #>         } #>         con <- file(info$path, \"rb\") #>         on.exit({ #>             close(con) #>             unlink(info$path) #>         }, add = TRUE) #>         readBin(con, \"raw\", file.info(info$path)$size) #>     } #>     clean_dev <- function(info) { #>         grDevices::dev.set(info$dev) #>         grDevices::dev.off() #>         unlink(info$path) #>     } #>     with_dev <- function(x, info) { #>         promises::with_promise_domain(create_graphics_device_promise_domain(info$dev),  #>             x) #>     } #>     structure(identity, init = init_dev, close = close_dev, clean = clean_dev,  #>         with = with_dev, class = \"device_formatter\") #> } #> <bytecode: 0x55911244e8d8> #> <environment: 0x559112454c90> #> attr(,\"class\") #> [1] \"device_constructor\""},{"path":"https://plumber2.posit.co/reference/get_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve options for creating a plumber2 api — get_opts","title":"Retrieve options for creating a plumber2 api — get_opts","text":"can provide options plumber2 api picked create API api(). Options can set either internal options() functionality, setting environment variables. former case, name option must prefixed \"plumber2.\", latter case variable name must upper case prefixed \"PLUMBER2_\". option stored environment variable value cast type giving default. See docs api() default values different options.","code":""},{"path":"https://plumber2.posit.co/reference/get_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve options for creating a plumber2 api — get_opts","text":"","code":"get_opts(x, default = NULL)  all_opts()"},{"path":"https://plumber2.posit.co/reference/get_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve options for creating a plumber2 api — get_opts","text":"x name option default default value, x set","code":""},{"path":"https://plumber2.posit.co/reference/get_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve options for creating a plumber2 api — get_opts","text":"get_opts value x, , default. all_opts() named list options set","code":""},{"path":"https://plumber2.posit.co/reference/get_opts.html","id":"plumber-options","dir":"Reference","previous_headings":"","what":"plumber2 options","title":"Retrieve options for creating a plumber2 api — get_opts","text":"following options currently recognized plumber2. read creation time parallel argument api() can also see default values. means changing option creation/running effect. host: address serve server port: port use server docType: ui use serving OpenAPI documentation docPath: path serve documentation rejectMissingMethods: requests paths handler specific method automatically rejected 405 Method Allowed response ignoreTrailingSlash: trailing slash path ignored adding handlers handling requests maxRequestSize: maximum allowed size request bodies sharedSecret: shared secret request must contain permitted compressionLimit: threshold response size automatic compression used async: default async engine use","code":""},{"path":"https://plumber2.posit.co/reference/get_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve options for creating a plumber2 api — get_opts","text":"","code":"# Using `options()` old_opts <- options(plumber2.port = 9889L) get_opts(\"port\") #> [1] 9889 options(old_opts)  # Using environment variables old_env <- Sys.getenv(\"PLUMBER2_PORT\") Sys.setenv(PLUMBER2_PORT = 9889)  ## If no default is provided the return value is a string get_opts(\"port\") #> [1] \"9889\"  ## Provide a default to hint at the options type get_opts(\"port\", 8080L) #> [1] 9889  Sys.setenv(PLUMBER2_PORT = old_env)"},{"path":"https://plumber2.posit.co/reference/init_formatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatter orchestration — init_formatter","title":"Formatter orchestration — init_formatter","text":"functions internal use exported ease async evaluation","code":""},{"path":"https://plumber2.posit.co/reference/init_formatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatter orchestration — init_formatter","text":"","code":"init_formatter(formatter)  close_formatter(formatter, info)  clean_formatter(formatter, info)  with_formatter(expr, formatter, info)"},{"path":"https://plumber2.posit.co/reference/init_formatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formatter orchestration — init_formatter","text":"formatter serializer function info structure returned init_formatter() expr expression evaluate context formatter","code":""},{"path":"https://plumber2.posit.co/reference/init_formatter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formatter orchestration — init_formatter","text":"init_formatter() returns opaque structure capturing information used functions. close_formatter() may return value used response body. with_formatter() returns result expr. clean_formatter() called side effects called close_formatter() never evaluated.","code":""},{"path":"https://plumber2.posit.co/reference/openapi.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct OpenAPI specifications — openapi","title":"Construct OpenAPI specifications — openapi","text":"helper functions aid constructing OpenAPI compliant specifications API. return simple lists may thus forego helpers instead construct manually (import json yaml file). purpose helpers mainly basic input checking documenting structure. Read spec https://spec.openapis.org/oas/v3.0.0.html","code":""},{"path":"https://plumber2.posit.co/reference/openapi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct OpenAPI specifications — openapi","text":"","code":"openapi(   openapi = \"3.0.0\",   info = openapi_info(),   paths = list(),   tags = list() )  openapi_info(   title = character(),   description = character(),   terms_of_service = character(),   contact = openapi_contact(),   license = openapi_license(),   version = character() )  openapi_contact(name = character(), url = character(), email = character())  openapi_license(name = character(), url = character())  openapi_path(   summary = character(),   description = character(),   get = openapi_operation(),   put = openapi_operation(),   post = openapi_operation(),   delete = openapi_operation(),   options = openapi_operation(),   head = openapi_operation(),   patch = openapi_operation(),   trace = openapi_operation(),   parameters = list() )  openapi_operation(   summary = character(),   description = character(),   operation_id = character(),   parameters = list(),   request_body = openapi_request_body(),   responses = list(),   tags = character() )  openapi_parameter(   name = character(),   location = c(\"path\", \"query\", \"header\", \"cookie\"),   description = character(),   required = logical(),   schema = openapi_schema(),   content = openapi_content(),   ... )  openapi_header(description = character(), schema = openapi_schema())  openapi_schema(x, default = NULL, min = NULL, max = NULL, ..., required = NULL)  openapi_content(...)  openapi_request_body(   description = character(),   content = openapi_content(),   required = logical() )  openapi_response(   description = character(),   content = openapi_content(),   headers = list() )  openapi_tag(name = character(), description = character())"},{"path":"https://plumber2.posit.co/reference/openapi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct OpenAPI specifications — openapi","text":"openapi OpenAPI version spec adheres . helpers assume 3.0.0 also default value info list constructed openapi_info() paths named list. names correspond endpoints elements lists constructed openapi_path() tags openapi() list elements corresponding value constructed openapi_tag(). openapi_operation() character vector list strings title string giving title API description longer description respective element. May use markdown terms_of_service URL terms service API contact list constructed openapi_contact() license list constructed openapi_license() version string giving version API name name contact, license, parameter, tag url URL pointing contact license information email email address contact summary one-sentence summary path operation get, put, post, delete, options, head, patch, trace list describing specific HTTP method requested path, constructed openapi_operation() parameters list parameters apply path /operation. given openapi_path() inherited operations. operation_id unique string identifies operation API request_body list constructed openapi_request_body() responses named list name corresponding response code elements lists constructed openapi_response() location parameter coming . Either \"path\", \"query\", \"header\", \"cookie\". required openapi_parameter boolean indicating required parameter (\"path\" parameters always required). openapi_schema() character vector naming required properties object. schema description data constructed openapi_schema content list constructed openapi_content(). ... named arguments added element. openapi_content() named elements constructed openapi_schema() x R object corresponding type schema. Supported types : integer: signal type: integer numeric: signal type: number character: signal type: string factor: signal type: string enum set factor levels raw: signal type:string; format: binary Date: signal type:string; format: date POSIXt: signal type:string; format: date-time list: unnamed must one-length list signal type: array items set schema element. named signal type: object properties set schema element. AsIs: signal type equivalent value input (must string) default default value parameter. Must reconsilable type x min, max Bounds value parameter headers named list names corresponding headers elements constructed openapi_header()","code":""},{"path":"https://plumber2.posit.co/reference/openapi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct OpenAPI specifications — openapi","text":"list","code":""},{"path":"https://plumber2.posit.co/reference/openapi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct OpenAPI specifications — openapi","text":"","code":"# Create docs for an API with a single endpoint doc <- openapi(   info = openapi_info(     title = \"My awesome api\",     version = \"1.0.0\"   ),   paths = list(     \"/hello/{name}\" = openapi_path(       get = openapi_operation(         summary = \"Get a greeting\",         parameters = list(           openapi_parameter(             name = \"name\",             location = \"path\",             description = \"Your name\",             schema = openapi_schema(character())           )         ),         responses = list(           \"200\" = openapi_response(             description = \"a kind message\",             content = openapi_content(               \"text/plain\" = openapi_schema(character())             )           )         )       )     )   ) )  # Add it to an api api() |>   api_doc_add(doc) #> ── A plumber server ──────────────────────────────────────────────────────────── #> Serving on http://127.0.0.1:8080 #> Currently not running"},{"path":"https://plumber2.posit.co/reference/parse_plumber_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a plumber file — parse_plumber_file","title":"Parse a plumber file — parse_plumber_file","text":"function takes care parsing annotated plumber file creating one routes, API specs, modifier function called plumber app routes added. function attach parsed data plumber api, rarely necessary call directly.","code":""},{"path":"https://plumber2.posit.co/reference/parse_plumber_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a plumber file — parse_plumber_file","text":"","code":"parse_plumber_file(path, env = caller_env())"},{"path":"https://plumber2.posit.co/reference/parse_plumber_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a plumber file — parse_plumber_file","text":"path path file parse env environment evaluate code annotations ","code":""},{"path":"https://plumber2.posit.co/reference/parse_plumber_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a plumber file — parse_plumber_file","text":"list containing: route main route handling requests according parsed file, named list length one header_route route attached header events (fires body recieved can used prematurely reject requests based headers), named list length one asset_routes asset routes created @static blocks named list message_handlers websocket message handlers created @message blocks, list api list giving OpenAPI spec parsed file modifier single function chaining functions @plumber blocks together","code":""},{"path":"https://plumber2.posit.co/reference/parse_plumber_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a plumber file — parse_plumber_file","text":"","code":"if (FALSE) { # file.exists(\"path/to/my/plumber/file.R\") # Parse a plumber file parse_plumber_file(\"path/to/my/plumber/file.R\") }"},{"path":"https://plumber2.posit.co/reference/parsers.html","id":null,"dir":"Reference","previous_headings":"","what":"Parser functions provided by plumber2 — parsers","title":"Parser functions provided by plumber2 — parsers","text":"functions cover large area potential request body formats. registered standard mime types users may want use register alternative types know makes sense.","code":""},{"path":"https://plumber2.posit.co/reference/parsers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parser functions provided by plumber2 — parsers","text":"","code":"parse_csv(...)  parse_octet()  parse_rds(...)  parse_feather(...)  parse_parquet(...)  parse_text(multiple = FALSE)  parse_tsv(...)  parse_yaml(...)  parse_geojson(...)  parse_multipart(parsers = get_parsers())"},{"path":"https://plumber2.posit.co/reference/parsers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parser functions provided by plumber2 — parsers","text":"... argument passed internal parsing function. See Details information function handles parsing internally parser multiple logical: conversion single     character string multiple individual characters? parsers list parsers use parsing parts body","code":""},{"path":"https://plumber2.posit.co/reference/parsers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parser functions provided by plumber2 — parsers","text":"function accepting raw vector along directives argument provides directives Content-Type passed along","code":""},{"path":"https://plumber2.posit.co/reference/parsers.html","id":"provided-parsers","dir":"Reference","previous_headings":"","what":"Provided parsers","title":"Parser functions provided by plumber2 — parsers","text":"parse_csv() uses readr::read_csv() parsing. registered \"csv\" mime types application/csv, application/x-csv, text/csv, text/x-csv parse_multipart uses webutils::parse_multipart() initial parsing. goes part tries find parser matches content type (either given directly guessed file extension provided). parser found leaves value raw vector. registered \"multi\" mime type multipart/* parse_octet() passes raw data unchanged. registered \"octet\" mime type application/octet-stream parse_rds() uses unserialize() parsing. registered \"rds\" mime type application/rds parse_feather() uses arrow::read_feather() parsing. registered \"feather\" mime types application/vnd.apache.arrow.file application/feather parse_parquet() uses arrow::read_parquet() parsing. registered \"parquet\" mime type application/vnd.apache.parquet parse_text() uses rawToChar() parsing. registered \"text\" mime types text/plain text/* parse_tsv() uses readr::read_tsv() parsing. registered \"tsv\" mime types application/tab-separated-values text/tab-separated-values parse_yaml() uses yaml::yaml.load() parsing. registered \"yaml\" mime types text/vnd.yaml, application/yaml, application/x-yaml, text/yaml, text/x-yaml parse_geojson() uses geojsonsf::geojson_sf() parsing. registered \"geojson\" mime types application/geo+json application/vdn.geo+json","code":""},{"path":"https://plumber2.posit.co/reference/parsers.html","id":"additional-registered-parsers","dir":"Reference","previous_headings":"","what":"Additional registered parsers","title":"Parser functions provided by plumber2 — parsers","text":"reqres::parse_json() registered \"json\" mime types application/json text/json reqres::parse_queryform() registered \"form\" mime type application/x-www-form-urlencoded reqres::parse_xml() registered \"xml\" mime types application/xml text/xml reqres::parse_html() registered \"html\" mime type text/html","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/parsers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parser functions provided by plumber2 — parsers","text":"","code":"# You can use parsers directly when adding handlers pa <- api() |>   api_post(\"/hello/<name:string>\", function(name, body) {     list(       msg = paste0(\"Hello \", name, \"!\")     )   }, parsers = list(\"text/csv\" = parse_csv())) #> Creating default route in request router"},{"path":"https://plumber2.posit.co/reference/plumber2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"plumber2: Easy and Powerful Web Servers — plumber2-package","title":"plumber2: Easy and Powerful Web Servers — plumber2-package","text":"Automatically create web server annotated 'R' files building programmatically. Provides automatic 'OpenAPI' documentation, input handling, asynchronous evaluation, plugin support.","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/plumber2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plumber2: Easy and Powerful Web Servers — plumber2-package","text":"Maintainer: Thomas Lin Pedersen thomas.pedersen@posit.co (ORCID) contributors: Posit Software, PBC (03wc8by49) [copyright holder, funder]","code":""},{"path":"https://plumber2.posit.co/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. firesafety csp, sts reqres abort_bad_request, abort_conflict, abort_forbidden, abort_gone, abort_http_problem, abort_internal_error, abort_method_not_allowed, abort_not_acceptable, abort_not_found, abort_status, abort_unauthorized, random_key","code":""},{"path":"https://plumber2.posit.co/reference/register_async.html","id":null,"dir":"Reference","previous_headings":"","what":"Register an async evaluator — register_async","title":"Register an async evaluator — register_async","text":"plumber supports async request handling two ways. Either manual returning promise handler, automatic @async tag / async argument handler functions. default evaluator controlled plumber2.async option PLUMBER2_ASYNC environment variable.","code":""},{"path":"https://plumber2.posit.co/reference/register_async.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register an async evaluator — register_async","text":"","code":"register_async(name, fun, dependency = NULL)  show_registered_async()  get_async(name = NULL, ...)"},{"path":"https://plumber2.posit.co/reference/register_async.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register an async evaluator — register_async","text":"name name evaluator fun function , upon calling returns evaluator taking expr envir argument. See async evaluator functions examples dependency Package dependencies evaluator. ... Arguments passed async function creator","code":""},{"path":"https://plumber2.posit.co/reference/register_async.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register an async evaluator — register_async","text":"","code":"# Register an async evaluator based on future (the provided mirai backend is # superior in every way so this is for illustrative purpose) future_async <- function(...) {   function(expr, envir) {     promises::future_promise(       expr = expr,       envir = envir,       substitute = FALSE,       ...     )   } } register_async(\"future\", future_async, c(\"promises\", \"future\"))"},{"path":"https://plumber2.posit.co/reference/register_parser.html","id":null,"dir":"Reference","previous_headings":"","what":"Register or fetch a parser — register_parser","title":"Register or fetch a parser — register_parser","text":"plumber2 comes many parsers cover almost standard use cases. Still might want provide , function facilitates.","code":""},{"path":"https://plumber2.posit.co/reference/register_parser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register or fetch a parser — register_parser","text":"","code":"register_parser(name, fun, mime_types, default = TRUE)  show_registered_parsers()  get_parsers(parsers = NULL)"},{"path":"https://plumber2.posit.co/reference/register_parser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register or fetch a parser — register_parser","text":"name name register parser function . already present current parser overwritten one provided fun function , called, returns binary function can parse request body. first argument takes raw vector binary encoding request body, second argument takes additional directives given requests Content-Type header mime_types One mime types parser can handle. mime types allowed contain wildcards, e.g. \"text/*\" default parser part default set parsers parsers Parsers collect. can either character vector names registered parsers list. list following expectations apply: unnamed elements containing character vector considered names registered parsers constructed default values. special value \"...\" fetch parsers otherwise specified call element containing function considered provided parser element must named mime type parser understands (wildcards allowed) remaining named elements considered names registered parsers constructed arguments given element","code":""},{"path":"https://plumber2.posit.co/reference/register_parser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register or fetch a parser — register_parser","text":"get_parsers named list parser functions named mime types. order given parsers preserved.","code":""},{"path":"https://plumber2.posit.co/reference/register_parser.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register or fetch a parser — register_parser","text":"want register parser, function register must factory function, .e. function returning function. returned function must accept two arguments, first raw vector corresponding request body, second parsed directives request Content-Type header. arguments factory function optional.","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/register_parser.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register or fetch a parser — register_parser","text":"","code":"# Register a parser that splits at a character and converts to number register_parser(\"comma\", function(delim = \",\") {   function(raw, directive) {     as.numeric(strsplit(rawToChar(raw), delim)[[1]])   } }, mime_types = \"text/plain\", default = FALSE)"},{"path":"https://plumber2.posit.co/reference/register_serializer.html","id":null,"dir":"Reference","previous_headings":"","what":"Register or fetch a serializer — register_serializer","title":"Register or fetch a serializer — register_serializer","text":"plumber2 comes many serializers cover almost standard use cases. Still might want provide , function facilitates.","code":""},{"path":"https://plumber2.posit.co/reference/register_serializer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register or fetch a serializer — register_serializer","text":"","code":"register_serializer(name, fun, mime_type, default = TRUE)  show_registered_serializers()  get_serializers(serializers = NULL)"},{"path":"https://plumber2.posit.co/reference/register_serializer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register or fetch a serializer — register_serializer","text":"name name register serializer function . already present current serializer overwritten one provided fun function , called, returns unary function can serialize response body mime type defined mime_type mime_type format serializer creates. take care ensure value provided standard mime type format default serializer part default set serializers serializers Serializers collect. can either character vector names registered serializers list. list following expectations apply: unnamed elements containing character vector considered names registered serializers constructed default values. special value \"...\" fetch serializers otherwise specified call. element containing function considered provided serializer element must named mime type serializer understands remaining named elements considered names registered serializers constructed arguments given element","code":""},{"path":"https://plumber2.posit.co/reference/register_serializer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register or fetch a serializer — register_serializer","text":"get_serializers named list serializer functions named mime type. order given serializers preserved.","code":""},{"path":"https://plumber2.posit.co/reference/register_serializer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register or fetch a serializer — register_serializer","text":"want register serializer, function register must factory function, .e. function returning function. returned function must accept single argument response body. arguments factory function optional.","code":""},{"path":"https://plumber2.posit.co/reference/register_serializer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Register or fetch a serializer — register_serializer","text":"Using ... provide remaining graphics serializers graphics serializer explicitely requested elsewhere. Otherwise provide remaining non-graphics serializers. warning thrown mix graphics non-graphics serializers requested.","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/register_serializer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register or fetch a serializer — register_serializer","text":"","code":"# Add a serializer that deparses the value register_serializer(\"deparse\", function(...) {   function(x) {     deparse(x, ...)   } }, mime_type = \"text/plain\")"},{"path":"https://plumber2.posit.co/reference/serializers.html","id":null,"dir":"Reference","previous_headings":"","what":"Serializer functions provided by plumber2 — serializers","title":"Serializer functions provided by plumber2 — serializers","text":"functions cover large area potential response body formats. registered standard mime type users may want use register alternative types know makes sense.","code":""},{"path":"https://plumber2.posit.co/reference/serializers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serializer functions provided by plumber2 — serializers","text":"","code":"format_csv(...)  format_tsv(...)  format_rds(version = \"3\", ascii = FALSE, ...)  format_geojson(...)  format_feather(...)  format_parquet(...)  format_yaml(...)  format_htmlwidget(...)  format_format(..., sep = \"\\n\")  format_print(..., sep = \"\\n\")  format_cat(..., sep = \"\\n\")  format_unboxed(...)  format_png(...)  format_jpeg(...)  format_tiff(...)  format_svg(...)  format_bmp(...)  format_pdf(...)"},{"path":"https://plumber2.posit.co/reference/serializers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serializer functions provided by plumber2 — serializers","text":"... argument passed internal formatting function. See Details information function handles formatting internally serializer version workspace format version use.  NULL     specifies current default version (3). supported     value 2, default R 1.4.0 R 3.5.0. ascii logical.  TRUE NA, ASCII     representation written; otherwise (default) binary one.     See also comments help save. sep separator multiple elements","code":""},{"path":"https://plumber2.posit.co/reference/serializers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serializer functions provided by plumber2 — serializers","text":"function accepting response body","code":""},{"path":"https://plumber2.posit.co/reference/serializers.html","id":"provided-serializers","dir":"Reference","previous_headings":"","what":"Provided serializers","title":"Serializer functions provided by plumber2 — serializers","text":"format_csv() uses readr::format_csv() formatting. registered \"csv\" mime type text/csv format_tsv() uses readr::format_tsv() formatting. registered \"tsv\" mime type text/tsv format_rds() uses serialize() formatting. registered \"rds\" mime type application/rds format_geojson() uses geojsonsf::sfc_geojson() geojsonsf::sf_geojson() formatting depending class response body. registered \"geojson\" mime type application/geo+json format_feather() uses arrow::write_feather() formatting. registered \"feather\" mime type application/vnd.apache.arrow.file format_parquet() uses nanoparquet::write_parquet() formatting. registered \"parquet\" mime type application/vnd.apache.parquet format_yaml() uses yaml::.yaml() formatting. registered \"yaml\" mime type text/yaml format_htmlwidget() uses htmlwidgets::saveWidget() formatting. registered \"htmlwidget\" mime type text/html format_format() uses format() formatting. registered \"format\" mime type text/plain format_print() uses print() formatting. registered \"print\" mime type text/plain format_cat() uses cat() formatting. registered \"cat\" mime type text/plain format_unboxed() uses reqres::format_json() auto_unbox = TRUE formatting. registered \"unboxedJSON\" mime type application/json","code":""},{"path":"https://plumber2.posit.co/reference/serializers.html","id":"additional-registered-serializers","dir":"Reference","previous_headings":"","what":"Additional registered serializers","title":"Serializer functions provided by plumber2 — serializers","text":"reqres::format_json() registered \"json\" mime type application/json reqres::format_html() registered \"html\" mime type text/html reqres::format_xml() registered \"xml\" mime type text/xml reqres::format_plain() registered \"text\" mime type text/plain","code":""},{"path":"https://plumber2.posit.co/reference/serializers.html","id":"provided-graphics-serializers","dir":"Reference","previous_headings":"","what":"Provided graphics serializers","title":"Serializer functions provided by plumber2 — serializers","text":"Serializing graphic output special requires operations handler executed. , handlers creating graphics expected side-effects (.e. call graphics rendering) returning ggplot2 object. want create graphics serializer use device_formatter() constructing . format_png() uses ragg::agg_png() rendering. registered \"png\" mime type image/png format_jpeg() uses ragg::agg_jpeg() rendering. registered \"jpeg\" mime type image/jpeg format_tiff() uses ragg::agg_tiff() rendering. registered \"tiff\" mime type image/tiff format_svg() uses svglite::svglite() rendering. registered \"svg\" mime type image/svg+xml format_bmp() uses grDevices::bmp() rendering. registered \"bmp\" mime type image/bmp format_pdf() uses grDevices::pdf() rendering. registered \"pdf\" mime type application/pdf","code":""},{"path":[]},{"path":"https://plumber2.posit.co/reference/serializers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Serializer functions provided by plumber2 — serializers","text":"","code":"# You can use serializers directly when adding handlers pa <- api() |>   api_get(\"/hello/<name:string>\", function(name) {     list(       msg = paste0(\"Hello \", name, \"!\")     )   }, serializers = list(\"application/json\" = format_unboxed())) #> Creating default route in request router"},{"path":"https://plumber2.posit.co/news/index.html","id":"plumber2-development-version","dir":"Changelog","previous_headings":"","what":"plumber2 (development version)","title":"plumber2 (development version)","text":"Fix bug constructing empty blocks extending can now pass additional arguments OpenAPI doc UI api_doc_setting() powerful report support. Added api_report() parallel `@report`` even settings. Parameters now type checked using facilities request handlers, much comprehensive OpenAPI documentation provided.","code":""},{"path":"https://plumber2.posit.co/news/index.html","id":"plumber2-010","dir":"Changelog","previous_headings":"","what":"plumber2 0.1.0","title":"plumber2 0.1.0","text":"CRAN release: 2025-09-22 Initial CRAN submission.","code":""}]
