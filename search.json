[{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Posit, PBC Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"annotations","dir":"Articles","previous_headings":"","what":"Annotations","title":"Annotations reference","text":"Annotations specially-structured comments used plumber file create API. full annotation line starts #*, annotation keyword @..., number space characters followed content. wish use annotation document API file don’t want OpenAPI documentation generated can use @noDoc tag works much like roxygens @noRd.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"global-annotations","dir":"Articles","previous_headings":"","what":"Global annotations","title":"Annotations reference","text":"Global annotations related handler placed block. block terminated NULL expression. Instead @apiTitle @apiDescription can also use convention first line gives title proceeding lines first tag gives description.","code":"#* Sample Pet Store App #* #* This is a sample server for a pet store. #* #* @apiTOS http://example.com/terms/ #* @apiContact list(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\") #* @apiLicense list(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\") #* @apiVersion 1.0.1 #* @apiTag pet Pets operations #* @apiTag toy Toys operations #* @apiTag \"toy space\" Toys operations NULL api() |>   api_doc_add(list(     info = list(       title = \"Sample Pet Store App\",       description = \"This is a sample server for a pet store.\",       termsOfService = \"http://example.com/terms/\",       contact = list(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\"),       license = list(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\"),       version = \"1.0.1\"     ),     tags = list(       list(name = \"pet\", description = \"Pets operations\"),       list(name = \"toy\", description = \"Toys operations\"),       list(name = \"toy space\", description = \"Toys operations\")     )   ))"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"annotations-example","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* Sample Pet Store App #* #* This is a sample server for a pet store. #* #* @apiTOS http://example.com/terms/ #* @apiContact list(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\") #* @apiLicense list(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\") #* @apiVersion 1.0.1 #* @apiTag pet Pets operations #* @apiTag toy Toys operations #* @apiTag \"toy space\" Toys operations NULL"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"equivalent-programmatic-usage","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"api() |>   api_doc_add(list(     info = list(       title = \"Sample Pet Store App\",       description = \"This is a sample server for a pet store.\",       termsOfService = \"http://example.com/terms/\",       contact = list(name = \"API Support\", url = \"http://www.example.com/support\", email = \"support@example.com\"),       license = list(name = \"Apache 2.0\", url = \"https://www.apache.org/licenses/LICENSE-2.0.html\"),       version = \"1.0.1\"     ),     tags = list(       list(name = \"pet\", description = \"Pets operations\"),       list(name = \"toy\", description = \"Toys operations\"),       list(name = \"toy space\", description = \"Toys operations\")     )   ))"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"handler-annotations","dir":"Articles","previous_headings":"","what":"Handler annotations","title":"Annotations reference","text":"Handler annotation describe aspects request handler always proceeds function considered handler function. following tags can used handler block. first line, unless tag considered title handler proceeding lines first tag considered long-form description. Annotation Argument Description/References @get, @head, @post, @put, @delete, @connect, @options, @trace, @patch, @Path Endpoints, Dynamic Routes, Typed Dynamic Routes @header None handler attached header router @serializer Alias[{Args list]}] Mime Function serializers accept arguments. See serializers article serializers reference. Aliases : r paste0(“<code>”, registered_serializers(), “<\/code>”, collapse = “,”) registered_serializers(). @serializerStrict None Turn strict content negotiation. default, first serializer chosen client requests response type isnt supported. using strict content negotiation 406 response sent requested response type available @parser Alias[{Args list}] Mime Function parsers accept arguments. See parsers reference. Can repeated allow multiple parsers endpoint. Aliases : r paste0(“<code>”, registered_parsers(), “<\/code>”, collapse = “,”) registered_parsers(). @param, @query, @body Name[:Type][(Default)][*][Description] Adding asterix indicates parameter required. Can repeated define different parameters. single @body tag used Name can omitted indicate body named object simply instance given Type @response Status[:Type] Description Simple Response object. Can repeated define different responses. @download [Filename] Mark response something downloaded, optionally setting default filename file @tag Tag Can repeated add multiple tags. Quote use non word character (like spaces) Tag. Tag field @message None Marks handler WebSocket message handler. tags effect tag present Types used define API inputs outputs. path parameters can given @param inside handler path. given places must agreement. query body parameters given respective @query @body tags. types can nested structure also supported, type spec can quickly become difficult read recurse use care Types can default value, given parentheses type specification, e.g. integer(10). objects arrays use JSON notation describe default value (e.g. [integer]([2, 6, 1])). integer number types also possible specify lower /upper bounds value. done putting | like : integer|3, 7|. Omitting one remove bound requirement (e.g. integer|,7| requires input equal 7). combining default value range comes first (integer|3,7|(5)). parameters can specified optional required type notation. Path parameters always required setting ignored . parameter can marked required adding * suffix type description, e.g. arg1:integer* indicate arg1 required integer. parameter required default value (reasons logic). Apart used documentation API, type information provide parameters also used cast incoming values correct type add defaults missing. , missing required parameters result error. response type checked conform specification provide.","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL } text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = list(       parameters = list(         list(           `in` = \"query\",           name = \"name\",           schema = list(type = \"string\"),           required = TRUE         ),         list(           `in` = \"query\",           name = \"age\",           schema = list(type = \"integer\"),           required = TRUE         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = list(       responses = list(          \"200\" = list(           description = \"A sentence\",           content = list(             \"text/plain\" = list(schema = list(               type = \"string\"             ))           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = list(       description = \"Upload an rds file and return the object\",       requestBody = list(         content = list(           \"multipart/form-data\" = list(schema = list(             type = \"object\",             properties = list(               file = list(                 type = \"string\",                 format = \"binary\"               )             )           ))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"endpoint-block-annotations","dir":"Articles","previous_headings":"","what":"Endpoint","title":"Annotations reference","text":"Annotation Argument Description/References @get, @head, @post, @put, @delete, @connect, @options, @trace, @patch, @Path Endpoints, Dynamic Routes, Typed Dynamic Routes @header None handler attached header router @serializer Alias[{Args list]}] Mime Function serializers accept arguments. See serializers article serializers reference. Aliases : r paste0(“<code>”, registered_serializers(), “<\/code>”, collapse = “,”) registered_serializers(). @serializerStrict None Turn strict content negotiation. default, first serializer chosen client requests response type isnt supported. using strict content negotiation 406 response sent requested response type available @parser Alias[{Args list}] Mime Function parsers accept arguments. See parsers reference. Can repeated allow multiple parsers endpoint. Aliases : r paste0(“<code>”, registered_parsers(), “<\/code>”, collapse = “,”) registered_parsers(). @param, @query, @body Name[:Type][(Default)][*][Description] Adding asterix indicates parameter required. Can repeated define different parameters. single @body tag used Name can omitted indicate body named object simply instance given Type @response Status[:Type] Description Simple Response object. Can repeated define different responses. @download [Filename] Mark response something downloaded, optionally setting default filename file @tag Tag Can repeated add multiple tags. Quote use non word character (like spaces) Tag. Tag field @message None Marks handler WebSocket message handler. tags effect tag present Types used define API inputs outputs. path parameters can given @param inside handler path. given places must agreement. query body parameters given respective @query @body tags. types can nested structure also supported, type spec can quickly become difficult read recurse use care Types can default value, given parentheses type specification, e.g. integer(10). objects arrays use JSON notation describe default value (e.g. [integer]([2, 6, 1])). integer number types also possible specify lower /upper bounds value. done putting | like : integer|3, 7|. Omitting one remove bound requirement (e.g. integer|,7| requires input equal 7). combining default value range comes first (integer|3,7|(5)). parameters can specified optional required type notation. Path parameters always required setting ignored . parameter can marked required adding * suffix type description, e.g. arg1:integer* indicate arg1 required integer. parameter required default value (reasons logic). Apart used documentation API, type information provide parameters also used cast incoming values correct type add defaults missing. , missing required parameters result error. response type checked conform specification provide.","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL } text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = list(       parameters = list(         list(           `in` = \"query\",           name = \"name\",           schema = list(type = \"string\"),           required = TRUE         ),         list(           `in` = \"query\",           name = \"age\",           schema = list(type = \"integer\"),           required = TRUE         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = list(       responses = list(          \"200\" = list(           description = \"A sentence\",           content = list(             \"text/plain\" = list(schema = list(               type = \"string\"             ))           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = list(       description = \"Upload an rds file and return the object\",       requestBody = list(         content = list(           \"multipart/form-data\" = list(schema = list(             type = \"object\",             properties = list(               file = list(                 type = \"string\",                 format = \"binary\"               )             )           ))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"more-details-on-type","dir":"Articles","previous_headings":"","what":"More details on Type","title":"Annotations reference","text":"Types used define API inputs outputs. path parameters can given @param inside handler path. given places must agreement. query body parameters given respective @query @body tags. types can nested structure also supported, type spec can quickly become difficult read recurse use care Types can default value, given parentheses type specification, e.g. integer(10). objects arrays use JSON notation describe default value (e.g. [integer]([2, 6, 1])). integer number types also possible specify lower /upper bounds value. done putting | like : integer|3, 7|. Omitting one remove bound requirement (e.g. integer|,7| requires input equal 7). combining default value range comes first (integer|3,7|(5)). parameters can specified optional required type notation. Path parameters always required setting ignored . parameter can marked required adding * suffix type description, e.g. arg1:integer* indicate arg1 required integer. parameter required default value (reasons logic). Apart used documentation API, type information provide parameters also used cast incoming values correct type add defaults missing. , missing required parameters result error. response type checked conform specification provide.","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL } text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = list(       parameters = list(         list(           `in` = \"query\",           name = \"name\",           schema = list(type = \"string\"),           required = TRUE         ),         list(           `in` = \"query\",           name = \"age\",           schema = list(type = \"integer\"),           required = TRUE         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = list(       responses = list(          \"200\" = list(           description = \"A sentence\",           content = list(             \"text/plain\" = list(schema = list(               type = \"string\"             ))           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = list(       description = \"Upload an rds file and return the object\",       requestBody = list(         content = list(           \"multipart/form-data\" = list(schema = list(             type = \"object\",             properties = list(               file = list(                 type = \"string\",                 format = \"binary\"               )             )           ))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"annotations-example-1","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @get /query/parameters #* @serializer text #* @query name:string* #* @query age:integer* function(query) {   sprintf(\"%s is %i years old\", query$name, max(query$age)) }  #* @get /dyn/<name:string>/<age:integer>/route #* @serializer text #* @parser none #* @response 200:string A sentence function(name, age) {   sprintf(\"%s is %i years old\", name, age) }  #* Upload a file and return the object as an rds #* #* @post /upload_file #* @serializer rds #* @parser multi #* @body file:binary A file #* @download function(body) {   body$file }  #* @message function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"equivalent-programmatic-usage-1","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"text_handler <- function(name, age) {   sprintf(\"%s is %i years old\", name, max(age)) } qp_handler <- function(query) {   text_handler(query$name, query$age) } file_handler <- function(body) {   body$f } msg_handler <- function(message, client_id, server) {   if (is.character(message)) {     server$log(\"message\", paste0(client_id, \" says \", message))   }   NULL }  api() |>   api_get(     path = \"/query/parameters\",     handler = qp_handler,     serializers = get_serializers(\"text\"),     parsers = get_parsers(),     doc = list(       parameters = list(         list(           `in` = \"query\",           name = \"name\",           schema = list(type = \"string\"),           required = TRUE         ),         list(           `in` = \"query\",           name = \"age\",           schema = list(type = \"integer\"),           required = TRUE         )       )     )   ) |>   api_get(     path = \"/dyn/<name:string>/<age:integer>/route\",     handler = text_handler,     serializers = get_serializers(\"text\"),     doc = list(       responses = list(          \"200\" = list(           description = \"A sentence\",           content = list(             \"text/plain\" = list(schema = list(               type = \"string\"             ))           )         )       )     )   ) |>   api_post(     path = \"/upload_file\",     handler = file_handler,     serializers = get_serializers(\"rds\"),     parsers = get_parsers(\"multi\"),     doc = list(       description = \"Upload an rds file and return the object\",       requestBody = list(         content = list(           \"multipart/form-data\" = list(schema = list(             type = \"object\",             properties = list(               file = list(                 type = \"string\",                 format = \"binary\"               )             )           ))         )       )     )   ) |>   api_message(msg_handler)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"static-block-annotations","dir":"Articles","previous_headings":"","what":"Asset annotation","title":"Annotations reference","text":"two ways serve static content plumber2 differ subtle ways. @assets tag instruct plumber create regular handler matches mount path (defaults /) serve files Path. @statics tag works , rather create handler instructs httpuv (low-level package powering plumber2) serve files request even reaches R process. makes much faster also limited flexibility since request never reaches code unable modify . general, use @statics unless need provide additional handling request, authentication logging.","code":"#* @assets ./assets/files NULL  #* @assets ./assets/files /assets NULL  #* @statics ./assets/static_files #* @except /secret_files NULL api() %>%   api_assets(\"/\", \"./assets/files\")  api() %>%   api_assets(\"/assets\", \"./assets/files\")  api() %>%   api_statics(\"/\", \"./assets/static_files\", except = \"/secret_files\")"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"annotations-example-2","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @assets ./assets/files NULL  #* @assets ./assets/files /assets NULL  #* @statics ./assets/static_files #* @except /secret_files NULL"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"equivalent-programmatic-usage-note-that-argument-order-is-reversed","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage (note that argument order is reversed)","title":"Annotations reference","text":"","code":"api() %>%   api_assets(\"/\", \"./assets/files\")  api() %>%   api_assets(\"/assets\", \"./assets/files\")  api() %>%   api_statics(\"/\", \"./assets/static_files\", except = \"/secret_files\")"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"plumber-block-annotations","dir":"Articles","previous_headings":"","what":"Plumber annotation","title":"Annotations reference","text":"","code":"#* @plumber function(api) {   api %>%     api_doc_setting(\"swagger\") }  # Named function use_swagger <- function(api) {   api %>%     api_doc_setting(\"swagger\") }  #* @plumber use_swagger api() |>   api_doc_setting(\"swagger\")"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"annotations-example-3","dir":"Articles","previous_headings":"","what":"Annotations example","title":"Annotations reference","text":"","code":"#* @plumber function(api) {   api %>%     api_doc_setting(\"swagger\") }  # Named function use_swagger <- function(api) {   api %>%     api_doc_setting(\"swagger\") }  #* @plumber use_swagger"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/annotations.html","id":"equivalent-programmatic-usage-2","dir":"Articles","previous_headings":"","what":"Equivalent programmatic usage","title":"Annotations reference","text":"","code":"api() |>   api_doc_setting(\"swagger\")"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"execution-model","dir":"Articles","previous_headings":"","what":"Execution Model","title":"Runtime","text":"plumb() file, Plumber calls source() file evaluate top-level code defined. include file call api(), counter variable created live environment created API route. However, endpoint defined evaluated invoked response incoming request. endpoint uses <<-, “double-assignment” operator, mutates counter variable previously defined file parsed. technique allows endpoints filters share data defined top-level API.","code":"# Global code; gets executed at plumb() time. counter <- 0  #* @get / function() {   # Only gets evaluated when this endpoint is requested.   counter <<- counter + 1 }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"environments","dir":"Articles","previous_headings":"","what":"Environments","title":"Runtime","text":"create plumber API using api() can provide environment env argument. default calling environment (often global environment) used. environment used parent environment parsing files, file parsed ’s environment avoid interfering . means share objects files. handlers different files need access data sign need advanced data store object defined plumber file.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"performance-request-processing","dir":"Articles","previous_headings":"","what":"Performance & Request Processing","title":"Runtime","text":"R single-threaded programming language, meaning can one task time. still true serving APIs using Plumber, single endpoint takes two seconds generate response, every time endpoint requested, R process unable respond additional incoming requests two seconds. Incoming HTTP requests serviced order appeared, requests coming quickly can processed API, backlog requests accrue. common solutions problem either : Keep API performant. filters endpoints complete quickly long-running complicated tasks done outside API process. Run multiple R processes redundantly host single Plumber API load-balance incoming requests available processes. See hosting section details hosting environments support feature.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"managing-state","dir":"Articles","previous_headings":"","what":"Managing State","title":"Runtime","text":"Often, Plumber APIs require coordination state. state may need shared multiple endpoints API (e.g. counter increments every time endpoint invoked). Alternatively, information needs persisted across requests single client (e.g. storing preference setting user). Lastly, might require coordinating multiple Plumber processes running independently behind load-balancer. scenarios unique properties determine solution might appropriate. previously discussed, R single-threaded. Therefore ’s important consider fact may eventually need multiple R processes running parallel handle incoming traffic API. may seem important initially, may thank later designing “horizontally scalable” API (one can scaled adding R processes parallel). key building horizontally scalable API ensure Plumber process “stateless,” meaning persistent state lives outside Plumber process. hosting environments exist today, guaranteed two subsequent requests single client served process. Thus ’s never safe assume information stored -memory available requests horizontally scaled app. options consider coordinate state Plumber API. shown previous Execution Model section, possible share state using environment associated Plumber router. one approach presented allow Plumber process stateless. approach sufficient coordinating state within single route single process, scale API adding processes routes, state longer coordinated . Therefore approach can effective “read-” data – load single, large dataset memory API starts, allow filters endpoints reference dataset moving forward – allow share state across multiple processes scale. want build scalable, stateless application, avoid relying -memory R environment coordinate state pieces API. Writing files disk often next obvious choice storing state. Plumber APIs modify data frame use write.csv() save data disk, use writeLines() append new data existing file. approaches enable R process stateless, always resilient concurrency issues. instance, ’ve horizontally scaled API five R processes two go write.csv() simultaneously, either see one process’s data get immediately overwritten ’s, – even worse – may end corrupted CSV file can’t read. Unless otherwise stated, ’s safe assume R function writes data disk resilient concurrency contention, rely filesystem coordinate shared state single R process running concurrently. ’s also important ask whether hosting platform ’ll using supports persistent storage disk. instance, Docker may insulate R process hardware allow write outside container. RStudio Connect, , provision new directory every time deploy updated version API discard data written disk point. ’re considering writing state disk long-term, sure hosting environment supports persistent -disk storage ’ve considered concurrency implications code. HTTP cookies convention allow web servers send state client expectation client include state future requests. See Setting Cookies section details leverage cookies Plumber. modern web browsers support cookies (unless configured ) many clients , well, though clients require additional configuration order . ’re confident intended clients API support cookies consider storing state cookies. approach mitigates concerns horizontal scalability, state written client independently included subsequent requests client. also minimizes infrastructure requirements hosting Plumber APIs since don’t need setup system capable storing state; instead, ’ve commissioned clients store state. One issue maintaining state cookies size kept minimum. Clients impose restrictions differently, plan store 4kB information cookie. realize whatever information gets placed cookie must retransmitted client every request. can significantly increase size HTTP request clients make. notable concern considering using cookies store state since clients responsible storing sending state, expect state tampered . Thus, may acceptable store user preferences like preferredColor=\"blue\", store authentication information like userID=1493, since user trivially change cookie another user’s ID impersonate . ’d like use cookies store information guarantees user either read modify state, see Encrypted Cookies section). final option consider coordinating state API leveraging external data store. relational database (like MySQL Amazon RedShift), non-relational database (like MongoDB), transactional data store like Redis. One important consideration options ensure “transactional,” meaning two Plumber processes trying write time won’t overwrite one another. ’re interested pursuing option see solutions.rstudio.com/db/ look resources put together Shiny pertains dealing databases web-accessible R platform.","code":"# Global code; gets executed at plumb() time. counter <- 0  #* @get / function() {   # Only gets evaluated when this endpoint is requested.   counter <<- counter + 1 }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"in-memory","dir":"Articles","previous_headings":"","what":"In-Memory","title":"Runtime","text":"shown previous Execution Model section, possible share state using environment associated Plumber router. one approach presented allow Plumber process stateless. approach sufficient coordinating state within single route single process, scale API adding processes routes, state longer coordinated . Therefore approach can effective “read-” data – load single, large dataset memory API starts, allow filters endpoints reference dataset moving forward – allow share state across multiple processes scale. want build scalable, stateless application, avoid relying -memory R environment coordinate state pieces API.","code":"# Global code; gets executed at plumb() time. counter <- 0  #* @get / function() {   # Only gets evaluated when this endpoint is requested.   counter <<- counter + 1 }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"file-system","dir":"Articles","previous_headings":"","what":"File System","title":"Runtime","text":"Writing files disk often next obvious choice storing state. Plumber APIs modify data frame use write.csv() save data disk, use writeLines() append new data existing file. approaches enable R process stateless, always resilient concurrency issues. instance, ’ve horizontally scaled API five R processes two go write.csv() simultaneously, either see one process’s data get immediately overwritten ’s, – even worse – may end corrupted CSV file can’t read. Unless otherwise stated, ’s safe assume R function writes data disk resilient concurrency contention, rely filesystem coordinate shared state single R process running concurrently. ’s also important ask whether hosting platform ’ll using supports persistent storage disk. instance, Docker may insulate R process hardware allow write outside container. RStudio Connect, , provision new directory every time deploy updated version API discard data written disk point. ’re considering writing state disk long-term, sure hosting environment supports persistent -disk storage ’ve considered concurrency implications code.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"state-cookies","dir":"Articles","previous_headings":"","what":"Cookies","title":"Runtime","text":"HTTP cookies convention allow web servers send state client expectation client include state future requests. See Setting Cookies section details leverage cookies Plumber. modern web browsers support cookies (unless configured ) many clients , well, though clients require additional configuration order . ’re confident intended clients API support cookies consider storing state cookies. approach mitigates concerns horizontal scalability, state written client independently included subsequent requests client. also minimizes infrastructure requirements hosting Plumber APIs since don’t need setup system capable storing state; instead, ’ve commissioned clients store state. One issue maintaining state cookies size kept minimum. Clients impose restrictions differently, plan store 4kB information cookie. realize whatever information gets placed cookie must retransmitted client every request. can significantly increase size HTTP request clients make. notable concern considering using cookies store state since clients responsible storing sending state, expect state tampered . Thus, may acceptable store user preferences like preferredColor=\"blue\", store authentication information like userID=1493, since user trivially change cookie another user’s ID impersonate . ’d like use cookies store information guarantees user either read modify state, see Encrypted Cookies section).","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"external-data-store","dir":"Articles","previous_headings":"","what":"External Data Store","title":"Runtime","text":"final option consider coordinating state API leveraging external data store. relational database (like MySQL Amazon RedShift), non-relational database (like MongoDB), transactional data store like Redis. One important consideration options ensure “transactional,” meaning two Plumber processes trying write time won’t overwrite one another. ’re interested pursuing option see solutions.rstudio.com/db/ look resources put together Shiny pertains dealing databases web-accessible R platform.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/execution-model.html","id":"exit-handlers","dir":"Articles","previous_headings":"","what":"Exit Handlers","title":"Runtime","text":"may useful define function want run API closing – instance, pool database connections need cleaned Plumber process terminated. can add handler \"end\" event . interrupt API (instance pressing Ctrl+C (blocking sessions) calling api_stop() (non-blocking sessions)) ’ll see Bye bye! printed console. can even register multiple end handlers ’ll run order registered.","code":"api(\"plumber.R\") |>   api_on(\"end\", function(){     print(\"Bye bye!\")   }) |>   api_run()"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"posit-connect","dir":"Articles","previous_headings":"","what":"Posit Connect","title":"Hosting","text":"Posit Connect enterprise publishing platform Posit. supports push-button publishing RStudio IDE variety R content types including Plumber APIs. Unlike options listed , Posit Connect automatically manages dependent packages files API recreates environment closely mimicking local development environment server. Posit Connect automatically manages number R processes necessary handle current load balances incoming traffic across available processes. can also shut idle processes ’re use. allows run appropriate number R processes scale capacity accommodate current load.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"digitalocean","dir":"Articles","previous_headings":"","what":"DigitalOcean","title":"Hosting","text":"DigitalOcean easy--use Cloud Computing provider. offer simple way spin Linux virtual machine access remotely. can choose size machine want run – options ranging small machines 512MB RAM dollars month large machines dozens GB RAM – pay ’s online. deploy Plumber API DigitalOcean, please check plumber companion package plumberDeploy.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"docker","dir":"Articles","previous_headings":"","what":"Docker (Basic)","title":"Hosting","text":"Docker platform built top Linux Containers allow run processes isolated environment; environment might certain resources/software pre-configured may emulate particular Linux environment like Ubuntu 14.04 CentOS 7.3. won’t delve details Docker setup install everything system. Docker provides great resources looking get started. ’ll assume Docker installed ’re familiar basic commands required spin container. article, ’ll take advantage rstudio/plumber Docker image bundles recent version R recent version plumber pre-installed (underlying R image courtesy rocker project). can get image Remember get current snapshot Plumber continue use image run pull . ’ll start just running single Plumber application Docker just see things work. default, rstudio/plumber image take first argument image name name file want plumb() serve port 8080. right away can run one examples ’s included plumber already installed image. : docker run tells Docker run new container --rm tells Docker clean-container ’s done -p 8080:8080 says map port 8080 plumber container (’ll run server) port 8080 local machine rstudio/plumber name image want run /usr/local/lib/R/site-library/plumber/plumber/03-mean-sum/plumber.R path inside Docker container Plumber file want host. ’ll note need plumber installed host machine work, path /usr/local/... need exist host machine. references path inside docker container R file want plumb() can found. mean-sum path default path image uses don’t specify one . ask Plumber plumb run file specified port 8080 new container. used -p argument, port 8080 local machine forwarded container. can test running machine Docker running: curl localhost:8080/mean, know IP address machine Docker running, visit web browser. /mean path one ’s defined plumber file just specified – get single number array back ([-0.1993]). works, can try using one plumber files arrangement. Keep mind file want run must available inside container must specify path file exists inside container. Keep simple now – use plumber file doesn’t require additional R packages depend files outside plumber definition. instance plumber file saved current directory called api.R, use following command ’ll notice used -v argument specify “volume” mapped host machine Docker container. defined location file /plumber.R, ’s argument give last tell container look plumber definition. can use technique share whole directory instead just passing single R file; approach useful Plumber API depends files. can also use rstudio/plumber image just like use . example, want start container based image poke around bash shell: can handy way debug problems. Prepare command think work add --entrypoint /bin/bash rstudio/plumber explore bit. Alternatively, can try run R process spawn plumber application see things go wrong (often missing package missing file). can build upon rstudio/plumber image build Docker image writing Dockerfile. Dockerfiles vast array options possible configurations, see official docs want learn options. couple commands relevant : RUN runs command persists side-effects Docker image ’re building. want build new image broom package, add line Dockerfile says RUN R -e \"install.packages('broom')\" make broom package available new Docker image. ENTRYPOINT command run starting image. rstudio/plumber specifies entrypoint starts R, plumb()s file, run()s router. want change plumber starts, run extra commands (like add global processor) run router, ’ll need provide custom ENTRYPOINT. CMD default arguments provide ENTRYPOINT. rstudio/plumber uses first argument name file want plumb(). custom Dockerfile simple : Dockerfile just extend rstudio/plumber image two ways. First, RUNs one additional command install broom package. Second, customizes default CMD argument used running image. case, expected mount Plumber application container /app/plumber.R build custom Docker image Dockerfile using command docker build -t mycustomdocker . (. – current directory – directory Dockerfile stored). ’d able use docker run --rm -vpwd:/app mycustomdocker run custom image, passing application’s directory volume mounted /app. want container start automatically machine booted, can use --restart parameter docker run. docker run -p 1234:8080 -dit --restart=unless-stopped myCustomDocker run custom image created automatically every time machine boots expose plumber service port 1234 host machine, unless container explicitly stopped. Like hosting options, ’ll need make sure firewall allows connections port 1234 want others able access service.","code":"docker pull rstudio/plumber docker run --rm -p 8080:8080 rstudio/plumber docker run --rm -p 8080:8080 rstudio/plumber \\   /usr/local/lib/R/site-library/plumber/plumber/04-mean-sum/plumber.R docker run --rm -p 8080:8080 -v `pwd`/api.R:/plumber.R rstudio/plumber /plumber.R docker run -it --rm --entrypoint /bin/bash rstudio/plumber FROM rstudio/plumber LABEL org.opencontainers.image.authors=\"Docker User <docker@user.org>\"  RUN R -e \"install.packages('broom')\"  CMD [\"/app/plumber.R\"]"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"default-dockerfile","dir":"Articles","previous_headings":"","what":"Default Dockerfile","title":"Hosting","text":"’ll start just running single Plumber application Docker just see things work. default, rstudio/plumber image take first argument image name name file want plumb() serve port 8080. right away can run one examples ’s included plumber already installed image. : docker run tells Docker run new container --rm tells Docker clean-container ’s done -p 8080:8080 says map port 8080 plumber container (’ll run server) port 8080 local machine rstudio/plumber name image want run /usr/local/lib/R/site-library/plumber/plumber/03-mean-sum/plumber.R path inside Docker container Plumber file want host. ’ll note need plumber installed host machine work, path /usr/local/... need exist host machine. references path inside docker container R file want plumb() can found. mean-sum path default path image uses don’t specify one . ask Plumber plumb run file specified port 8080 new container. used -p argument, port 8080 local machine forwarded container. can test running machine Docker running: curl localhost:8080/mean, know IP address machine Docker running, visit web browser. /mean path one ’s defined plumber file just specified – get single number array back ([-0.1993]). works, can try using one plumber files arrangement. Keep mind file want run must available inside container must specify path file exists inside container. Keep simple now – use plumber file doesn’t require additional R packages depend files outside plumber definition. instance plumber file saved current directory called api.R, use following command ’ll notice used -v argument specify “volume” mapped host machine Docker container. defined location file /plumber.R, ’s argument give last tell container look plumber definition. can use technique share whole directory instead just passing single R file; approach useful Plumber API depends files. can also use rstudio/plumber image just like use . example, want start container based image poke around bash shell: can handy way debug problems. Prepare command think work add --entrypoint /bin/bash rstudio/plumber explore bit. Alternatively, can try run R process spawn plumber application see things go wrong (often missing package missing file).","code":"docker run --rm -p 8080:8080 rstudio/plumber docker run --rm -p 8080:8080 rstudio/plumber \\   /usr/local/lib/R/site-library/plumber/plumber/04-mean-sum/plumber.R docker run --rm -p 8080:8080 -v `pwd`/api.R:/plumber.R rstudio/plumber /plumber.R docker run -it --rm --entrypoint /bin/bash rstudio/plumber"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"custom-dockerfiles","dir":"Articles","previous_headings":"","what":"Custom Dockerfiles","title":"Hosting","text":"can build upon rstudio/plumber image build Docker image writing Dockerfile. Dockerfiles vast array options possible configurations, see official docs want learn options. couple commands relevant : RUN runs command persists side-effects Docker image ’re building. want build new image broom package, add line Dockerfile says RUN R -e \"install.packages('broom')\" make broom package available new Docker image. ENTRYPOINT command run starting image. rstudio/plumber specifies entrypoint starts R, plumb()s file, run()s router. want change plumber starts, run extra commands (like add global processor) run router, ’ll need provide custom ENTRYPOINT. CMD default arguments provide ENTRYPOINT. rstudio/plumber uses first argument name file want plumb(). custom Dockerfile simple : Dockerfile just extend rstudio/plumber image two ways. First, RUNs one additional command install broom package. Second, customizes default CMD argument used running image. case, expected mount Plumber application container /app/plumber.R build custom Docker image Dockerfile using command docker build -t mycustomdocker . (. – current directory – directory Dockerfile stored). ’d able use docker run --rm -vpwd:/app mycustomdocker run custom image, passing application’s directory volume mounted /app.","code":"FROM rstudio/plumber LABEL org.opencontainers.image.authors=\"Docker User <docker@user.org>\"  RUN R -e \"install.packages('broom')\"  CMD [\"/app/plumber.R\"]"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"automatically-run-on-restart","dir":"Articles","previous_headings":"","what":"Automatically Run on Restart","title":"Hosting","text":"want container start automatically machine booted, can use --restart parameter docker run. docker run -p 1234:8080 -dit --restart=unless-stopped myCustomDocker run custom image created automatically every time machine boots expose plumber service port 1234 host machine, unless container explicitly stopped. Like hosting options, ’ll need make sure firewall allows connections port 1234 want others able access service.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"docker-advanced","dir":"Articles","previous_headings":"","what":"Docker (Advanced)","title":"Hosting","text":"already basic Docker instance running, may interested advanced configurations capable hosting multiple plumber applications single server even load-balancing across multiple plumber processes. order coordinate run multiple Plumber processes one server, install docker-compose system. included installations Docker, need follow instructions currently able run docker-compose command-line. Docker Compose helps orchestrate multiple Docker containers. ’re planning run one Plumber process, ’ll want use Docker Compose keep alive route traffic . ’ll use Docker Compose help us organize multiple Plumber processes. won’t go detail use Docker Compose, ’re new familiarize using official docs. define Docker Compose configuration defines behavior every Plumber application want run. ’ll first want setup Dockerfile defines desired behavior applications (outlined previously. use docker-compose.yml configuration like following: detail options options exist can found . configuration defines two Docker containers run app1 app2. associated files case laid disk follows: can see app2 simpler two apps; just plumber definition run plumb(). merely use default plumber Docker image image, customize command specify Plumber API definition can found container. Since ’re mapping host’s ./app2 /app inside container, definition found /app/plumber.R. specify always restart anything ever happens container, export port 8080 container port 7001 host. app1 complicated app. extra data another directory needs loaded, custom Dockerfile. additional R packages system dependencies requires. now run docker-compose , Docker Compose build referenced images config file run . ’ll find app1 available port 7000 machine running Docker Compose, app2 available port 7001. want APIs run background survive restarts server, can use -d switch just like docker run. may desirable run Plumber services standard port like 80 (HTTP) 443 (HTTPS). case, ’d prefer router running port 80 can send traffic appropriate Plumber API distinguishing based path prefix. Requests myserver.com/app1/ sent app1 container, myserver.org/app2/ target app2 container, paths available port 80 server. order , can use another Docker container running nginx configured route traffic two Plumber containers. ’d add following entry docker-compose.yml app containers already defined. uses nginx Docker image downloaded . order run nginx meaningful way, provide configuration file place /etc/nginx/nginx.conf, mounting local file location container. basic nginx config file look something like following: set server_name parameter whatever public address server. can save file nginx.conf directory Compose config file. Docker Compose intelligent enough know route traffic http://app1:8080/ app1 container, port 8080, can leverage config file. Docker containers able contact non-public ports, can go directly port 8080 containers. proxy configuration trim prefix request sends applications, applications don’t need know anything hosted publicly URL includes /app1/ /app2/ prefixes. also get rid previous port mappings ports 7000 7001 applications, don’t want expose APIs ports anymore. now run docker compose , ’ll see two application servers running now new nginx server running, well. ’ll find visit server port 80, ’ll see “welcome Nginx!” page. access /app1 ’ll sent app1 just like hoped. ’re expecting lot traffic one application API ’s particularly computationally complex, may want distribute load across multiple R processes running Plumber application. Thankfully, can use Docker Compose , well. First, ’ll want create multiple instances application. easily accomplished docker-compose scale command. simply run docker-compose scale app1=3 run three instances app1. Now just need load balance traffic across three instances. setup nginx configuration already balance traffic across pool workers, need manually re-configure update nginx instance every time need scale number , might hassle. Luckily, ’s elegant solution. can use dockercloud/haproxy Docker image automatically balance HTTP traffic across pool workers. image intelligent enough listen workers pool arriving leaving automatically remove/add containers pool. Let’s add new container configuration defines load balancer trick allows image listen scaling app1 passing docker socket shared volume. Note particular arrangement differ based host OS. configuration intended Linux, MacOS X users require slightly different config. export port 80 new load balancer port 80 host machine solely wanted load-balance single application. Alternatively, can actually use nginx (handle routing various applications) HAProxy (handle load balancing particular application). , ’d merely add new location block nginx.conf file knows send traffic HAProxy, modify existing location block send traffic load balancer instead going directly application. location /app1/ block becomes: lb name HAProxy load balancer defined Compose configuration. next time start/redeploy Docker Compose cluster, ’ll balancing incoming requests /app1/ across pool 1 R processes based whatever ’ve set scale application. keep mind using load-balancing ’s longer guaranteed subsequent requests particular application land process. means maintain state Plumber application (like global counter, user’s session state), can’t expect shared across processes user might encounter. least three possible solutions problem: Use robust means maintaining state. put state database, instance, lives outside R processes Plumber processes get save state externally. serialize state user using (encrypted) session cookies, assuming ’s small enough. scenario, workers write data back user form cookie, user include cookie subsequent requests. works best state going set rarely read often (instance, cookie set user logs , read request detect identity user). can enable “sticky sessions” HAProxy load balancer. ensure user’s traffic always gets routed worker. downside approach distribute traffic less evenly. end situation 2 R processes application 90% traffic hitting one happens users triggering majority requests “stuck” one particular worker.","code":"services:   app1:     build: ./app1/     volumes:      - ./data:/data      - ./app1:/app     restart: always     ports:      - \"7000:8080\"   app2:     image: rstudio/plumber     command: /app/plumber.R     volumes:      - ../app2:/app     restart: always     ports:      - \"7001:8080\" docker-compose.yml app1 ├── Dockerfile ├── api.R app2 ├── plumber.R data ├── data.csv nginx:     image: nginx:1.9     ports:      - \"80:80\"     volumes:      - ./nginx.conf:/etc/nginx/nginx.conf:ro     restart: always     depends_on:      - app1      - app2 events {   worker_connections  4096;  ## Default: 1024 }  http {         default_type application/octet-stream;         sendfile     on;         tcp_nopush   on;         server_names_hash_bucket_size 128; # this seems to be required for some vhosts          server {                 listen 80 default_server;                 listen [::]:80 default_server ipv6only=on;                  root /usr/share/nginx/html;                 index index.html index.htm;                  server_name MYSERVER.ORG;                  location /app1/ {                         proxy_pass http://app1:8080/;                         proxy_set_header Host $host;                 }                  location /app2/ {                         proxy_pass http://app2:8080/;                         proxy_set_header Host $host;                 }                   location ~ /\\.ht {                         deny all;                 }         } } lb:     image: 'dockercloud/haproxy:1.2.1'     links:      - app1     volumes:       - /var/run/docker.sock:/var/run/docker.sock location /app1/ {   proxy_pass http://lb/;   proxy_set_header Host $host; }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"multiple-plumber-applications","dir":"Articles","previous_headings":"","what":"Multiple Plumber Applications","title":"Hosting","text":"’ll use Docker Compose help us organize multiple Plumber processes. won’t go detail use Docker Compose, ’re new familiarize using official docs. define Docker Compose configuration defines behavior every Plumber application want run. ’ll first want setup Dockerfile defines desired behavior applications (outlined previously. use docker-compose.yml configuration like following: detail options options exist can found . configuration defines two Docker containers run app1 app2. associated files case laid disk follows: can see app2 simpler two apps; just plumber definition run plumb(). merely use default plumber Docker image image, customize command specify Plumber API definition can found container. Since ’re mapping host’s ./app2 /app inside container, definition found /app/plumber.R. specify always restart anything ever happens container, export port 8080 container port 7001 host. app1 complicated app. extra data another directory needs loaded, custom Dockerfile. additional R packages system dependencies requires. now run docker-compose , Docker Compose build referenced images config file run . ’ll find app1 available port 7000 machine running Docker Compose, app2 available port 7001. want APIs run background survive restarts server, can use -d switch just like docker run.","code":"services:   app1:     build: ./app1/     volumes:      - ./data:/data      - ./app1:/app     restart: always     ports:      - \"7000:8080\"   app2:     image: rstudio/plumber     command: /app/plumber.R     volumes:      - ../app2:/app     restart: always     ports:      - \"7001:8080\" docker-compose.yml app1 ├── Dockerfile ├── api.R app2 ├── plumber.R data ├── data.csv"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"multiple-applications-on-one-port","dir":"Articles","previous_headings":"","what":"Multiple Applications on One Port","title":"Hosting","text":"may desirable run Plumber services standard port like 80 (HTTP) 443 (HTTPS). case, ’d prefer router running port 80 can send traffic appropriate Plumber API distinguishing based path prefix. Requests myserver.com/app1/ sent app1 container, myserver.org/app2/ target app2 container, paths available port 80 server. order , can use another Docker container running nginx configured route traffic two Plumber containers. ’d add following entry docker-compose.yml app containers already defined. uses nginx Docker image downloaded . order run nginx meaningful way, provide configuration file place /etc/nginx/nginx.conf, mounting local file location container. basic nginx config file look something like following: set server_name parameter whatever public address server. can save file nginx.conf directory Compose config file. Docker Compose intelligent enough know route traffic http://app1:8080/ app1 container, port 8080, can leverage config file. Docker containers able contact non-public ports, can go directly port 8080 containers. proxy configuration trim prefix request sends applications, applications don’t need know anything hosted publicly URL includes /app1/ /app2/ prefixes. also get rid previous port mappings ports 7000 7001 applications, don’t want expose APIs ports anymore. now run docker compose , ’ll see two application servers running now new nginx server running, well. ’ll find visit server port 80, ’ll see “welcome Nginx!” page. access /app1 ’ll sent app1 just like hoped.","code":"nginx:     image: nginx:1.9     ports:      - \"80:80\"     volumes:      - ./nginx.conf:/etc/nginx/nginx.conf:ro     restart: always     depends_on:      - app1      - app2 events {   worker_connections  4096;  ## Default: 1024 }  http {         default_type application/octet-stream;         sendfile     on;         tcp_nopush   on;         server_names_hash_bucket_size 128; # this seems to be required for some vhosts          server {                 listen 80 default_server;                 listen [::]:80 default_server ipv6only=on;                  root /usr/share/nginx/html;                 index index.html index.htm;                  server_name MYSERVER.ORG;                  location /app1/ {                         proxy_pass http://app1:8080/;                         proxy_set_header Host $host;                 }                  location /app2/ {                         proxy_pass http://app2:8080/;                         proxy_set_header Host $host;                 }                   location ~ /\\.ht {                         deny all;                 }         } }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"load-balancing","dir":"Articles","previous_headings":"","what":"Load Balancing","title":"Hosting","text":"’re expecting lot traffic one application API ’s particularly computationally complex, may want distribute load across multiple R processes running Plumber application. Thankfully, can use Docker Compose , well. First, ’ll want create multiple instances application. easily accomplished docker-compose scale command. simply run docker-compose scale app1=3 run three instances app1. Now just need load balance traffic across three instances. setup nginx configuration already balance traffic across pool workers, need manually re-configure update nginx instance every time need scale number , might hassle. Luckily, ’s elegant solution. can use dockercloud/haproxy Docker image automatically balance HTTP traffic across pool workers. image intelligent enough listen workers pool arriving leaving automatically remove/add containers pool. Let’s add new container configuration defines load balancer trick allows image listen scaling app1 passing docker socket shared volume. Note particular arrangement differ based host OS. configuration intended Linux, MacOS X users require slightly different config. export port 80 new load balancer port 80 host machine solely wanted load-balance single application. Alternatively, can actually use nginx (handle routing various applications) HAProxy (handle load balancing particular application). , ’d merely add new location block nginx.conf file knows send traffic HAProxy, modify existing location block send traffic load balancer instead going directly application. location /app1/ block becomes: lb name HAProxy load balancer defined Compose configuration. next time start/redeploy Docker Compose cluster, ’ll balancing incoming requests /app1/ across pool 1 R processes based whatever ’ve set scale application. keep mind using load-balancing ’s longer guaranteed subsequent requests particular application land process. means maintain state Plumber application (like global counter, user’s session state), can’t expect shared across processes user might encounter. least three possible solutions problem: Use robust means maintaining state. put state database, instance, lives outside R processes Plumber processes get save state externally. serialize state user using (encrypted) session cookies, assuming ’s small enough. scenario, workers write data back user form cookie, user include cookie subsequent requests. works best state going set rarely read often (instance, cookie set user logs , read request detect identity user). can enable “sticky sessions” HAProxy load balancer. ensure user’s traffic always gets routed worker. downside approach distribute traffic less evenly. end situation 2 R processes application 90% traffic hitting one happens users triggering majority requests “stuck” one particular worker.","code":"lb:     image: 'dockercloud/haproxy:1.2.1'     links:      - app1     volumes:       - /var/run/docker.sock:/var/run/docker.sock location /app1/ {   proxy_pass http://lb/;   proxy_set_header Host $host; }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"pm2","dir":"Articles","previous_headings":"","what":"pm2","title":"Hosting","text":"don’t luxury running Plumber instance designated server (discussed DigitalOcean section) ’re comfortable hosting API Docker, ’ll need find way run manage Plumber APIs server directly. variety tools built help manage web hosting single-threaded environment like R. compelling tools developed around Ruby (like Phusion Passenger) Node.js (like Node Supervisor, forever pm2). Thankfully, many tools can adapted support managing R process running Plumber API. pm2 process manager initially targeting Node.js. ’ll show commands needed Ubuntu 14.04, can use Operating System distribution supported pm2. end, ’ll server automatically starts plumber services booted, restarts ever crash, even centralizes logs plumber services. first thing ’ll need , regardless process manager choose, deploy R files containing plumber applications server ’ll hosted. Keep mind ’ll also need include supplemental R files source()d plumber file, datasets dependencies files . ’ll also need make sure R packages need (appropriate versions) available remote server. can either manually installing packages can consider using tool like Packrat help . myriad features pm2 won’t cover . good idea spend time reading documentation see features might interest ensure understand implications pm2 hosts services (user want run processes , etc.). quick-start guide may especially relevant. sake simplicity, basic installation without customizing many options. Now ’re ready install pm2. pm2 package ’s maintained npm (Node.js’s package management system); also requires Node.js order run. start ’ll want install Node.js. Ubuntu 14.04, necessary commands : npm Node.js installed, ’re ready install pm2. find errors like SSL Error: CERT_UNTRUSTED using npm command, can bypass ssl error using: set registry URL https:// http://: install pm2 globally (-g) server, meaning now able run pm2 --version get version number pm2 ’ve installed. order get pm2 startup services boot, run sudo pm2 startup create necessary files system run pm2 boot machine. ’ve deployed Plumber files onto server, ’ll still need tell server run server. ’re probably used running commands like Unfortunately, pm2 doesn’t understand R scripts natively; however, possible specify custom interpreter. can use feature launch R-based wrapper plumber file using Rscript scripting front-end comes R. following script run two commands listed . Save R script server something like run-myfile.R. also make executable changing permissions file using command like chmod 755 run-myfile.R. now execute file make sure runs service like expect. able make requests server appropriate port plumber service respond. can kill process using Ctrl-c ’re convinced ’s working. Make sure shell script permanent location won’t erased modified accidentally. can consider creating designated directory plumber services directory like /usr/local/plumber, put services associated Rscript-runners subdirectory like /usr/local/plumber/myfile/. ’ll now need teach pm2 Plumber API can put work. can register configure number services pm2; let’s start myfile Plumber service. can use pm2 list command see services pm2 already running. run command now, ’ll see pm2 doesn’t services ’s charge . scripts code stored directory want , use following command tell pm2 service. see output pm2 starting instance service, followed status information pm2. everything worked properly, ’ll see new service registered running. can see output executing pm2 list . ’re happy pm2 services defined, can use pm2 save tell pm2 retain set services running next time boot machine. services defined automatically restarted . point, persistent pm2 service created Plumber application. means can reboot server, find kill underlying R process plumber application using pm2 automatically bring new process replace . help guarantee always Plumber process running port number specified shell script. good idea reboot server ensure everything comes back way expected. can repeat process plumber applications want deploy, long give unique port run . Remember can’t one service running single port. sure pm2 save every time add services want survive restart. Run netstat -tulpn see application ran. see application host 127.0.0.0 127.0.0.1, application accessed externally. change host parameter 0.0.0.0, example: `pr_run(host = “0.0.0.0”). Now applications defined pm2, may want drill manage debug . want see information, use pm2 show command specify name application pm2 list. usually name shell script specified, may something like pm2 show run-myfile. can peruse information keep eye restarts count applications. application restart many times, implies process crashing often, sign ’s problem code. Thankfully, pm2 automatically manages log files underlying processes. ever need check log files service, can just run pm2 logs run-myfile, myfile name service obtained pm2 list. command show last lines logged process, begin streaming incoming log lines exit (Ctrl-c). want big-picture view health server pm2 services, can run pm2 monit show dashboard RAM CPU usage services.","code":"sudo apt-get update sudo apt-get install nodejs npm sudo npm install -g pm2 npm config set strict-ssl false npm config set registry=\"http://registry.npmjs.org/\" api(\"myfile.R\", port=4500) |>   api_run() #!/usr/bin/env Rscript  library(plumber2) api(\"myfile.R\", host=\"0.0.0.0\", port=4500) |>   api_run() # Setting the host option on a VM instance ensures the application can be accessed externally. # (This may be only true for Linux users.) pm2 start --interpreter=\"Rscript\" /usr/local/plumber/myfile/run-myfile.R"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"server-deployment-and-preparation","dir":"Articles","previous_headings":"","what":"Server Deployment and Preparation","title":"Hosting","text":"first thing ’ll need , regardless process manager choose, deploy R files containing plumber applications server ’ll hosted. Keep mind ’ll also need include supplemental R files source()d plumber file, datasets dependencies files . ’ll also need make sure R packages need (appropriate versions) available remote server. can either manually installing packages can consider using tool like Packrat help . myriad features pm2 won’t cover . good idea spend time reading documentation see features might interest ensure understand implications pm2 hosts services (user want run processes , etc.). quick-start guide may especially relevant. sake simplicity, basic installation without customizing many options.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"install-pm2","dir":"Articles","previous_headings":"","what":"Install pm2","title":"Hosting","text":"Now ’re ready install pm2. pm2 package ’s maintained npm (Node.js’s package management system); also requires Node.js order run. start ’ll want install Node.js. Ubuntu 14.04, necessary commands : npm Node.js installed, ’re ready install pm2. find errors like SSL Error: CERT_UNTRUSTED using npm command, can bypass ssl error using: set registry URL https:// http://: install pm2 globally (-g) server, meaning now able run pm2 --version get version number pm2 ’ve installed. order get pm2 startup services boot, run sudo pm2 startup create necessary files system run pm2 boot machine.","code":"sudo apt-get update sudo apt-get install nodejs npm sudo npm install -g pm2 npm config set strict-ssl false npm config set registry=\"http://registry.npmjs.org/\""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"wrap-your-plumber-file","dir":"Articles","previous_headings":"","what":"Wrap Your Plumber File","title":"Hosting","text":"’ve deployed Plumber files onto server, ’ll still need tell server run server. ’re probably used running commands like Unfortunately, pm2 doesn’t understand R scripts natively; however, possible specify custom interpreter. can use feature launch R-based wrapper plumber file using Rscript scripting front-end comes R. following script run two commands listed . Save R script server something like run-myfile.R. also make executable changing permissions file using command like chmod 755 run-myfile.R. now execute file make sure runs service like expect. able make requests server appropriate port plumber service respond. can kill process using Ctrl-c ’re convinced ’s working. Make sure shell script permanent location won’t erased modified accidentally. can consider creating designated directory plumber services directory like /usr/local/plumber, put services associated Rscript-runners subdirectory like /usr/local/plumber/myfile/.","code":"api(\"myfile.R\", port=4500) |>   api_run() #!/usr/bin/env Rscript  library(plumber2) api(\"myfile.R\", host=\"0.0.0.0\", port=4500) |>   api_run() # Setting the host option on a VM instance ensures the application can be accessed externally. # (This may be only true for Linux users.)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"introduce-our-service-to-pm2","dir":"Articles","previous_headings":"","what":"Introduce Our Service to pm2","title":"Hosting","text":"’ll now need teach pm2 Plumber API can put work. can register configure number services pm2; let’s start myfile Plumber service. can use pm2 list command see services pm2 already running. run command now, ’ll see pm2 doesn’t services ’s charge . scripts code stored directory want , use following command tell pm2 service. see output pm2 starting instance service, followed status information pm2. everything worked properly, ’ll see new service registered running. can see output executing pm2 list . ’re happy pm2 services defined, can use pm2 save tell pm2 retain set services running next time boot machine. services defined automatically restarted . point, persistent pm2 service created Plumber application. means can reboot server, find kill underlying R process plumber application using pm2 automatically bring new process replace . help guarantee always Plumber process running port number specified shell script. good idea reboot server ensure everything comes back way expected. can repeat process plumber applications want deploy, long give unique port run . Remember can’t one service running single port. sure pm2 save every time add services want survive restart. Run netstat -tulpn see application ran. see application host 127.0.0.0 127.0.0.1, application accessed externally. change host parameter 0.0.0.0, example: `pr_run(host = “0.0.0.0”).","code":"pm2 start --interpreter=\"Rscript\" /usr/local/plumber/myfile/run-myfile.R"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"logs-and-management","dir":"Articles","previous_headings":"","what":"Logs and Management","title":"Hosting","text":"Now applications defined pm2, may want drill manage debug . want see information, use pm2 show command specify name application pm2 list. usually name shell script specified, may something like pm2 show run-myfile. can peruse information keep eye restarts count applications. application restart many times, implies process crashing often, sign ’s problem code. Thankfully, pm2 automatically manages log files underlying processes. ever need check log files service, can just run pm2 logs run-myfile, myfile name service obtained pm2 list. command show last lines logged process, begin streaming incoming log lines exit (Ctrl-c). want big-picture view health server pm2 services, can run pm2 monit show dashboard RAM CPU usage services.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/hosting.html","id":"systemd","dir":"Articles","previous_headings":"","what":"systemd","title":"Hosting","text":"systemd service manager used certain Linux distributions including RedHat/CentOS 7, SUSE 12, Ubuntu versions 16.04 later. use Linux server can use systemd run Plumber service can accessed local network even outside network depending firewall rules. option similar using Docker method. One main advantages using systemd using Docker systemd won’t bypass firewall rules (Docker !) avoids overhead running container. implement option ’ll complete following three steps terminal: Verify plumber2 package available globally server: Run sudo nano /etc/systemd/system/plumber-api.service, paste adapt content: Activate service (auto-start power/reboot) start : check API running, type systemctl | grep running terminal display plumber-api.service \\ loaded active running Plumber API.","code":"R -e 'install.packages(\"plumber2\", repos = \"https://cran.rstudio.com/\")' [Unit] Description=Plumber2 API # After=postgresql # (or mariadb, mysql, etc if you use a DB with Plumber2, otherwise leave this commented)  [Service] ExecStart=/usr/bin/Rscript -e \"library(plumber2); api('/your-dir/your-api-script.R', host='0.0.0.0', port=8080) |> api_run()\" Restart=on-abnormal WorkingDirectory=/your-dir/  [Install] WantedBy=multi-user.target sudo systemctl enable plumber-api  # automatically start the service when the server boots sudo systemctl start plumber-api   # start the service right now"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/introduction.html","id":"web-apis","dir":"Articles","previous_headings":"","what":"Web APIs","title":"Introduction","text":"Hypertext Transfer Protocol (HTTP) dominant medium information exchanged Internet. Application Programming Interface (API) broad term defines rules guide interaction software. case HTTP APIs, defined set endpoints accept particular inputs. Plumber2 translates annotations place functions HTTP API can called machines network. execute Plumber API public server, can even make API available public Internet. HTTP APIs become predominant language software communicates. creating HTTP API, ’ll empower R code leveraged services – whether ’re housed inside organization hosted side world. just ideas doors opened wrap R code Plumber API: Software written languages organization can run R code. company’s Java application now pull custom ggplot2 graph generate -demand, Python client query predictive model defined R. can third-party receive emails behalf notify Plumber service new messages arrive. register “Slash Command” Slack, enabling execute R function response command entered Slack. can write JavaScript code queries Plumber API visitor’s web browser. Even , use Plumber exclusively back-end interactive web application.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"moving-from-plumber","dir":"Articles","previous_headings":"","what":"Moving from plumber","title":"Upgrading From Plumber","text":"Plumber2 designed way make familiar long-time plumber users. However, created explicit intend API-compatible old plumber code plumber files, except simplest cases. done allow us learn many years experience plumber keep work shedding proven suboptimal. coming plumber document may serve starting ground recalibrating ways plumber2, well aid updating old plumber APIs plumber2.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"pr_-to-api_","dir":"Articles","previous_headings":"","what":"pr_*() to api_*()","title":"Upgrading From Plumber","text":"One first changes may recognise functional interface gotten prefix change. done, partly avoid namespace conflicts plumber, partly avoid users assuming functions worked 100% equivalently, partly pr prefix descriptive. acronym Plumber Route, API much router (especially plumber2) general prefix doesn’t make sense. new prefix, api, well-known acronym (Application Programming Interface) single meaning fits plumber2 meant help creates. plumber object creating also referred Plumber API underscore . functional interface match 1--1 substitute prefix shouldn’t expect find-replace needed.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"only-path-arguments-are-passed-as-named-arguments-to-your-handler","dir":"Articles","previous_headings":"","what":"Only path arguments are passed as named arguments to your handler","title":"Upgrading From Plumber","text":"plumber, path argument, query parameters, potentially body parts used named arguments calling handler function. presented multiple problems, first foremost one win name clashes . also meant query string always parsed even handler didn’t use anything, adding unnecessary overhead. plumber2 avoid confusion supplying path arguments handler function named arguments. Query parameters request body passed function query body argument respectively. , passed way means function doesn’t touch never parsed. change means handler contains arguments meant come query string request body update accept query /body argument grab need .","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"no-more-filter-and-preempt","dir":"Articles","previous_headings":"","what":"No more filter and preempt","title":"Upgrading From Plumber","text":"Filters preempt removed completely plumber2. existed mainly plumber way letting users perform multiple chained operations requests. plumber2 possible many routes want, one tried sequence. possible routes called request completely recieved. can used inspect headers request reject even enters main router chain. functionality default filters plumber moved. body, query, cookie parsing now handled reqres fully automated way. shared-secret filter automatically created handler header route shared secret found options.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"forward-replaced-by-next-and-break","dir":"Articles","previous_headings":"","what":"forward replaced by Next and Break","title":"Upgrading From Plumber","text":"Since filters , forward filter specific construct also gone. However, since every handler might now one chain handlers, added new ways control flow request handling. handler assumed pass handling next () handler chain. can make explicit returning Next handler, required. ’d often like instead return object assigned response body can well. Basically returning anything Break allow handling chain continue execution. However, returning Break inform plumber2 handler specifically wants return response right now modification (except serializing). useful header route handlers reject requests early , can also used normal request handling e.g. know ressource moved want return redirect response immediately. might also want use Break handler catches error need abort. However, plumber2 offers much better way utilising abort_*() functions reqres. Throwing exception immediately stop handling request, set response according abort content log error.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"new-request-and-response-objects","dir":"Articles","previous_headings":"","what":"New Request and Response objects","title":"Upgrading From Plumber","text":"Plumber provided objects working HTTP request responses. plumber2 now uses Request Response objects reqres. highly capable classes removed lot internal logic plumber2. responsible content negotiation, cookies, headers, etc. support encrypted session data storage like used plumber.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"new-plumber-object","dir":"Articles","previous_headings":"","what":"New Plumber object","title":"Upgrading From Plumber","text":"main class encapsulating API , unsurprisingly, also changed plumber2. Fiery now used backbone plumber2 Plumber class now subclass powerful Fire class offers many capabilities advanced use, wish level plumber API","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/migration.html","id":"added-query-and-body-tags","dir":"Articles","previous_headings":"","what":"Added @query and @body tags","title":"Upgrading From Plumber","text":"plumber @param tag used document path parameters, query parameters request body. line making handler function arguments explicit also want apply documentation , now document query body explicit @query @body tags. syntax tags @param","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/plumber.html","id":"specifying-the-inputs","dir":"Articles","previous_headings":"","what":"Specifying the Inputs","title":"Get Started","text":"may noticed functions define endpoints accept parameters. parameters allow us customize behavior endpoints. example use two different ways specifying outputs. /echo/... handler take variable part path use argument. can see “test” used resulting json object provided different path, e.g. /echo/plumber “plumber” used instead. handler rely “query string” pass optional argument. visit http://localhost:8080/plot?spec=setosa, see similar graph one saw , now dataset filtered include “setosa” species iris dataset.  might guessed, spec=setosa portion URL sets spec element query setosa. details Plumber processes inputs available Routing & Input article.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/plumber.html","id":"customizing-the-output","dir":"Articles","previous_headings":"","what":"Customizing The Output","title":"Get Started","text":"previous example, saw one endpoint rendered JSON one produced image. However, visited /echo/test path web browser probably saw result rendered HTML. Plumber2 comes many different serializers can convert result R code variety formats. possible client (e.g. web browser) request specific format, server knows format generally oblige. browser usually prefers HTML, request wins default JSON representation plumber2 uses. wish ensure JSON always returned can make explicit using @serializer json sets JSON known output format. graphical output always explicit plumber knows set graphic device capture output. example use @serializer png graphic serializers available well, e.g. @serializer jpeg. neat able provide results variety formats unlikely formats makes sense output produce generally mindful serializers provide handler always produce HTML called. can even provide custom serializers define translate R object produced handler bits produce Plumber’s HTTP response. can find details Rendering & Output article.","code":"#* @get /hello #* @serializer html function() {   list(     body = list(       h1 = \"hello world\"     )   ) } <html><body><h1>hello world<\/h1><\/body><\/html>"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/programmatic-usage.html","id":"creating-and-controlling-routers","dir":"Articles","previous_headings":"","what":"Creating and Controlling routers","title":"Programmatic Usage","text":"work plumber2 API related request router. router entity funnels requests correct handler based path. router used plumber2 provided routr package can interacted directly request_router field plumber API object. Often though, interact indirectly functions methods. router can contain multiple routes route can contain multiple path handlers. request received router pass route turn. route select handler (one exist) request execute handler request. possible handler signal processing happen case remaining routes router skipped response send immediately. create plumber api based multiple files file define route named file routes ordered order inputs. instead create API programmatically can create new route calling api_add_route() naming non-existing route add handler. latter case route placed end stack whereas adding explicitly former approach allows insert location router wish. may also use api_add_route() add already defined routr route api.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/programmatic-usage.html","id":"defining-handlers","dir":"Articles","previous_headings":"","what":"Defining handlers","title":"Programmatic Usage","text":"can add handlers router using api_get(), api_post(), one handler functions. instance, define Plumber API responds GET requests / POST requests /submit, use following code: handler functions define calls identical code defined annotated file using annotations define API. handler functions take additional arguments allow control nuanced behavior handler like serializer(s) use. instance, following endpoint use default HTML serializer plumber2. worth noting difference adding handlers handler functions provided plumber2 routr::Route$add_handler() even though former based latter. latter approach handler added -’ll use routr’s syntax path variables (prefixing path element : rather enclosing <>). former handler wrapped another function talkes care much plumber2 “magic”, setting parsers serializers, providing type casting, supporting graphic output. Unless specifically want opt ’d best served using plumber2 provided handler functions. One place may want consider foregoing plumber API altogether writing plugin want plugin usable fiery apps plumber APIs.","code":"api() |>   api_get(\"/\", function(req, res){     # ...   }) |>   api_post(\"/submit\", function(req, res){     # ...   }) api() %>%   api_get(     path = \"/\",     handler = function(){       list(         body = list(           h1 = \"Programmatic Plumber!\"         )       )     },     serializers = get_serializers(\"html\")   )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/programmatic-usage.html","id":"listening-for-and-triggering-events","dir":"Articles","previous_headings":"","what":"Listening for and triggering events","title":"Programmatic Usage","text":"Plumber2 build upon fiery event-driven web server framework. course running several events fire event handlers triggered (e.g. router listening \"request\" events). generally rely router handling request event ensure requests handled structured manner, might want attach handlers events, e.g. \"start\" \"end\" events. can using api_on() function: can read event cycle fiery app fiery website. restricted listening predefined events. can add handlers event wish, ’ll need trigger event manually one predefined ones.","code":"api() |>   api_on(\"start\", function() {     print(\"Yay! I'm starting up\")   }) papi <- api() |>   api_on(\"hello\", function(name) {     print(\"Hello\", name)   })  ## Somewhere in your server code papi$trigger(\"hello\", name = \"Thomas\")"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/programmatic-usage.html","id":"mount-static","dir":"Articles","previous_headings":"","what":"Static File Routers","title":"Programmatic Usage","text":"Static files can served two different manners. Either using specialized route attached router, completely circumventing R session serving files directly. former approach flexible, latter performant make files directories stored ./myfiles directory available API /assets/ path.","code":"# Serving files as a standard route api() |>   api_assets(\"/assets\", \"./myfiles\") |>   api_run()  # Serving files directly api() |>   api_statics(\"/assets\", \"./myfiles\") |>   api_run()"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"response-object","dir":"Articles","previous_headings":"","what":"The Response Object","title":"Rendering Output","text":"plumber2 response object , like request object, provided reqres implemented R6 class object. Please consult reqres documentation -depth overview class can . response object accessible within handler provides response argument, since based R6, change happening handler persist. necessary handler interact directly response. Returning “classic” value handler function set response body value, often providing everything needed particular handler. return values differ : Returning NULL Next: Returning either modify response body, allow request handled next route stack Returning Break: modify response short-circuit handling, returning response -Returning response: may return response handler alter ’s body . Like returning NULL Next allow handling continue next route Using graphics serializer: graphics serializer use body set graphic captured serializer return value function ignored Returning ggplot object: ggplot object returned plotted graphics serializer may capture output wish make use powerful features reqres likely want interact response object directly. features include, accessing setting session cookie data, setting headers, taking full control content negotiation serializing.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"serializers","dir":"Articles","previous_headings":"","what":"Serializers","title":"Rendering Output","text":"order send response R API client, object must “serialized” format client can understand. JavaScript Object Notation (JSON) one standard commonly used web APIs. JSON serialization translates R objects like list(=123, b=\"hi!\") JSON text resembling {: 123, b: \"hi!\"}. JSON appropriate every situation, however. want API render HTML page might viewed browser, instance, need different serializer. Likewise, want return image rendered R, likely want use standard image format like PNG JPEG rather JSON. required decide single serializer front. server can provide different representations client can prefer specific representations. server can provide result different ways perform something called server-driven content negotiation, inspects request get client preferences chooses best serializer based . order use multiple serializers provide multiple @serializer tags, order determining server priority. two special values: none .... former instructs plumber2 serialization , leaving handler prepare response body set Content-Type header. latter insert non-selected serializers list position. e.g. : make YAML preferred response format still remaining serializers fall back client understand yaml. default, plumber2 uses registered serializers performs content negotiation based want ensure single output type set explicitly. Another reason set explicitly modify behavior providing arguments : may noticed JSON API responses generated Plumber render singular values (“scalars”) arrays. instance: value element, though ’s singular, still rendered array. may surprise initially, done keep output consistent. JSON differentiates scalar vector objects, R . creates ambiguity serializing R object JSON since unclear whether particular element rendered atomic value JSON array. Consider following API returns letters lexicographically “higher” given letter. example API , instance, produces scalar, instances produces vector. Visiting http://localhost:8080/boxed?letter=U http://localhost:8080/unboxed?letter=U return identical responses: However, http://localhost:8080/boxed?letter=Y produce: http://localhost:8080/unboxed?letter=Y produce: /boxed endpoint, name implies, produces “boxed” JSON output length-1 vectors still rendered array. Conversely, /unboxed endpoint sets auto_unbox=TRUE call jsonlite::toJSON, causing length-1 R vectors rendered JSON scalars. R doesn’t distinguish scalars vectors, API clients may respond differently encountering JSON array versus atomic value. may find API clients respond gracefully object expected vector becomes scalar one call. reason, Plumber inherits jsonlite::toJSON default setting auto_unbox=FALSE result length-1 vectors still rendered JSON arrays. can configure endpoint use unboxedJSON serializer (shown ) want alter behavior particular endpoint. couple functions aware around feature set. using boxed JSON serialization, jsonlite::unbox() can used force length-1 object R presented JSON scalar. using unboxed JSON serialization, () cause length-1 R object present JSON array. Graphics serializers special need setup teardown around handler order capture graphics output. mixed standard serializers. omitted using ... unless graphics serializer selected explicitly case ... refer remaining graphics serializers omit standard ones. standard serializers behaviour can modified specifying additional arguments serializer. Many arguments well-known using graphics devices R including width, height, bg among others. Arguments inside curly braces evaluated environment handler R expression valid. However, evaluated , parsing file, possible provide dynamic serializer settings way. wish dynamically size images, need render capture graphical output return contents appropriate Content-Type header. See existing image renderers model . instances may desirable return value directly R without serialization. can settings @serializer none turn automatic serialization plumber. Consider following handler: response returned endpoint contain body Literal text ! Content-Type header without additional serialization. similar vein can set Content-Type otherwise leave body unchanged providing mime type @serializer. can use annotation want control response send. Running API visiting http://localhost:8080/pdf download PDF generated R (display PDF natively, client supports ). plumber2 comes serializers cover use cases may want provide . can two ways. Either registering serializer refering name native serializer, specifying inline. may want serve toml files plumber doesn’t (yet) ship serializer . quickly create using blogdown::write_toml(). Serializers plumber2 factory functions take range arguments return unary function capable formatting response body: use directly handler @serializer application/toml format_toml() register : use like serializer: @serializer toml","code":"#* @serializer yaml #* @serializer ... #* @serializer json{na=\"string\"} jsonlite::toJSON(list(a=5)) #> {\"a\":[5]} #* Get letters after a given letter #* @serializer json #* @get /boxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] }  #* Get letters after a given letter #* @serializer unboxedJSON #* @get /unboxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] } [   \"V\",   \"W\",   \"X\",   \"Y\",   \"Z\" ] [   \"Z\" ] \"Z\" #* Example of customizing graphical output #* @serializer png{width = 400, height = 500} #* @get / function() {   plot(1:10) } #* Endpoint that bypasses serialization #* @get / #* @serializer none function(response) {   response$body <- \"Literal text here!\" } #* @serializer application/pdf #* @get /pdf function() {   tmp <- tempfile()   pdf(tmp)   plot(1:10, type=\"b\")   text(4, 8, \"PDF from plumber!\")   text(6, 2, paste(\"The time is\", Sys.time()))   dev.off()    readBin(tmp, \"raw\", n=file.info(tmp)$size) } format_toml <- function(...) {   function(x) {     blogdown::write_toml(x)   } } register_serializer(\"toml\", format_toml, \"application/toml\")"},{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"boxed-vs-unboxed-json","dir":"Articles","previous_headings":"","what":"Boxed vs Unboxed JSON","title":"Rendering Output","text":"may noticed JSON API responses generated Plumber render singular values (“scalars”) arrays. instance: value element, though ’s singular, still rendered array. may surprise initially, done keep output consistent. JSON differentiates scalar vector objects, R . creates ambiguity serializing R object JSON since unclear whether particular element rendered atomic value JSON array. Consider following API returns letters lexicographically “higher” given letter. example API , instance, produces scalar, instances produces vector. Visiting http://localhost:8080/boxed?letter=U http://localhost:8080/unboxed?letter=U return identical responses: However, http://localhost:8080/boxed?letter=Y produce: http://localhost:8080/unboxed?letter=Y produce: /boxed endpoint, name implies, produces “boxed” JSON output length-1 vectors still rendered array. Conversely, /unboxed endpoint sets auto_unbox=TRUE call jsonlite::toJSON, causing length-1 R vectors rendered JSON scalars. R doesn’t distinguish scalars vectors, API clients may respond differently encountering JSON array versus atomic value. may find API clients respond gracefully object expected vector becomes scalar one call. reason, Plumber inherits jsonlite::toJSON default setting auto_unbox=FALSE result length-1 vectors still rendered JSON arrays. can configure endpoint use unboxedJSON serializer (shown ) want alter behavior particular endpoint. couple functions aware around feature set. using boxed JSON serialization, jsonlite::unbox() can used force length-1 object R presented JSON scalar. using unboxed JSON serialization, () cause length-1 R object present JSON array.","code":"jsonlite::toJSON(list(a=5)) #> {\"a\":[5]} #* Get letters after a given letter #* @serializer json #* @get /boxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] }  #* Get letters after a given letter #* @serializer unboxedJSON #* @get /unboxed #* @query letter:string(\"A\") function(query) {   LETTERS[LETTERS > query$letter] } [   \"V\",   \"W\",   \"X\",   \"Y\",   \"Z\" ] [   \"Z\" ] \"Z\""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"graphics-serializers","dir":"Articles","previous_headings":"","what":"Graphics serializers","title":"Rendering Output","text":"Graphics serializers special need setup teardown around handler order capture graphics output. mixed standard serializers. omitted using ... unless graphics serializer selected explicitly case ... refer remaining graphics serializers omit standard ones. standard serializers behaviour can modified specifying additional arguments serializer. Many arguments well-known using graphics devices R including width, height, bg among others. Arguments inside curly braces evaluated environment handler R expression valid. However, evaluated , parsing file, possible provide dynamic serializer settings way. wish dynamically size images, need render capture graphical output return contents appropriate Content-Type header. See existing image renderers model .","code":"#* Example of customizing graphical output #* @serializer png{width = 400, height = 500} #* @get / function() {   plot(1:10) }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"bypassing-serialization","dir":"Articles","previous_headings":"","what":"Bypassing Serialization","title":"Rendering Output","text":"instances may desirable return value directly R without serialization. can settings @serializer none turn automatic serialization plumber. Consider following handler: response returned endpoint contain body Literal text ! Content-Type header without additional serialization. similar vein can set Content-Type otherwise leave body unchanged providing mime type @serializer. can use annotation want control response send. Running API visiting http://localhost:8080/pdf download PDF generated R (display PDF natively, client supports ).","code":"#* Endpoint that bypasses serialization #* @get / #* @serializer none function(response) {   response$body <- \"Literal text here!\" } #* @serializer application/pdf #* @get /pdf function() {   tmp <- tempfile()   pdf(tmp)   plot(1:10, type=\"b\")   text(4, 8, \"PDF from plumber!\")   text(6, 2, paste(\"The time is\", Sys.time()))   dev.off()    readBin(tmp, \"raw\", n=file.info(tmp)$size) }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"custom-serializers","dir":"Articles","previous_headings":"","what":"Custom serializers","title":"Rendering Output","text":"plumber2 comes serializers cover use cases may want provide . can two ways. Either registering serializer refering name native serializer, specifying inline. may want serve toml files plumber doesn’t (yet) ship serializer . quickly create using blogdown::write_toml(). Serializers plumber2 factory functions take range arguments return unary function capable formatting response body: use directly handler @serializer application/toml format_toml() register : use like serializer: @serializer toml","code":"format_toml <- function(...) {   function(x) {     blogdown::write_toml(x)   } } register_serializer(\"toml\", format_toml, \"application/toml\")"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"error-handling","dir":"Articles","previous_headings":"","what":"Error Handling","title":"Rendering Output","text":"Plumber wraps endpoint invocation can gracefully capture errors. run API interactive mode visit http://localhost:8080/simple, ’ll notice two things: HTTP response status code 500 (“internal server error”) sent client. response give clues nature error error printed console means possible intentionally use stop() handler way communicate problem user. However, since information stripped away response, may preferable provide bit detail user. reqres, provides set abort calls works like stop() also carry information status code message send client. Read reqres website. Visiting second handler can see action:","code":"#* Example of throwing an error #* @get /simple function() {   stop(\"I'm an error!\") }  #* Generate a friendly error #* @get /friendly function() {   abort_bad_request(     \"Your request could not be parsed\"   ) } {   \"type\": \"https://datatracker.ietf.org/doc/html/rfc9110#section-15.5.1\",   \"title\": \"Bad Request\",   \"status\": 400,   \"detail\": \"Your request could not be parsed\" }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"setting-cookies","dir":"Articles","previous_headings":"","what":"Setting Cookies","title":"Rendering Output","text":"part fulfilling request, Plumber API can choose set HTTP cookies client. HTTP APIs don’t implicitly contain notion “session.” Without additional information, Plumber way ascertaining whether two HTTP requests come associated user. Cookies offer way commission client store state behalf selected data can outlive single HTTP request; full implications using cookies track state API discussed . two forms Plumber cookies – plain-text encrypted – discussed following sections. make cookies important part API’s security model, sure understand section security considerations working cookies. Plumber can set receive plaint-text cookies. API endpoint return random letter, remembers preferences whether like capitalized lower-case letters. Since API using PUT request test API, ’ll use curl command line test . (’s nothing cookies necessitates PUT requests; just easily modify API use GET request.) can start visiting /letter endpoint ’ll see API defaults lower-case alphabet. curl http://localhost:8080/letter send PUT request specify capital parameter, cookie set client allow server accommodate preference future requests. curl, need specify file want save cookies using -c option. good reminder clients handle cookies differently – won’t support – sure clients intend support API play nicely cookies want use . send PUT request, setting parameter capital 1, invoke: curl -c cookies.txt -X PUT --data 'capital=1' \"http://localhost:8800/preferences\". print cookies.txt file, now see contains single cookie called capitalize value 1. can make another GET request /letter see accommodates preferences. ’ll need tell curl use cookies file just created sending request using -b switch: curl -b cookies.txt http://localhost:8080/letter. now see API returning random capitalized letter. set_cookie method accepts variety additional options customize cookie handled client. default, cookies set session lifetime, meaning cookie persist user’s browser client closes tab point cookie deleted. can customize setting expires max_age parameter set_cookie using either date number seconds future cookie expire. options can set cookie include path (path domain cookie installed client); http_only (controls whether cookie accessible JavaScript running domain – TRUE means cookie HTTP-, accessible JavaScript); secure (TRUE, instructs browser send cookie HTTPS, insecure HTTP. ’re using cookies infer security-sensitive properties (identify user, determine resources client access ), sure see Security article – particular section security implications cookies. addition storing plain-text cookies, Plumber also supports handling cookies encrypted. Encrypted cookies prevent users seeing stored inside also sign contents users can’t modify stored. use feature, must explicitly add router constructing . example, run following sequence commands create router supports encrypted session cookies. used api_session_cookie(), ’ll able use request$session response$session object (point data) read set data transmitted encrypted cookie named cookie_name. example, key used encrypt data \"my_secret_here\", work since 32-bit key required security reasons. can construct compliant key reqres::random_key store securely using keyring package. Unlike response$set_header(), values attached session data serialized via jsonlite; ’re free use complex data structures like lists session. However, deserializing done “blindly” using jsonlite::fromJSON() always verify type conversion done correctly storing ambiguous values (e.g. storing \"5\" (string) get deserialized 5 (number) next request). example, ’ll store encrypted cookie counts many times client visited particular endpoint: , need setup api using api_session_cookie() function code work. inspect cookie set browser, ’ll find value encrypted time gets client. time arrives Plumber, cookie available regular R list can read modified. session cookies great way store state without setting additional facilities server, aware session cookie transmitted request/response need encrypted decrypted every time (last part happens try read though). Using thus adds server load weigh pros cons managing session state .","code":"#* @put /preferences #* @body capital:integer* function(response, body) {   response$set_cookie(\"capitalize\", body$capital) }  #* @get /letter function(request) {   capitalize <- request$cookies$capitalize    # Default to lower-case unless user preference is capitalized   alphabet <- letters    # The capitalize cookie will initially be empty (NULL)   if (!is.null(capitalize) && capitalize == \"1\"){     alphabet <- LETTERS   }    list(     letter = sample(alphabet, 1)   ) } {   \"letter\": [     \"v\"   ] } api(\"myfile.R\") %>%   api_session_cookie(\"my_secret_here\", \"cookie_name\", ...) %>%   api_run() #* @get /sessionCounter function(request){   count <- 0   if (!is.null(request$session$counter)){     count <- as.numeric(request$session$counter)   }   request$session$counter <- count + 1   paste0(\"This is visit #\", count) }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"setting-unencrypted-cookies","dir":"Articles","previous_headings":"","what":"Setting Unencrypted Cookies","title":"Rendering Output","text":"Plumber can set receive plaint-text cookies. API endpoint return random letter, remembers preferences whether like capitalized lower-case letters. Since API using PUT request test API, ’ll use curl command line test . (’s nothing cookies necessitates PUT requests; just easily modify API use GET request.) can start visiting /letter endpoint ’ll see API defaults lower-case alphabet. curl http://localhost:8080/letter send PUT request specify capital parameter, cookie set client allow server accommodate preference future requests. curl, need specify file want save cookies using -c option. good reminder clients handle cookies differently – won’t support – sure clients intend support API play nicely cookies want use . send PUT request, setting parameter capital 1, invoke: curl -c cookies.txt -X PUT --data 'capital=1' \"http://localhost:8800/preferences\". print cookies.txt file, now see contains single cookie called capitalize value 1. can make another GET request /letter see accommodates preferences. ’ll need tell curl use cookies file just created sending request using -b switch: curl -b cookies.txt http://localhost:8080/letter. now see API returning random capitalized letter. set_cookie method accepts variety additional options customize cookie handled client. default, cookies set session lifetime, meaning cookie persist user’s browser client closes tab point cookie deleted. can customize setting expires max_age parameter set_cookie using either date number seconds future cookie expire. options can set cookie include path (path domain cookie installed client); http_only (controls whether cookie accessible JavaScript running domain – TRUE means cookie HTTP-, accessible JavaScript); secure (TRUE, instructs browser send cookie HTTPS, insecure HTTP. ’re using cookies infer security-sensitive properties (identify user, determine resources client access ), sure see Security article – particular section security implications cookies.","code":"#* @put /preferences #* @body capital:integer* function(response, body) {   response$set_cookie(\"capitalize\", body$capital) }  #* @get /letter function(request) {   capitalize <- request$cookies$capitalize    # Default to lower-case unless user preference is capitalized   alphabet <- letters    # The capitalize cookie will initially be empty (NULL)   if (!is.null(capitalize) && capitalize == \"1\"){     alphabet <- LETTERS   }    list(     letter = sample(alphabet, 1)   ) } {   \"letter\": [     \"v\"   ] }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"encrypted-cookies","dir":"Articles","previous_headings":"","what":"Setting Encrypted Cookies","title":"Rendering Output","text":"addition storing plain-text cookies, Plumber also supports handling cookies encrypted. Encrypted cookies prevent users seeing stored inside also sign contents users can’t modify stored. use feature, must explicitly add router constructing . example, run following sequence commands create router supports encrypted session cookies. used api_session_cookie(), ’ll able use request$session response$session object (point data) read set data transmitted encrypted cookie named cookie_name. example, key used encrypt data \"my_secret_here\", work since 32-bit key required security reasons. can construct compliant key reqres::random_key store securely using keyring package. Unlike response$set_header(), values attached session data serialized via jsonlite; ’re free use complex data structures like lists session. However, deserializing done “blindly” using jsonlite::fromJSON() always verify type conversion done correctly storing ambiguous values (e.g. storing \"5\" (string) get deserialized 5 (number) next request). example, ’ll store encrypted cookie counts many times client visited particular endpoint: , need setup api using api_session_cookie() function code work. inspect cookie set browser, ’ll find value encrypted time gets client. time arrives Plumber, cookie available regular R list can read modified. session cookies great way store state without setting additional facilities server, aware session cookie transmitted request/response need encrypted decrypted every time (last part happens try read though). Using thus adds server load weigh pros cons managing session state .","code":"api(\"myfile.R\") %>%   api_session_cookie(\"my_secret_here\", \"cookie_name\", ...) %>%   api_run() #* @get /sessionCounter function(request){   count <- 0   if (!is.null(request$session$counter)){     count <- as.numeric(request$session$counter)   }   request$session$counter <- count + 1   paste0(\"This is visit #\", count) }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/rendering-output.html","id":"documenting-responses","dir":"Articles","previous_headings":"","what":"Documenting responses","title":"Rendering Output","text":"TBD","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"endpoints","dir":"Articles","previous_headings":"","what":"Handlers","title":"Routing & Input","text":"Handlers standard R functions gets executed request received matches ’s path (assuming specific handler present route). create endpoint annotating function like : annotation specifies function responsible generating response GET request /hello. value returned function used response request (run serializer e.g. convert response JSON). case, GET response /hello return content [\"hello world\"] application/json Content-Type (unless request include preference another return format). annotations generate endpoint include: @get @post @put @delete @head map HTTP methods API client might send along request. default open page web browser, sends GET request API. can use API clients (even JavaScript inside web browser) form HTTP requests using methods listed . conventions around methods used can read . Note conventions carry security implications, ’s good idea follow recommended uses method fully understand might deviate . Note single endpoint can support multiple verbs. following function used service incoming GET, POST, PUT request /cars. also special method @make handler respond method matches path. can useful e.g. authentication handler needs called every request comes .","code":"#* Return \"hello world\" #* @get /hello function() {   \"hello world\" } #* @get /cars #* @post /cars #* @put /cars function(){   ... }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"handler-methods","dir":"Articles","previous_headings":"","what":"Handler methods","title":"Routing & Input","text":"annotations generate endpoint include: @get @post @put @delete @head map HTTP methods API client might send along request. default open page web browser, sends GET request API. can use API clients (even JavaScript inside web browser) form HTTP requests using methods listed . conventions around methods used can read . Note conventions carry security implications, ’s good idea follow recommended uses method fully understand might deviate . Note single endpoint can support multiple verbs. following function used service incoming GET, POST, PUT request /cars. also special method @make handler respond method matches path. can useful e.g. authentication handler needs called every request comes .","code":"#* @get /cars #* @post /cars #* @put /cars function(){   ... }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"paths","dir":"Articles","previous_headings":"","what":"Paths","title":"Routing & Input","text":"heart routing path handler gets assigned . Apart static paths /cars saw selected exact match, possible create dynamic paths responds set paths sharing common structure. Dynamic paths allow handlers define flexible set paths match. common REST convention include identifier object API paths associated . lookup information user #13, might make GET request path /users/13. Rather register handlers every user API might possibly encounter, can use dynamic path associate handler variety paths. API uses dynamic path /users/<id> match request form /users/ followed path element like number letters. case, return information user user associated ID found, empty object . can name dynamic path elements however ’d like, note name used dynamic path must match name argument handler (case, id). can even complex dynamic routes like: Often path parameters need allow provide dynamic structured path extract parameters input. However, plumber2 also support path wildcards can match anything pass . Conceptually works like * file globbing .* regular expressions. example , handler match /images/index.html, /images/february/img_03.png, /images/metadata/ path starts /images/. Wildcards needs , ie. can’t path like /imag* match anything starts /imag (like /images/ /imaginary). However, need end, path like /*/robot.txt matches path ends robot.txt. fact “unspecific” well doesn’t give rise argument input handler means wildcards used much less frequently can indispensable tool belt situations. discussed , every route select one handler request. However, existence path parameters path wildcards means route can easily contain multiple handlers can match given request. route decide one wins? Internally route order handlers based three metrics: specificity (ie. number elements path) - higher better, number path parameters - lower better, number wildcards - lower better. Consider following paths /path//something/specific /path//<name>/specific /path//<name>/<setting> /path//something/* /path/* ordered route order , highest priority top. means request /path//something/specific get matched first path, even though matches given paths. /path//anything/specific get matched second path even though matches second, third fifth, . may seem complicated figure handler gets request, priority ordering designed way generally matches ’d rank specificity set paths.","code":"users <- data.frame(   uid = c(12, 13),   username = c(\"kim\", \"john\") )  #* Lookup a user #* @get /users/<id> function(id) {   subset(users, uid %in% id) } #* @get /user/<from>/connect/<to> function(from, to){   # Do something with the `from` and `to` variables... } #* @get /images/* function() {   # do something }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"path-parameters","dir":"Articles","previous_headings":"","what":"Path parameters","title":"Routing & Input","text":"common REST convention include identifier object API paths associated . lookup information user #13, might make GET request path /users/13. Rather register handlers every user API might possibly encounter, can use dynamic path associate handler variety paths. API uses dynamic path /users/<id> match request form /users/ followed path element like number letters. case, return information user user associated ID found, empty object . can name dynamic path elements however ’d like, note name used dynamic path must match name argument handler (case, id). can even complex dynamic routes like:","code":"users <- data.frame(   uid = c(12, 13),   username = c(\"kim\", \"john\") )  #* Lookup a user #* @get /users/<id> function(id) {   subset(users, uid %in% id) } #* @get /user/<from>/connect/<to> function(from, to){   # Do something with the `from` and `to` variables... }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"path-wildcard","dir":"Articles","previous_headings":"","what":"Path wildcard","title":"Routing & Input","text":"Often path parameters need allow provide dynamic structured path extract parameters input. However, plumber2 also support path wildcards can match anything pass . Conceptually works like * file globbing .* regular expressions. example , handler match /images/index.html, /images/february/img_03.png, /images/metadata/ path starts /images/. Wildcards needs , ie. can’t path like /imag* match anything starts /imag (like /images/ /imaginary). However, need end, path like /*/robot.txt matches path ends robot.txt. fact “unspecific” well doesn’t give rise argument input handler means wildcards used much less frequently can indispensable tool belt situations.","code":"#* @get /images/* function() {   # do something }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"path-priority","dir":"Articles","previous_headings":"","what":"Path priority","title":"Routing & Input","text":"discussed , every route select one handler request. However, existence path parameters path wildcards means route can easily contain multiple handlers can match given request. route decide one wins? Internally route order handlers based three metrics: specificity (ie. number elements path) - higher better, number path parameters - lower better, number wildcards - lower better. Consider following paths /path//something/specific /path//<name>/specific /path//<name>/<setting> /path//something/* /path/* ordered route order , highest priority top. means request /path//something/specific get matched first path, even though matches given paths. /path//anything/specific get matched second path even though matches second, third fifth, . may seem complicated figure handler gets request, priority ordering designed way generally matches ’d rank specificity set paths.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"input-handling","dir":"Articles","previous_headings":"","what":"Handler input","title":"Routing & Input","text":"Plumber routes requests based exclusively path method incoming HTTP request, requests can contain much information just . might include additional HTTP headers, query string, request body. fields may viewed “inputs” Plumber API. general think inputs function R think arguments function. plumber2 certain rules around arguments handler function determines kind input handler gets access . importantly perhaps, path parameters provided directly handler named arguments. example, given following handler request /user/123/setting/security call handler function user = \"123\" type = \"security\". Path arguments documented @param tag may also know roxygen documentation. Path parameters type variable handler arguments. predefined can included leisure handler needs access . following ’ll get overview : query string may appended URL order convey additional information beyond just request route. Query strings allow encoding character string keys values. example, URL https://duckduckgo.com/?q=bread&pretty=1, everything following ? constitutes query string. case, two variables (q pretty) set (bread 1, respectively). Plumber automatically parse query string make available query argument handler function. following example defines search API mimics example DuckDuckGo merely prints receives. Visiting http://localhost:8080/?q=bread&pretty=1 print: handler use %||% provide fallback value case query parameter weren’t provided. Later ’ll learn provide default values mark parameters required. Since query string “open” sense user can send anything along query value can contain multitude values handler isn’t expecting. values may meant handlers routes may included error. open nature good practice document query parameters handler understand. done @query tag works much like @param. API may need array-like input query string. plumber2 understands two forms providing array data: Either providing parameter multiple times, e.g. ?arg=1&arg=2&arg=3, separating values comma, e.g. ?arg=1,2,3. latter approach condensed become quite unwieldy large amount data. top web browsers impose limitations length URL. Internet Explorer, particular, caps query string 2,048 characters. , larger amount data better served request body. Another way provide additional information inside HTTP request using message body. Effectively, client specifies metadata request (path ’s trying reach, HTTP headers, etc.) can provide message body. maximum size request body depends largely technologies involved (client, proxies, etc.) typically least 2MB – much larger query string. approach commonly seen PUT, POST, PATCH requests, though encounter HTTP methods. Plumber attempt parse request body using best matching parser provided handler one @parser tags. parsers provided plumber2 try registered parsers. result parsing made available body argument. can document expectations around request body using @body tag works much like @param @query. Plumber2 comes selection parsers common data transfer formats: can also provide parsers register can reference name. two special names can use: none .... setting @parser none parsing request body attempted. can still done manually request later stage. may seem like good idea set @parser none intend use request body handler order speed processing, necessary since body parsed code tries access . Setting @parser ... selects parsers yet referenced handler block. can useful registered alternative parser specific mime type wish move top list selected one provided plumber. example : give handler access parsers registered plumber2 select artisinal_json_parser json content type application/json. register new parsers using register_parser(), can also provide directly block annotation like : However, probably better registering parser rather redefine every time need Unfortunately, crafting request message body requires bit work making GET request query string web browser, can use tools like curl command line httr2 R package. ’ll use curl examples . Running curl --data \"id=123&name=Jennifer\" -H \"Content-Type: application/x-www-form-urlencoded\" \"http://localhost:8080/user\" return: Alternatively, echo {\"id\":123, \"name\": \"Jennifer\"} > call.json & curl --data @call.json \"http://localhost:8080/user\" -H \"content-type: application/json\" (formatting body JSON) effect. request argument contains request object. plumber2 object provided reqres package thedocumentation gives great overview information contains. special interest headers, cookies, session field gives access additional input otherwise available handler arguments. cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session. HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name. Like request argument, response argument holds object encapsulates response constructed. also provided reqres extensive documentation . See article rendering output various way may want interact response. server argument handler populated Plumber API object. can use logging, accessing server data store, etc. See documentation fiery webpage get overview possible Plumber automatically tries keep track clients tries access ’s API. setting cookie first time request comes new client giving unique id. id passed handlers client_id argument.","code":"#* @get /user/<id>/setting/<type> function(user, type) {   # ... } #* @get / function(query) {   paste0(\"The q parameter is '\", query$q %||% \"\", \"'. \",          \"The pretty parameter is '\", query$pretty %||% 0, \"'.\") } [   \"The q parameter is 'bread'. The pretty parameter is '1'.\" ] #* @parser artisinal_json_parser #* @parser ... #* @parser application/toml function(x, ...) blogdown::read_toml(x = rawToChar(x)) #* @post /user function(body) {   list(     id = body$id,     name = body$name   ) } {   \"id\": [     \"123\"   ],   \"name\": [     \"Jennifer\\n\"   ] } #* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"handler-arguments","dir":"Articles","previous_headings":"","what":"Handler arguments","title":"Routing & Input","text":"general think inputs function R think arguments function. plumber2 certain rules around arguments handler function determines kind input handler gets access . importantly perhaps, path parameters provided directly handler named arguments. example, given following handler request /user/123/setting/security call handler function user = \"123\" type = \"security\". Path arguments documented @param tag may also know roxygen documentation. Path parameters type variable handler arguments. predefined can included leisure handler needs access . following ’ll get overview : query string may appended URL order convey additional information beyond just request route. Query strings allow encoding character string keys values. example, URL https://duckduckgo.com/?q=bread&pretty=1, everything following ? constitutes query string. case, two variables (q pretty) set (bread 1, respectively). Plumber automatically parse query string make available query argument handler function. following example defines search API mimics example DuckDuckGo merely prints receives. Visiting http://localhost:8080/?q=bread&pretty=1 print: handler use %||% provide fallback value case query parameter weren’t provided. Later ’ll learn provide default values mark parameters required. Since query string “open” sense user can send anything along query value can contain multitude values handler isn’t expecting. values may meant handlers routes may included error. open nature good practice document query parameters handler understand. done @query tag works much like @param. API may need array-like input query string. plumber2 understands two forms providing array data: Either providing parameter multiple times, e.g. ?arg=1&arg=2&arg=3, separating values comma, e.g. ?arg=1,2,3. latter approach condensed become quite unwieldy large amount data. top web browsers impose limitations length URL. Internet Explorer, particular, caps query string 2,048 characters. , larger amount data better served request body. Another way provide additional information inside HTTP request using message body. Effectively, client specifies metadata request (path ’s trying reach, HTTP headers, etc.) can provide message body. maximum size request body depends largely technologies involved (client, proxies, etc.) typically least 2MB – much larger query string. approach commonly seen PUT, POST, PATCH requests, though encounter HTTP methods. Plumber attempt parse request body using best matching parser provided handler one @parser tags. parsers provided plumber2 try registered parsers. result parsing made available body argument. can document expectations around request body using @body tag works much like @param @query. Plumber2 comes selection parsers common data transfer formats: can also provide parsers register can reference name. two special names can use: none .... setting @parser none parsing request body attempted. can still done manually request later stage. may seem like good idea set @parser none intend use request body handler order speed processing, necessary since body parsed code tries access . Setting @parser ... selects parsers yet referenced handler block. can useful registered alternative parser specific mime type wish move top list selected one provided plumber. example : give handler access parsers registered plumber2 select artisinal_json_parser json content type application/json. register new parsers using register_parser(), can also provide directly block annotation like : However, probably better registering parser rather redefine every time need Unfortunately, crafting request message body requires bit work making GET request query string web browser, can use tools like curl command line httr2 R package. ’ll use curl examples . Running curl --data \"id=123&name=Jennifer\" -H \"Content-Type: application/x-www-form-urlencoded\" \"http://localhost:8080/user\" return: Alternatively, echo {\"id\":123, \"name\": \"Jennifer\"} > call.json & curl --data @call.json \"http://localhost:8080/user\" -H \"content-type: application/json\" (formatting body JSON) effect. request argument contains request object. plumber2 object provided reqres package thedocumentation gives great overview information contains. special interest headers, cookies, session field gives access additional input otherwise available handler arguments. cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session. HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name. Like request argument, response argument holds object encapsulates response constructed. also provided reqres extensive documentation . See article rendering output various way may want interact response. server argument handler populated Plumber API object. can use logging, accessing server data store, etc. See documentation fiery webpage get overview possible Plumber automatically tries keep track clients tries access ’s API. setting cookie first time request comes new client giving unique id. id passed handlers client_id argument.","code":"#* @get /user/<id>/setting/<type> function(user, type) {   # ... } #* @get / function(query) {   paste0(\"The q parameter is '\", query$q %||% \"\", \"'. \",          \"The pretty parameter is '\", query$pretty %||% 0, \"'.\") } [   \"The q parameter is 'bread'. The pretty parameter is '1'.\" ] #* @parser artisinal_json_parser #* @parser ... #* @parser application/toml function(x, ...) blogdown::read_toml(x = rawToChar(x)) #* @post /user function(body) {   list(     id = body$id,     name = body$name   ) } {   \"id\": [     \"123\"   ],   \"name\": [     \"Jennifer\\n\"   ] } #* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"query","dir":"Articles","previous_headings":"","what":"query","title":"Routing & Input","text":"query string may appended URL order convey additional information beyond just request route. Query strings allow encoding character string keys values. example, URL https://duckduckgo.com/?q=bread&pretty=1, everything following ? constitutes query string. case, two variables (q pretty) set (bread 1, respectively). Plumber automatically parse query string make available query argument handler function. following example defines search API mimics example DuckDuckGo merely prints receives. Visiting http://localhost:8080/?q=bread&pretty=1 print: handler use %||% provide fallback value case query parameter weren’t provided. Later ’ll learn provide default values mark parameters required. Since query string “open” sense user can send anything along query value can contain multitude values handler isn’t expecting. values may meant handlers routes may included error. open nature good practice document query parameters handler understand. done @query tag works much like @param. API may need array-like input query string. plumber2 understands two forms providing array data: Either providing parameter multiple times, e.g. ?arg=1&arg=2&arg=3, separating values comma, e.g. ?arg=1,2,3. latter approach condensed become quite unwieldy large amount data. top web browsers impose limitations length URL. Internet Explorer, particular, caps query string 2,048 characters. , larger amount data better served request body.","code":"#* @get / function(query) {   paste0(\"The q parameter is '\", query$q %||% \"\", \"'. \",          \"The pretty parameter is '\", query$pretty %||% 0, \"'.\") } [   \"The q parameter is 'bread'. The pretty parameter is '1'.\" ]"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"body","dir":"Articles","previous_headings":"","what":"body","title":"Routing & Input","text":"Another way provide additional information inside HTTP request using message body. Effectively, client specifies metadata request (path ’s trying reach, HTTP headers, etc.) can provide message body. maximum size request body depends largely technologies involved (client, proxies, etc.) typically least 2MB – much larger query string. approach commonly seen PUT, POST, PATCH requests, though encounter HTTP methods. Plumber attempt parse request body using best matching parser provided handler one @parser tags. parsers provided plumber2 try registered parsers. result parsing made available body argument. can document expectations around request body using @body tag works much like @param @query. Plumber2 comes selection parsers common data transfer formats: can also provide parsers register can reference name. two special names can use: none .... setting @parser none parsing request body attempted. can still done manually request later stage. may seem like good idea set @parser none intend use request body handler order speed processing, necessary since body parsed code tries access . Setting @parser ... selects parsers yet referenced handler block. can useful registered alternative parser specific mime type wish move top list selected one provided plumber. example : give handler access parsers registered plumber2 select artisinal_json_parser json content type application/json. register new parsers using register_parser(), can also provide directly block annotation like : However, probably better registering parser rather redefine every time need Unfortunately, crafting request message body requires bit work making GET request query string web browser, can use tools like curl command line httr2 R package. ’ll use curl examples . Running curl --data \"id=123&name=Jennifer\" -H \"Content-Type: application/x-www-form-urlencoded\" \"http://localhost:8080/user\" return: Alternatively, echo {\"id\":123, \"name\": \"Jennifer\"} > call.json & curl --data @call.json \"http://localhost:8080/user\" -H \"content-type: application/json\" (formatting body JSON) effect.","code":"#* @parser artisinal_json_parser #* @parser ... #* @parser application/toml function(x, ...) blogdown::read_toml(x = rawToChar(x)) #* @post /user function(body) {   list(     id = body$id,     name = body$name   ) } {   \"id\": [     \"123\"   ],   \"name\": [     \"Jennifer\\n\"   ] }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"request","dir":"Articles","previous_headings":"","what":"request","title":"Routing & Input","text":"request argument contains request object. plumber2 object provided reqres package thedocumentation gives great overview information contains. special interest headers, cookies, session field gives access additional input otherwise available handler arguments. cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session. HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name.","code":"#* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"read-cookies","dir":"Articles","previous_headings":"","what":"Cookies","title":"Routing & Input","text":"cookies attached incoming request, ’ll made available via request$cookies. contain list cookies included request. names list correspond names cookies value element character string URL-decoded. See Setting Cookies section details set cookies Plumber. ’ve set encrypted cookies (discussed Encrypted Cookies section), session decrypted made available request$session.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"headers","dir":"Articles","previous_headings":"","what":"Headers","title":"Routing & Input","text":"HTTP headers attached incoming request available request object. can either access get_header() method headers field request object Running curl --header \"Custom-Header: abc123\" http://localhost:8080 return: slight difference get_header() headers aware . R fond - symbols, names list provided headers - substituted _. get_header() can use real header name.","code":"#* Return the value of a custom header and the total number of headers #* @get / function(request) {   list(     val = request$get_header(\"Custom-Header\"),     n_headers = length(request$headers)   ) } {   \"val\": [     \"abc123\"   ],   \"n_headers\": [     2   ] }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"response","dir":"Articles","previous_headings":"","what":"response","title":"Routing & Input","text":"Like request argument, response argument holds object encapsulates response constructed. also provided reqres extensive documentation . See article rendering output various way may want interact response.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"server","dir":"Articles","previous_headings":"","what":"server","title":"Routing & Input","text":"server argument handler populated Plumber API object. can use logging, accessing server data store, etc. See documentation fiery webpage get overview possible","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"client_id","dir":"Articles","previous_headings":"","what":"client_id","title":"Routing & Input","text":"Plumber automatically tries keep track clients tries access ’s API. setting cookie first time request comes new client giving unique id. id passed handlers client_id argument.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"typed-dynamic-routes","dir":"Articles","previous_headings":"","what":"Type casting input","title":"Routing & Input","text":"Path query paramters comes text string, provided string handler. However, can provide type hints plumber automatically cast expected type providing handler. Consider following API. Visiting http://localhost:8080/type/14 return: intend support particular data type particular parameter dynamic route, can specify desired type path , @param field. syntax : Anything following first : name parameter. Anything following type specification. following details mapping scalar type names can use dynamic types map R data types. can also specify array, enclosing [...], (e.g. [integer] array integers). Arrays can even nested (e.g. [[integer]] array arrays integers). Lastly, possible specify “object”, cast lists R. syntax {name:Type, ...} allows provide concise specifications complex data structures (e.g. specification iris dataset {Sepal.Length:number,Sepal.Width:number,Petal.Length:number,Petal.Width:number,Species:string}. unlikely ’ll need objects path query parameters, request bodies often form object. R used providing default values function arguments. plumber can adding default value parenthesis type specification, e.g. integer(10). type caster automatically ensure value inserted missing query body request can assume always present code. Path parameters always required. , can’t arrive handler path parameter missing. query body parameters assumed optional, can mark required well adding * type, like [number]*. required parameter missing type converter automatically throw error return 400 client. aware required parameter default value logical fallacy.","code":"#* @get /type/<id> function(id) {   list(     id = id,     type = typeof(id)   ) } {   \"id\": [     \"14\"   ],   \"type\": [     \"character\"   ] } #* @get /user/<id:integer> function(id){   next <- id + 1   # ... }  #* @post /user/activated/<active> #* @param active:boolean Whether the user is active function(active){   if (!active){     # ...   } }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"defaults","dir":"Articles","previous_headings":"","what":"Defaults","title":"Routing & Input","text":"R used providing default values function arguments. plumber can adding default value parenthesis type specification, e.g. integer(10). type caster automatically ensure value inserted missing query body request can assume always present code.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"required-parameters","dir":"Articles","previous_headings":"","what":"Required parameters","title":"Routing & Input","text":"Path parameters always required. , can’t arrive handler path parameter missing. query body parameters assumed optional, can mark required well adding * type, like [number]*. required parameter missing type converter automatically throw error return 400 client. aware required parameter default value logical fallacy.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/routing-and-input.html","id":"static-file-handler","dir":"Articles","previous_headings":"","what":"Static File Handler","title":"Routing & Input","text":"Plumber includes static file server can used host directories static assets JavaScript, CSS, HTML files. servers fairly simple configure integrate plumber application. example expose local directory ./files/static root / path server. file ./files/static/branding.html, available Plumber server /branding.html. can optionally provide additional argument configure path used server. instance expose local directory files/static /, /static.","code":"#* @assets ./files/static NULL #* @assets ./files/static /static NULL"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/security.html","id":"networking","dir":"Articles","previous_headings":"","what":"Networking & Firewalls","title":"Security","text":"networking standpoint, two fundamentally different approaches developing R code. can develop locally using tool like RStudio Desktop. case, R session (Plumber APIs run()) housed local machine. can develop remote machine using tool like RStudio Server. , R session running remote server accessed across network. first case, ’s typically little consider networking perspective. APIs accessible http://127.0.0.1:8080 default (localhost synonymous local IP address 127.0.0.1) likely won’t need concern firewalls network proxies. second case, however, may need consider network environment server running API. considerations ’ll need make hosting API server production use. particular, investigate whether firewalls server hosting Plumber API clients want able connect. Firewalls way block undesired network traffic. desktop computers many servers come firewalls enabled ---box. means want expose API running port 8080, need configure firewall accept incoming connections port. Firewalls can also configured network intermediaries, may need configure multiple firewalls allow traffic order expose desired port API clients.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/security.html","id":"https","dir":"Articles","previous_headings":"","what":"HTTPS","title":"Security","text":"HTTPS secure form HTTP. Many people now aware check browser displays padlock associated HTTPS enter sensitive information like credit card number. HTTPS important consider developing Plumber APIs, well. HTTPS primarily offers two protections: encrypts information sent API client Plumber process using TLS (often still referred predecessor, “SSL”). prevents others network able read information sent back forth. gives API client confidence ’s communicating Plumber process, opposed imposter. two assurances critical API handling sensitive data performing actions intended authenticated users. hosting options support serving HTTP HTTPS simultaneously. secure configuration redirect incoming HTTP traffic HTTPS hosting option. added layer protection, can consider enabling HTTP Strict Transport Security (HSTS). HSTS way instruct clients – future – refuse connect server unsecure HTTP. ensures imposter server able trick client connecting insecure HTTP future. Unfortunately, Plumber implement HTTPS support natively, documented hosting options offer ways deploy HTTPS HSTS front Plumber API.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/security.html","id":"dos","dir":"Articles","previous_headings":"","what":"Denial Of Service (DoS)","title":"Security","text":"Denial service (DoS) attacks employed order temporarily shut server service overwhelming traffic. DoS scenario caused single ignorant user unintentionally making request ask server impossible task, intentionally introduced malicious actor leveraging vast number machines repeatedly make requests expensive server respond . later form often called distributed denial service attack (DDoS) typically requires special infrastructure network capacity beyond scope ’ll discuss . However, practices employ designing Plumber API put safety guards around work API request might instigate. expected output harmless plot.  plot takes negligible amount time create. However, plots points take time create.  plot, 10,000 points added, took 0.197 seconds generate. doesn’t sound like much, exposed API publicly Internet, attacker easily generate enough traffic endpoint overwhelm Plumber process. Even worse, attacker make request endpoint millions billions points might cause server run memory consume much CPU deprives important system resources. Either case result Plumber process crashing altogether. solution, case, ensure reasonable safety guards place user input. can see allow user request graph 1,000 points. requests exceeding limit immediately terminated without computation. attentive resources consumed filters endpoints. Consider various values user provide API endpoint’s parameters ensure behavior system reasonable cases. API endpoints require extensive computation, consider protect endpoints (perhaps exposing authenticated users) prevent malicious user abusing system.","code":"#* This is an example of an UNSAFE endpoint which #* is vulnerable to a DOS attack. #* @get / #* @query pts:integer(10) #* @serializer png function(query) {   # An example of an UNSAFE endpoint.   plot(1:query$pts) } #* This is an example of an safe endpoint which #* checks user input to avoid a DOS attack #* @get / #* @query pts:integer(10) #* @serializer png function(query) {   if (query$pts > 1000 & query$pts < 1){     abort_bad_request(\"pts must be between 1 and 1,000\")   }   plot(1:pts) }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/security.html","id":"sanitization","dir":"Articles","previous_headings":"","what":"Sanitization & Injection","title":"Security","text":"time accept input user code, plan worst-case scenario. , example, API endpoint allows user specify name file read particular directory returns contents, might naively implement like . Unfortunately, API endpoint properly sanitize user input. user set file parameter ../plumber.R now endpoint return source code Plumber API. course just easy attempt read files might contain API keys sensitive data. One solution case strip special characters user input prevent users able escape different directory. File paths opportunity malicious input damage system, however. Another way user input can dangerous attack known “cross site scripting,” “XSS.” attack can leveraged whenever user input may rendered user’s browser. instance endpoint allows users comment page later displays comments users, attacked craft comment : can see, comment JavaScript embedded within , case used popup message user. course JavaScript used harmful way redirecting users malicious site, instance, uploading data special access server destination. user input might included HTML page properly escaped (see htmltools::html_escape help). Lastly, user input can used “injection attack,” user injects malicious commands might sent another system. best known family SQL injection attacks, user input meant included SQL query executed database might contain additional SQL commands leak data damage database. details SQL injection attacks mitigation strategies R available . summary, sure separate “trusted” “untrusted” objects API implementation. Anything user provides considered “untrusted” escaped sanitized. point can consider object “trusted” proceed take actions .","code":"#* This is an example of an UNSAFE endpoint which #* does not sanitize user input #* @get / #* @query file:string* function(query) {    # An example of an UNSAFE endpoint.   path <- file.path(\"./datasets\", query$file)   readLines(path) } #* This is an example of an endpoint which #* checks user input. #* @get / #* @query file:string* function(query) {   # Strip all \"non-word\" characters from user input   sanitizedFile <- gsub(\"\\\\W\", \"\", query$file)    path <- file.path(\"./datasets\", sanitizedFile)   readLines(path) } \"This is a comment with JavaScript! <script>alert('I could do something bad here!');<\/script>"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/security.html","id":"cross-origin-resource-sharing-cors","dir":"Articles","previous_headings":"","what":"Cross-Origin Resource Sharing (CORS)","title":"Security","text":"TBD","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/security.html","id":"security-cookies","dir":"Articles","previous_headings":"","what":"Cookies","title":"Security","text":"section setting cookies, discussed mechanics setting cookies. However, intend use cookies security-sensitive purpose, aware ways cookies can exploited. First foremost, recognize client ability modify fabricate cookies send API. storing preferences user provided cookie concern. Storing something security implications – like identity user making requests – however, ; malicious user just need modify user ID saved cookie order trick API thinking someone ’re . two common workarounds concern. can store session information server identified long, cryptographically random IDs rely cookie store ID (Plumber provides ID client_id argument handler). can use signed/encrypted cookies, detailed section setting encrypted cookies. also aware cookies handled managed clients. can manage properties providing different parameters set_cookie() method response. expires - cookie expire. provide POSIXt object gives time explicitly. value provided (max_age set), cookie session cookie, meaning persist user closes tab/browser. Remember, however, client may accidentally maliciously retain cookie beyond assigned expiration time. security standpoint, rely client well-behaved delete cookie assigned time. max_age - alternative strategy defining life-time cookie. sets number seconds cookie kept active, instead setting termination date/time. concerns expires apply setting. http_only - HttpOnly property cookie determines whether cookie accessible JavaScript running domain. using cookie persist user settings host JavaScript may also leverage preferences stored cookie, want http parameter FALSE, indicating cookie HttpOnly, available JavaScript. storing session ID cookie interpretable server, set http TRUE. variety attacks (“cross-site scripting”) enable attacker run malicious JavaScript clients’ machines, ’s wise limit amount information accessible JavaScript. plumber2, session data cookie client id cookie http-. secure - TRUE, instructs clients send cookie connecting server HTTPS. HTTPS mechanism clients can gain assurance server ’re connected indeed server intended communicating . API uses HTTPS, using secure cookies protects use case attacker tricks one clients connecting HTTP server impersonating API. scenario, client may send cookies malicious server, point attacker use cookies server impersonate actual user. Note shouldn’t enable API stably running HTTPS. Additionally, bear mind attacker gets physical access client valid cookie, attacker copy cookie different machine begin using . Unfortunately, can’t perfectly protect attacks, can minimize impact 1.) using shorter session lifetimes (perhaps hours instead days), 2.) invalidating sessions period user inactivity, 3.) rotating session ID periodically; way ’d able detect multiple clients trying use session take action. can also consider adding additional layer security around security-sensitive endpoints (like changing user’s password). Lastly, using encrypted cookies store sensitive information, remember expiring cookie instruction ’re sending client may may honored. Thus set encrypted cookie client authenticate user user wishes log , can instruct client delete cookie. cookie stolen misbehaving client doesn’t delete cookie, ’s possible cookie still used continue making authenticated requests API.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/tips-and-tricks.html","id":"debugging","dir":"Articles","previous_headings":"","what":"Debugging","title":"Tips & Tricks","text":"’ve historically used R interactively, may find difficult define functions get executed without input Plumber requires. couple debugging techniques aware working Plumber APIs; techniques equally transferable debugging R scripts, packages, reports. programmers first approach debugging adding print statements code order inspect state point. R, print() cat() can used print state. instance, cat(\"currently: \", ) inserted code help ensure variable point code. approach equally viable Plumber. However, plumber comes dedicated logging infrastructure can leveraged well. handler can use server$log() log messages specific events. use logger backend like logger, can set log level allowing filter messages shown. Using warning() message() automatically ends log well also valid logging calls. Similar print debugging, can output plumber knows various stages processing pipeline using event handlers. e.g. add logging calls -request -request logs comes send . example, can add lines route file: execute GET request /stage_debug expect see output like: output shows route /stage_debug calculated value 42 value serialized using json. expect see received response status 200 body containing JSON matching [42]. Print debugging obvious starting point, developers eventually wish something powerful. R, capacity built browser() function. ’re unfamiliar, browser() pauses execution function gives interactive session can inspect current value internal variables even proceed function one statement time. can leverage browser() developing APIs locally adding browser() call one handlers. offers powerful technique use want inspect multiple different variables interact current state things inside function. also good way get hands dirty Plumber get better acquainted things behave low level. Consider following API endpoint: run API locally visit API web browser, ’ll see R session switch debug mode request arrives, allowing look objects contained inside req res objects. usually works, R session can become confused entering debugging mode running server. often better mock request. can create mocked request object using fiery::fake_request() can populate path, method, headers, body content. can take object send API using test_request() method Plumber API object: aware req res objects familiar handlers, rather formats plumber needs use interact httpuv.","code":"#* @plumber function(api) {   api |>     api_on(\"before-request\", function(request, ...) {       cli::cli_inform(request$as_message())     }) |>     api_on(\"after-request\", function(response, ...) {       cli::cli_inform(response$as_message())     }) } #* @get /stage_debug function() {   return(42) } GET /stage_debug HTTP/1.1 Host: localhost:8080 Cookie: fiery_id=e6a4290e84ddd3eb5c429275b24423c87fb8c9ffaee230008a1ae8863cb72760  <No Body>  HTTP/1.1 200 OK Vary: Accept Date: Fri, 21 Mar 2025 08:48:09 GMT Content-Length: 4 Content-Type: application/json  [42] #* @get / function(request, response){   browser()    list(a=123) } papi <- api(\"plumber.R\")  req <- fiery::fake_request(\"http://localhost:8080/path/to/handler\")  res <- papi$test_request(req)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/tips-and-tricks.html","id":"print-debugging","dir":"Articles","previous_headings":"","what":"Print Debugging","title":"Tips & Tricks","text":"programmers first approach debugging adding print statements code order inspect state point. R, print() cat() can used print state. instance, cat(\"currently: \", ) inserted code help ensure variable point code. approach equally viable Plumber. However, plumber comes dedicated logging infrastructure can leveraged well. handler can use server$log() log messages specific events. use logger backend like logger, can set log level allowing filter messages shown. Using warning() message() automatically ends log well also valid logging calls.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/tips-and-tricks.html","id":"router-stage-debugging","dir":"Articles","previous_headings":"","what":"Router Stage Debugging","title":"Tips & Tricks","text":"Similar print debugging, can output plumber knows various stages processing pipeline using event handlers. e.g. add logging calls -request -request logs comes send . example, can add lines route file: execute GET request /stage_debug expect see output like: output shows route /stage_debug calculated value 42 value serialized using json. expect see received response status 200 body containing JSON matching [42].","code":"#* @plumber function(api) {   api |>     api_on(\"before-request\", function(request, ...) {       cli::cli_inform(request$as_message())     }) |>     api_on(\"after-request\", function(response, ...) {       cli::cli_inform(response$as_message())     }) } #* @get /stage_debug function() {   return(42) } GET /stage_debug HTTP/1.1 Host: localhost:8080 Cookie: fiery_id=e6a4290e84ddd3eb5c429275b24423c87fb8c9ffaee230008a1ae8863cb72760  <No Body>  HTTP/1.1 200 OK Vary: Accept Date: Fri, 21 Mar 2025 08:48:09 GMT Content-Length: 4 Content-Type: application/json  [42]"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/tips-and-tricks.html","id":"interactive-debugging","dir":"Articles","previous_headings":"","what":"Interactive Debugging","title":"Tips & Tricks","text":"Print debugging obvious starting point, developers eventually wish something powerful. R, capacity built browser() function. ’re unfamiliar, browser() pauses execution function gives interactive session can inspect current value internal variables even proceed function one statement time. can leverage browser() developing APIs locally adding browser() call one handlers. offers powerful technique use want inspect multiple different variables interact current state things inside function. also good way get hands dirty Plumber get better acquainted things behave low level. Consider following API endpoint: run API locally visit API web browser, ’ll see R session switch debug mode request arrives, allowing look objects contained inside req res objects. usually works, R session can become confused entering debugging mode running server. often better mock request. can create mocked request object using fiery::fake_request() can populate path, method, headers, body content. can take object send API using test_request() method Plumber API object: aware req res objects familiar handlers, rather formats plumber needs use interact httpuv.","code":"#* @get / function(request, response){   browser()    list(a=123) } papi <- api(\"plumber.R\")  req <- fiery::fake_request(\"http://localhost:8080/path/to/handler\")  res <- papi$test_request(req)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/articles/tips-and-tricks.html","id":"port-range","dir":"Articles","previous_headings":"","what":"Port Range","title":"Tips & Tricks","text":"can use [httpuv::randomPort()] define range port Plumber pick running API. programmatically","code":"# plumber.R options(\"plumber2.port\" = httpuv::randomPort(min = 4000, max = 7000, n = 100))  ### define the rest of your plumber router... api(port = httpuv::randomPort(min = 4000, max = 7000, n = 100)) |>   api_run()"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thomas Lin Pedersen. Author, maintainer.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pedersen T (2025). plumber2: Easy Powerful Webservers R. R package version 0.0.0.9000, https://github.com/posit-dev/plumber2, https://posit-dev.github.io/plumber2/.","code":"@Manual{,   title = {plumber2: Easy and Powerful Webservers in R},   author = {Thomas Lin Pedersen},   year = {2025},   note = {R package version 0.0.0.9000, https://github.com/posit-dev/plumber2},   url = {https://posit-dev.github.io/plumber2/}, }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/index.html","id":"plumber2","dir":"","previous_headings":"","what":"Easy and Powerful Webservers in R","title":"Easy and Powerful Webservers in R","text":"complete rewrite plumber. purpose rewrite take everything ’ve learned plumber, shed bad decision inevitably make course development, start scratch. ’ll find plumber2 similar plumber lot ways, diverts key areas, resulting API incompitability two packages. may need update plumber APIs switching plumber2.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Easy and Powerful Webservers in R","text":"plumber2 still work progress, recommended use experiment get familiarity future direction plumber APIs. wish try can install development version GitHub using pak:","code":"pak::pak(\"posit-dev/plumber2\")"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/index.html","id":"feedback","dir":"","previous_headings":"","what":"Feedback","title":"Easy and Powerful Webservers in R","text":"point development feedback crucial. decide try plumber2, please share experience, good bad, ask question informs us spend time documentation.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/index.html","id":"hello-world","dir":"","previous_headings":"","what":"Hello World","title":"Easy and Powerful Webservers in R","text":"simply “hello world” API written plumber2 illustrates differences plumber: can see breaking changes new features action. biggest breaking change parameters coming path, query string, body now clearly separated. parameters path provided direct arguments handler function. Query body parameters accessible query body argument respectively. can seen also use different tags documentation. Speaking documentation, parsing plumber blocks greatly improved. now build upon roxygen2, follows convention, allowing multiline tags defaulting first line title proceeding untagged lines description. ability define input output types also greatly expanded, adding ability define nested objects, adding default values (seen ) define enum (factors) name . input get type checked default value imputed missing. /plot handler can also see specifies multiple serializers. allow client request ’s prefered response format using Accept header. Plumber2 perform content negotiation figure best response format based supports client prefers. Lastly, can see new tag (one many) /plot handler. @async allows convert handler async handler automatically. still possible create async handler manually returning promise, new tag significantly simplifies classic cases. still overhead involved handling requests asynchronously mainly good idea longer running handlers, shown example.","code":"#* Echo the parameter that was sent in #* #* @get /echo/<msg> #* #* @param msg:string The message to echo back. #* #* @response 200:{msg:string} A string containing the input message #* function(msg) {   list(     msg = paste0(\"The message is: '\", msg, \"'\")   ) }  #* Plot out data from the iris dataset #* #* @get /plot #* #* @query spec:enum|setosa, versicolor, virginica| If provided, filter the #* data to only this species #* #* @serializer png{width = 700, height = 500} #* @serializer jpeg{width = 700, height = 500} #* #* @async function(query) {   myData <- iris   title <- \"All Species\"    # Filter if the species was specified   if (!is.null(query$spec)){     title <- paste0(\"Only the '\", query$spec, \"' Species\")     myData <- subset(iris, Species == query$spec)     if (nrow(myData) == 0) {       abort_internal_error(\"Missing data for {query$spec}\")     }   }    plot(     myData$Sepal.Length,     myData$Petal.Length,     main=title,     xlab=\"Sepal Length\",     ylab=\"Petal Length\"   ) }"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Next.html","id":null,"dir":"Reference","previous_headings":"","what":"Router control flow — Next","title":"Router control flow — Next","text":"plumber2 API can multiple middleware request passes . point can short-circuit remaining middleware returning Break, instructs plumber2 return response . Returning Next indicates opposite, ie request allowed pass next middleware chain. handler function return either assumed return value set response body implicitely continue next middleware.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Next.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Router control flow — Next","text":"","code":"Next  Break  should_break(x)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Next.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Router control flow — Next","text":"x object test","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":null,"dir":"Reference","previous_headings":"","what":"The Plumber2 Class — Plumber2","title":"The Plumber2 Class — Plumber2","text":"class encapsulates logic plumber2 api, gets passed around functional api plumber2. Plumber2 class subclass fiery::Fire class. Please consult documentation additional information type server capable . Note Plumber2 objects reference objects, meaning change change instances object.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"initialization","dir":"Reference","previous_headings":"","what":"Initialization","title":"The Plumber2 Class — Plumber2","text":"new 'Plumber2'-object initialized using new() method generator: However, users use functional api package thus construct one using api()","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"copying","dir":"Reference","previous_headings":"","what":"Copying","title":"The Plumber2 Class — Plumber2","text":"Plumber2 objects using reference semantics new copies api made simply assigning new variable. true copy Plumber2 object desired, use clone() method.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"The Plumber2 Class — Plumber2","text":"fiery::Fire -> Plumber2","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"The Plumber2 Class — Plumber2","text":"request_router router handling requests header_router router handling partial requests (request pass router prior reading body) doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation ","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"The Plumber2 Class — Plumber2","text":"fiery::Fire$async() fiery::Fire$attach() fiery::Fire$close_ws_con() fiery::Fire$delay() fiery::Fire$exclude_static() fiery::Fire$extinguish() fiery::Fire$get_data() fiery::Fire$has_plugin() fiery::Fire$header() fiery::Fire$is_running() fiery::Fire$log() fiery::Fire$() fiery::Fire$() fiery::Fire$reignite() fiery::Fire$remove_async() fiery::Fire$remove_data() fiery::Fire$remove_delay() fiery::Fire$remove_time() fiery::Fire$resume() fiery::Fire$safe_call() fiery::Fire$send() fiery::Fire$serve_static() fiery::Fire$set_client_id_converter() fiery::Fire$set_data() fiery::Fire$set_logger() fiery::Fire$start() fiery::Fire$stop() fiery::Fire$test_header() fiery::Fire$test_message() fiery::Fire$test_request() fiery::Fire$test_websocket() fiery::Fire$time() fiery::Fire$trigger()","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"The Plumber2 Class — Plumber2","text":"Plumber2$new() Plumber2$format() Plumber2$ignite() Plumber2$add_route() Plumber2$request_handler() Plumber2$message_handler() Plumber2$redirect() Plumber2$parse_file() Plumber2$add_api_doc() Plumber2$clone()","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"The Plumber2 Class — Plumber2","text":"Create new Plumber2 api","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$new(   host = get_opts(\"host\", \"127.0.0.1\"),   port = get_opts(\"port\", 8080),   doc_type = get_opts(\"docType\", \"rapidoc\"),   doc_path = get_opts(\"docPath\", \"__docs__\"),   reject_missing_methods = get_opts(\"rejectMissingMethods\", FALSE),   ignore_trailing_slash = get_opts(\"ignoreTrailingSlash\", TRUE),   max_request_size = get_opts(\"maxRequestSize\"),   shared_secret = get_opts(\"sharedSecret\"),   compression_limit = get_opts(\"compressionLimit\", 1000),   default_async = get_opts(\"async\", \"future\"),   env = caller_env() )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"host string overriding default host port port number overriding default port doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation reject_missing_methods requests paths handler specific method automatically rejected 405 Method Allowed response correct Allow header informing client implemented methods. Assigning handler \"\" path later point overwrite functionality. aware setting TRUE prevent request falling routes might matching method path. setting anly affects handlers request router. ignore_trailing_slash Logical. trailing slash path ignored adding handlers handling requests. Setting change request path associated just ensure path//ressource path//ressource/ ends handler. setting affect routes created automatically. max_request_size Sets maximum size request bodies. Setting add handler header router automatically rejects requests based Content-Length header shared_secret Assigns shared secret api. Setting add handler header router automatically rejects requests Plumber-Shared-Secret header contain value. aware type authentication weak. Never put shared secret plain text rely e.g. keyring package storage. Even , requests send HTTP (HTTPS) anyone can read secret use compression_limit size threshold bytes trying compress response body (still dependant content negotiation) default_async default evaluater use async request handling env environment used default execution environment API","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"The Plumber2 Class — Plumber2","text":"Plumber2 object","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-format-","dir":"Reference","previous_headings":"","what":"Method format()","title":"The Plumber2 Class — Plumber2","text":"Human readable description api object","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$format(...)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"... ignored","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"The Plumber2 Class — Plumber2","text":"character vector","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-ignite-","dir":"Reference","previous_headings":"","what":"Method ignite()","title":"The Plumber2 Class — Plumber2","text":"Begin running server. trigger start event","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$ignite(   block = FALSE,   showcase = is_interactive(),   ...,   silent = FALSE )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"block console blocked running (alternative run background) showcase default browser open server address. TRUE browser opens root api, unless api contains OpenAPI documentation case open location. string string used path add root opening. ... Arguments passed start handler silent startup messaging silenced","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-add-route-","dir":"Reference","previous_headings":"","what":"Method add_route()","title":"The Plumber2 Class — Plumber2","text":"Add new route either request header router","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$add_route(name, route = NULL, header = FALSE, after = NULL)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"name name route add. route already present name provided route () merged route route add. NULL new empty route created header Logical. route added header router? location place new route stack. NULL place end. effect route given name already exists.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-request-handler-","dir":"Reference","previous_headings":"","what":"Method request_handler()","title":"The Plumber2 Class — Plumber2","text":"Add handler request. See api_request_handlers detailed information","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$request_handler(   method,   path,   handler,   serializers,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   async = FALSE,   doc = NULL,   route = NULL,   header = FALSE )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"method HTTP method attach handler path string giving path handler responds . handler handler function call request matched path serializers named list serializers can used format response sending back client. one selected based request Accept header parsers named list parsers can used parse request body passing body argument. one selected based request Content-Type header use_strict_serializer default, serializer respects requests Accept header found, first provided ones used. Setting TRUE instead send back 406 Acceptable response download response mark download instead shown inline? Setting TRUE set Content-Disposition header response attachment. Setting string equivalent setting TRUE addition also set default filename download string value async FALSE create regular handler. TRUE, use default async evaluater create async handler. string, async evaluater registered name used. function provided used async evaluater doc OpenAPI documentation handler. added paths$<handler_path>$<handler_method> portion API. route route handler added . Defaults last route stack. route exist created last route stack. header Logical. handler added header router","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-message-handler-","dir":"Reference","previous_headings":"","what":"Method message_handler()","title":"The Plumber2 Class — Plumber2","text":"Add handler WebSocket message. See api_message detailed information","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$message_handler(handler, async = FALSE)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"handler function conforming specifications laid api_message() async FALSE create regular handler. TRUE, use default async evaluater create async handler. string, async evaluater registered name used. function provided used async evaluater","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-redirect-","dir":"Reference","previous_headings":"","what":"Method redirect()","title":"The Plumber2 Class — Plumber2","text":"Add redirect header router. Depending value permanent respond 307 Temporary Redirect 308 Permanent Redirect. can contain path parameters wildcards matched two construct correct redirect path.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$redirect(method, from, to, permanent = TRUE)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"method HTTP method redirect respond path redirect respond path/URL redirect incoming request towards. resolving path parameters wildcards used Location header permanent Logical. redirect considered permanent temporary? Determines type redirct status code use","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-parse-file-","dir":"Reference","previous_headings":"","what":"Method parse_file()","title":"The Plumber2 Class — Plumber2","text":"Parses plumber file updates app according ","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$parse_file(file, env = NULL)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"file path file parse env parent environment environment file evaluated . NULL environment provided construction used","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-add-api-doc-","dir":"Reference","previous_headings":"","what":"Method add_api_doc()","title":"The Plumber2 Class — Plumber2","text":"Add (partial) OpenAPI spec api docs","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$add_api_doc(doc, overwrite = FALSE, subset = NULL)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"doc list OpenAPI documentation overwrite Logical. already existing documentation removed merged together doc subset character vector giving path subset docs assign doc ","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"The Plumber2 Class — Plumber2","text":"objects class cloneable method.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"The Plumber2 Class — Plumber2","text":"","code":"Plumber2$clone(deep = FALSE)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/Plumber2.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Plumber2 Class — Plumber2","text":"deep Whether make deep clone.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new plumber API, optionally based on one or more plumber files — api","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"main way create new Plumber2 object encapsulates full api. also possible add files API creation using api_parse()","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"","code":"api(   ...,   host = get_opts(\"host\", \"127.0.0.1\"),   port = get_opts(\"port\", 8080),   doc_type = get_opts(\"docType\", \"rapidoc\"),   doc_path = get_opts(\"docPath\", \"__docs__\"),   reject_missing_methods = get_opts(\"rejectMissingMethods\", FALSE),   ignore_trailing_slash = get_opts(\"ignoreTrailingSlash\", TRUE),   max_request_size = get_opts(\"maxRequestSize\"),   shared_secret = get_opts(\"sharedSecret\"),   compression_limit = get_opts(\"compressionLimit\", 1000),   default_async = get_opts(\"async\", \"future\"),   env = caller_env() )  is_plumber_api(x)  api_parse(api, ...)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"... plumber files directories containing plumber files parsed given order. order parsing determines final order routes stack. ... contains _server.yml file files ... ignored _server.yml file used basis API host string valid IPv4 address owned server port number integer indicates server port listened . Note Unix-like systems including Linux macOS, port numbers smaller 1024 require root privileges. doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation reject_missing_methods requests paths handler specific method automatically rejected 405 Method Allowed response correct Allow header informing client implemented methods. Assigning handler \"\" path later point overwrite functionality. aware setting TRUE prevent request falling routes might matching method path. setting anly affects handlers request router. ignore_trailing_slash Logical. trailing slash path ignored adding handlers handling requests. Setting change request path associated just ensure path//ressource path//ressource/ ends handler. max_request_size Sets maximum size request bodies. Setting add handler header router automatically rejects requests based Content-Length header shared_secret Assigns shared secret api. Setting add handler header router automatically rejects requests Plumber-Shared-Secret header contain value. aware type authentication weak. Never put shared secret plain text rely e.g. keyring package storage. Even , requests send HTTP (HTTPS) anyone can read secret use compression_limit size threshold bytes trying compress response body (still dependant content negotiation) default_async default evaluater use async request handling env parent environment environment files evaluated . file evaluated environment interfere x object test whether plumber api api plumber2 api object parse files ","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new plumber API, optionally based on one or more plumber files — api","text":"Plumber2 object","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_add_route.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a new route to either the request or header router — api_add_route","title":"Add a new route to either the request or header router — api_add_route","text":"function allows explicit creation routes addition/merging predefined routr::Route router api. new route can also created route argument adding handler. However, way always add new routes end stack, whereas using api_add_route() allows full control placement.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_add_route.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a new route to either the request or header router — api_add_route","text":"","code":"api_add_route(api, name, route = NULL, header = FALSE, after = NULL)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_add_route.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a new route to either the request or header router — api_add_route","text":"api plumber2 api object add route name name route add. route already present name provided route () merged route route add. NULL new empty route created header Logical. route added header router? location place new route stack. NULL place end. effect route given name already exists.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_add_route.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a new route to either the request or header router — api_add_route","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_assets.html","id":null,"dir":"Reference","previous_headings":"","what":"Serve ressources from your file system — api_assets","title":"Serve ressources from your file system — api_assets","text":"plumber2 provides two ways serve files server. One (api_assets) goes R gives power expect modify work response. (api_statics) never hits R process result blazing fast. However comes price limited freedom modify response even basic authentication. place.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_assets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serve ressources from your file system — api_assets","text":"","code":"api_assets(   api,   at,   path,   default_file = \"index.html\",   default_ext = \"html\",   finalize = NULL,   continue = FALSE,   route = NULL )  api_statics(   api,   at,   path,   use_index = TRUE,   fallthrough = FALSE,   html_charset = \"utf-8\",   headers = list(),   validation = NULL,   except = NULL )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_assets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serve ressources from your file system — api_assets","text":"api plumber2 api object add rossource serving path serve ressources path location file system map default_file default file look path map file directly (see Details) default_ext default file extension add file file found provided path path extension (see Details) finalize optional function run file found. function receive request first argument, response second, anything passed ... dispatch method. return value function discarded. function must accept ... continue logical returned file found. Defaults FALSE indicating response send unmodified. route name route header router add asset route . Defaults last route stack. route exist created last route stack use_index index.html file served present client requests folder fallthrough requests match file enter request loop 404 response send directly html_charset charset report serving html files headers list headers add response. combined global headers app validation optional validation pattern. Presently, type validation supported exact string match header. example, validation '\"abc\" = \"xyz\"', HTTP requests must header named abc (case-insensitive) value xyz (case-sensitive). request matching header, httpuv give 403 Forbidden response. character(0) (default), validation check performed. except One url paths excluded route. Requests matching enter standard router dispatch. paths interpreted subpaths , e.g. final path exclude +exclude (see example)","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_assets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serve ressources from your file system — api_assets","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_docs.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure your API for serving documentation for itself — api_docs","title":"Configure your API for serving documentation for itself — api_docs","text":"OpenAPI standard offers way describe various endpoints api machine- human-readable way. top , various solutions build generate online documentation API based provided OpenAPI spec. plumber2 offers support RapiDoc, Redoc, Swagger UI frontend documentation also generate spec based tags parsed files. creating API programmatically wish add autogenerated docs can add docs manually, either adding handler (using doc argument), api_doc_add() function","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_docs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure your API for serving documentation for itself — api_docs","text":"","code":"api_doc_setting(api, doc_type, doc_path)  api_doc_add(api, doc, overwrite = FALSE, subset = NULL)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_docs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure your API for serving documentation for itself — api_docs","text":"api plumber2 api object add docs doc settings doc_type type API documentation generate. Can either \"rapidoc\" (default), \"redoc\", \"swagger\", NULL (equating generating API docs) doc_path URL path serve api documentation doc list OpenAPI documentation overwrite Logical. already existing documentation removed merged together doc subset character vector giving path subset docs assign doc ","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_docs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure your API for serving documentation for itself — api_docs","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_logger.html","id":null,"dir":"Reference","previous_headings":"","what":"Set logging function and access log format for the API — api_logger","title":"Set logging function and access log format for the API — api_logger","text":"Plumber2 build-logging facility takes care logging conditions caught, well access logs. possible log custom messages using log() method api object. However, actual logging handled customizable function can set. can read logging infrastructure fiery documentation. plumber2 reexports loggers provided fiery immediately available user.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_logger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set logging function and access log format for the API — api_logger","text":"","code":"api_logger(api, logger = NULL, access_log_format = NULL)  logger_null()  logger_console(format = \"{time} - {event}: {message}\")  logger_file(file, format = \"{time} - {event}: {message}\")  logger_logger(default_level = \"INFO\")  logger_switch(..., default = logger_null())  common_log_format  combined_log_format"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_logger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set logging function and access log format for the API — api_logger","text":"api plumber2 api object set logger logger logger function. NULL current logger kept access_log_format glue string giving format access logs. plumber2 (fiery) provides predefined common_log_format combined_log_format, can easily create . See fiery::loggers variables glue string access . format glue string specifying format log entry file file connection write default_level log level use events request, websocket, message, warning, error ... named list loggers use different events. semantics switch used possible let events fall e.g. logger_switch(error =, warning = logger_file('errors.log')). default catch-logger use events defined ...","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_message.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler to a WebSocket message — api_message","title":"Add a handler to a WebSocket message — api_message","text":"WebSockets bidirectional communication channel can established request client. websocket communication really part standard REST api, many uses can easily used together one.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_message.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler to a WebSocket message — api_message","text":"","code":"api_message(api, handler)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_message.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler to a WebSocket message — api_message","text":"api plumber2 api object add handler handler function conforming specifications laid Details","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_message.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler to a WebSocket message — api_message","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_message.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a handler to a WebSocket message — api_message","text":"handler websocket message much simpler requests general since concern methods, paths, responses. message handler registered get called sequence websocket message recieved client. Still, expectations apply","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_message.html","id":"handler-arguments","dir":"Reference","previous_headings":"","what":"Handler Arguments","title":"Add a handler to a WebSocket message — api_message","text":"handler can take following arguments: message: Either raw vector message recieved binary form single string, giving message sent client server: Plumber2 object representing server implementation client_id: string uniquely identifying session request comes request: request initially used establish websocket connection client reqres::Request object","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_message.html","id":"handler-return-value","dir":"Reference","previous_headings":"","what":"Handler Return Value","title":"Add a handler to a WebSocket message — api_message","text":"expected websocket message sends response thus handler required anything like . However, handler returns either raw vector single string taken signal send back client. return value silently ignored.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_on.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler to an event — api_on","title":"Add a handler to an event — api_on","text":"life cycle plumber API various events fired, either automatically manually. See article events fiery full overview. api_on() allows add handlers called specific events fire. api_off() can used remove handler necessary","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_on.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler to an event — api_on","text":"","code":"api_on(api, event, handler, id = NULL)  api_off(api, id)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_on.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler to an event — api_on","text":"api plumber2 api object launch stop event string naming event listen handler function call event fires id string uniquely identifying handler. NULL random id generated making impossible remove handler ","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_on.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler to an event — api_on","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_redirect.html","id":null,"dir":"Reference","previous_headings":"","what":"Redirect request to another resource — api_redirect","title":"Redirect request to another resource — api_redirect","text":"optimal API remains stable lifetime often fully attainable. order direct requests ressources moved new location can add redirect ensures smooth transition clients still using old path. Depending value permanent redirect respond 307 Temporary Redirect 308 Permanent Redirect. can contain path parameters wildcards matched two construct correct redirect path. , can either path server fully qualified URL redirect requests another server alltogether.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_redirect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Redirect request to another resource — api_redirect","text":"","code":"api_redirect(api, method, from, to, permanent = TRUE)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_redirect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Redirect request to another resource — api_redirect","text":"api plumber2 api object add redirect method HTTP method redirect respond path redirect respond path/URL redirect incoming request towards. resolving path parameters wildcards used Location header permanent Logical. redirect considered permanent temporary? Determines type redirct status code use","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_redirect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Redirect request to another resource — api_redirect","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler for a request — api_request_handlers","title":"Add a handler for a request — api_request_handlers","text":"family functions facilitates adding request handler specific HTTP method path.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler for a request — api_request_handlers","text":"","code":"api_get(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_head(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_post(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_put(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_delete(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_connect(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_options(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_trace(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_patch(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )  api_any(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   doc = NULL,   route = NULL )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler for a request — api_request_handlers","text":"api plumber2 api object add handler path string giving path handler responds . See Details handler handler function call request matched path serializers named list serializers can used format response sending back client. one selected based request Accept header. See get_serializers() helper construct parsers named list parsers can used parse request body passing body argument. one selected based request Content-Type header. See get_parsers() helper construct use_strict_serializer default, serializer respects requests Accept header found, first provided ones used. Setting TRUE instead send back 406 Acceptable response download response mark download instead shown inline? Setting TRUE set Content-Disposition header response attachment. Setting string equivalent setting TRUE addition also set default filename download string value doc list OpenAPI spec endpoint route route handler added . Defaults last route stack. route exist created last route stack","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler for a request — api_request_handlers","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"http-methods","dir":"Reference","previous_headings":"","what":"HTTP Methods","title":"Add a handler for a request — api_request_handlers","text":"HTTP specs provide selection specific methods clients can send server (plumber api). enforcement server follows conventions strive create server API adheres common expectations. required server understands methods, often opposite true. HTTP methods described , consider consulting MDN get acquainted HTTP spec general GET: method used request specific content perhaps ubiquitous method use. GET requests retrieve data contain body content HEAD: method identical GET, except response contain headers, body. Apart expected HEAD request identical GET request ressource POST: method delivers content, form request body, server, potentially causing change server. context plumber2 often used call functions require input larger can put URL PUT: method used update specific ressource server. context standard plumber2 server rarely relevant, though usage can come . PUT considered clients indemptotent meaning sending PUT request multiple times effect DELETE: method deletes ressource opposite PUT. PUT method limited use standard plumber2 servers CONNECT: method request establishment proxy tunnel. considered advanced use unlikely usecase plumber2 api OPTIONS: method used clients query server methods settings supported server TRACE: method form ping send response containing request (stripped sensitive information). Many servers disallow method due security concerns PATCH: method like PUT allows partial modification ressource Apart , plumber2 also understands method responds requests methods, assuming specific handler method found. semantics various methods quite different handler mainly used rejections setting specific broad headers response, main handler request","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"the-path","dir":"Reference","previous_headings":"","what":"The Path","title":"Add a handler for a request — api_request_handlers","text":"path defines URL request made root removed. plumber2 server runs http://example.com/api/ request made http://example.com/api/user/thomas/, path user/thomas/. Paths can static like prior example, dynamic described :","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"path-arguments","dir":"Reference","previous_headings":"","what":"Path arguments","title":"Add a handler for a request — api_request_handlers","text":"Consider bunch users. impractical register handler one . Instead can use dynamic path like following syntax: user/<username>/. path matched requests made user/..something../. actual value ..something.. (e.g. thomas) made available handler (see ). path can contain multiple arguments needed, user/<username>/settings/<setting>/","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"path-wildcards","dir":"Reference","previous_headings":"","what":"Path wildcards","title":"Add a handler for a request — api_request_handlers","text":"Apart path arguments also possible even less specific adding wildcard path. path user/* match user/thomas/, user/thomas/settings/interests/, anything path begins user/. arguments path can contain multiple wildcards use diminishing returns. Contrary path arguments value(s) corresponding * made available handler.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"path-priority","dir":"Reference","previous_headings":"","what":"Path Priority","title":"Add a handler for a request — api_request_handlers","text":"existence path arguments wildcards possible multiple handlers route can matched single request. Since one can selected need determine one wins. priority based specificity path. Consider server containing following handler paths: user/thomas/, user/<username>/, user/<username>/settings/<setting>/, user/*. paths following priority: user/<username>/settings/<setting>/ user/thomas/ user/<username>/ user/* first spot due fact path elements deemed specific. remaining 3 number elements, static paths considered specific dynamic paths, path arguments considered specific wildcards. request made user/carl thus end third handler, request made user/thomas end second. ordering makes possible provide default handlers well specialisations specific paths.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"the-handler","dir":"Reference","previous_headings":"","what":"The Handler","title":"Add a handler for a request — api_request_handlers","text":"handler standard R function called request made matches handlers path (unless specific handler path exists — see ). handler function can perform operation normal R function can , though consider strongly security implications handler functions. However, certain expectations plumber around arguments handler function takes return value provides","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"handler-arguments","dir":"Reference","previous_headings":"","what":"Handler Arguments","title":"Add a handler for a request — api_request_handlers","text":"handler function can take one following arguments. Path arguments: path arguments passed handler. handler registered following path user/<username>/settings/<setting>/ handles request user/thomas/settings/interests/ called username = \"thomas\", setting = \"interest\" request: request handler responding reqres::Request object response: response returned client reqres::Response object server: Plumber2 object representing server implementation client_id: string uniquely identifying session request comes query: list giving additional arguments passed handler part url query string body: request body, parsed specified provided parsers","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"handler-return-value","dir":"Reference","previous_headings":"","what":"Handler Return Value","title":"Add a handler for a request — api_request_handlers","text":"Handlers can return range different value types, inform plumber2 next:","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"returning-next-or-break","dir":"Reference","previous_headings":"","what":"Returning Next or Break","title":"Add a handler for a request — api_request_handlers","text":"two control objects informs plumber2 either proceed handling request (Next) return response , circumventing remaining routes (Break)","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"returning-null-or-the-response-object","dir":"Reference","previous_headings":"","what":"Returning NULL or the response object","title":"Add a handler for a request — api_request_handlers","text":"returning Next, ie. signals handling can proceed","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"returning-a-ggplot-object","dir":"Reference","previous_headings":"","what":"Returning a ggplot2 object","title":"Add a handler for a request — api_request_handlers","text":"return ggplot2 object get plotted (added response assuming graphics serializer provided) handling continues","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"returning-any-other-value","dir":"Reference","previous_headings":"","what":"Returning any other value","title":"Add a handler for a request — api_request_handlers","text":"kind value returned captured description set response body (overwritting already ) handling allowed continue","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_handlers.html","id":"handler-conditions","dir":"Reference","previous_headings":"","what":"Handler conditions","title":"Add a handler for a request — api_request_handlers","text":"Like function R, handler may need signal something happened, either throwing error warning emitting message. can use stop(), warning(), message() used . , condition message end log. , stop() handling request end 500 Internal Error response returned. take control problems can use abort_*() family conditions reqres. Like stop() halt processing, also allow control kind response sent back, kind information issue communicated client, kind information logged internally. response send back (except abort_status()) adhere HTTP Problem spec defined RFC 9457. may feel like good idea send detailed error message back client often better inform client need change solve issue. much information internal implementation details can security risk forwarding internal errors client can help inform client server implemented.","code":""},{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_header_handlers.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a handler for a request header — api_request_header_handlers","title":"Add a handler for a request header — api_request_header_handlers","text":"handlers called request body recieved lets y ou preemptively reject requests recieving full content. logic, however, main handlers asked consult api_request_handlers docs -depth details use request handlers general.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_header_handlers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a handler for a request header — api_request_header_handlers","text":"","code":"api_get_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_head_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_post_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_put_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_delete_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_connect_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_options_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_trace_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_patch_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )  api_any_header(   api,   path,   handler,   serializers = NULL,   parsers = NULL,   use_strict_serializer = FALSE,   download = FALSE,   route = NULL )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_header_handlers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a handler for a request header — api_request_header_handlers","text":"api plumber2 api object add handler path string giving path handler responds . See Details handler handler function call request matched path serializers named list serializers can used format response sending back client. one selected based request Accept header. See get_serializers() helper construct parsers named list parsers can used parse request body passing body argument. one selected based request Content-Type header. See get_parsers() helper construct use_strict_serializer default, serializer respects requests Accept header found, first provided ones used. Setting TRUE instead send back 406 Acceptable response download response mark download instead shown inline? Setting TRUE set Content-Disposition header response attachment. Setting string equivalent setting TRUE addition also set default filename download string value route route handler added . Defaults last route stack. route exist created last route stack","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_request_header_handlers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a handler for a request header — api_request_header_handlers","text":"functions return api object allowing easy chaining pipe","code":""},{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Launch the API — api_run","title":"Launch the API — api_run","text":"function starts api settings defined.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Launch the API — api_run","text":"","code":"api_run(   api,   block = !is_interactive(),   showcase = is_interactive(),   ...,   silent = FALSE )  api_stop(api)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Launch the API — api_run","text":"api plumber2 api object launch stop block console blocked running (alternative run background). Defaults FALSE interactive sessions TRUE otherwise. showcase default browser open server address. TRUE browser opens root api, unless api contains OpenAPI documentation case open location. string string used path add root opening. ... Arguments passed start handler silent startup messaging silenced","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Launch the API — api_run","text":"functions return api object allowing easy chaining pipe, even though often last part chain","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_session_cookie.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn on session cookie data storage for your API — api_session_cookie","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"need keep data requests, want store server-side can instead pass back forth encrypted session cookie. function sets api use can now access set session data request response $session field. aware session data send back forth requests thus kept minimal avoid congestion server.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_session_cookie.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"","code":"api_session_cookie(   api,   key,   name = \"reqres\",   expires = NULL,   max_age = NULL,   path = NULL,   secure = NULL,   same_site = NULL )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_session_cookie.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"api plumber2 api object add session cookie setup key 32-bit secret key hex encoded string raw vector use encrypting session cookie. valid key can generated using reqres::random_key(). NEVER STORE KEY PLAIN TEXT. Optimalle use keyring package store name name cookie expires POSIXct object given expiration time cookie max_age number seconds elapse cookie expires path URL path cookie related secure cookie send https same_site Either \"Lax\", \"Strict\", \"None\" indicating cookie can send cross-site requests. set \"None\" secure must also set TRUE","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/api_session_cookie.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn on session cookie data storage for your API — api_session_cookie","text":"functions return api object allowing easy chaining pipe","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/async_evaluaters.html","id":null,"dir":"Reference","previous_headings":"","what":"Async evaluaters provided by plumber — async_evaluaters","title":"Async evaluaters provided by plumber — async_evaluaters","text":"functions support async request handling. can register well using register_async().","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/async_evaluaters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Async evaluaters provided by plumber — async_evaluaters","text":"","code":"future_async(...)  mirai_async(...)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/async_evaluaters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Async evaluaters provided by plumber — async_evaluaters","text":"... argument passed internal async function. See Details information function handles formatting internally async evaluater","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/async_evaluaters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Async evaluaters provided by plumber — async_evaluaters","text":"function taking expr envir. former expression evaluate latter environment additional variables made available evaluation","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/async_evaluaters.html","id":"provided-evaluaters","dir":"Reference","previous_headings":"","what":"Provided evaluaters","title":"Async evaluaters provided by plumber — async_evaluaters","text":"future_async() uses promises::future_promise(). registered \"future\". aware evaluater execute asynchronously need set different planner default. See future::plan(). mirai_async() uses mirai::mirai(). registered \"mirai\". aware evaluater performant start multiple persistent background processes. See mirai::daemons().","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/create_server_yml.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a _server.yml file to describe your API — create_server_yml","title":"Create a _server.yml file to describe your API — create_server_yml","text":"can manually create plumber2 API calling api(), often need deploy api somewhere else. facilitate can create _server.yml encapsulates settings plumber files. call api() path file API constructed according content.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/create_server_yml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a _server.yml file to describe your API — create_server_yml","text":"","code":"create_server_yml(..., path = \".\", constructor = NULL, freeze_opt = TRUE)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/create_server_yml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a _server.yml file to describe your API — create_server_yml","text":"... path files /directories contain annotated plumber files used API path folder place generated _server.yml file constructor path file creates plumber2 API object. Can omitted case API object created freeze_opt Logical specifying whether options currently locally (either environment variables R options) written _server.yml file. Shared secret never written file must find different way move deployment server.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/device_formatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a graphics device formatter — device_formatter","title":"Create a graphics device formatter — device_formatter","text":"internal function facilitates creating formatter uses specific device rendering.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/device_formatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a graphics device formatter — device_formatter","text":"","code":"device_formatter(dev_open, dev_close = grDevices::dev.off())"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/device_formatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a graphics device formatter — device_formatter","text":"dev_open function opens device dev_close function closing device. Usually grDevices::dev.()","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/device_formatter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a graphics device formatter — device_formatter","text":"device formatter function","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/init_formatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatter orchestration — init_formatter","title":"Formatter orchestration — init_formatter","text":"functions internal use exported ease async evaluation","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/init_formatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatter orchestration — init_formatter","text":"","code":"init_formatter(formatter)  close_formatter(formatter, info)  clean_formatter(formatter, info)  with_formatter(expr, formatter, info)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/init_formatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formatter orchestration — init_formatter","text":"formatter serializer function info structure returned init_formatter() expr expression evaluate context formatter","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/init_formatter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formatter orchestration — init_formatter","text":"init_formatter() returns opaque structure capturing information used functions. close_formatter() may return value used response body. with_formatter() returns result expr. clean_formatter() called side effects called close_formatter() never evaluated.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/openapi.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct OpenAPI specifications — openapi","title":"Construct OpenAPI specifications — openapi","text":"helper functions aid constructing OpenAPI compliant specifications API. return simple lists may thus forego helpers instead construct manually (import json yaml file). purpose helpers mainly basic input checking documenting structure. Read spec https://spec.openapis.org/oas/v3.0.0.html","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/openapi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct OpenAPI specifications — openapi","text":"","code":"openapi(   openapi = \"3.0.0\",   info = openapi_info(),   paths = list(),   tags = list() )  openapi_info(   title = character(),   description = character(),   terms_of_service = character(),   contact = openapi_contact(),   license = openapi_license(),   version = character() )  openapi_contact(name = character(), url = character(), email = character())  openapi_license(name = character(), url = character())  openapi_path(   summary = character(),   description = character(),   get = openapi_operation(),   put = openapi_operation(),   post = openapi_operation(),   delete = openapi_operation(),   options = openapi_operation(),   head = openapi_operation(),   patch = openapi_operation(),   trace = openapi_operation(),   parameters = list() )  openapi_operation(   summary = character(),   description = character(),   operation_id = character(),   parameters = list(),   request_body = openapi_request_body(),   responses = list(),   tags = character() )  openapi_parameter(   name = character(),   location = c(\"path\", \"query\", \"header\", \"cookie\"),   description = character(),   required = logical(),   schema = openapi_schema(),   content = openapi_content(),   ... )  openapi_header(description = character(), schema = openapi_schema())  openapi_schema(x, default = NULL, min = NULL, max = NULL, ..., required = NULL)  openapi_content(...)  openapi_request_body(   description = character(),   content = openapi_content(),   required = logical() )  openapi_response(   description = character(),   content = openapi_content(),   headers = list() )  openapi_tag(name = character(), description = character())"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/openapi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct OpenAPI specifications — openapi","text":"openapi OpenAPI version spec adheres . helpers assume 3.0.0 also default value info list constructed openapi_info() paths named list. names correspond endpoints elements lists constructed openapi_path() tags openapi() list elements corresponding value constructed openapi_tag(). openapi_operation() argument simple character vector title string giving title API description longer description respective element. May use markdown terms_of_service URL terms service API contact list constructed openapi_contact() license list constructed openapi_license() version string giving version API name name contact, license, parameter, tag url URL pointing contact license information email email address contact summary one-sentence summary path operation get, put, post, delete, options, head, patch, trace list describing specific HTTP method requested path, constructed openapi_operation() parameters list parameters apply path /operation. given openapi_path() inherited operations. operation_id unique string identifies operation API request_body list constructed openapi_request_body() responses named list name corresponding response code elements lists constructed openapi_response() location parameter coming . Either \"path\", \"query\", \"header\", \"cookie\". required openapi_parameter boolean indicating required parameter (\"path\" parameters always required). openapi_schema() character vector naming required properties object. schema description data constructed openapi_schema content list constructed openapi_content(). ... named arguments added element. openapi_content() named elements constructed openapi_schema() x R object corresponding type schema. Supported types : integer: signal type: integer numeric: signal type: number character: signal type: string faactor: signal type: string enum set factor levels raw: signal type:string; format: binary Date: signal type:string; format: date POSIXt: signal type:string; format: date-time list: unnamed must one-length list signal type: array items set schema element. named signal type: object properties set schema element. AsIs: signal type equivalent value input (must string) default default value parameter. Must reconsilable type x min, max Bounds value parameter headers named list names corresponding headers elements constructed openapi_header()","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/openapi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct OpenAPI specifications — openapi","text":"list","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parse_plumber_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a plumber file — parse_plumber_file","title":"Parse a plumber file — parse_plumber_file","text":"function takes care parsing annotated plumber file creating one routes, API specs, modifier function called plumber app routes added. function attach parsed data plumber api, rarely necessary call directly.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parse_plumber_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a plumber file — parse_plumber_file","text":"","code":"parse_plumber_file(   path,   ignore_trailing_slash,   default_async,   env = caller_env() )"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parse_plumber_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a plumber file — parse_plumber_file","text":"path path file parse ignore_trailing_slash Logical. trailing slash path ignored adding handlers handling requests. Setting change request path associated just ensure path//ressource path//ressource/ ends handler. default_async async evaluater use default @async tag used without argument env environment evaluate code annotations ","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parse_plumber_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a plumber file — parse_plumber_file","text":"list containing: route main route handling requests according parsed file, named list length one header_route route attached header events (fires body recieved can used prematurely reject requests based headers), named list length one asset_routes asset routes created @static blocks named list message_handlers websocket message handlers created @message blocks, list api list giving OpenAPI spec parsed file modifier single function chaining functions @plumber blocks together","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parsers.html","id":null,"dir":"Reference","previous_headings":"","what":"Parser functions provided by plumber2 — parsers","title":"Parser functions provided by plumber2 — parsers","text":"functions cover large area potential request body formats. registered standard mime types users may want use register alternative types know makes sense.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parsers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parser functions provided by plumber2 — parsers","text":"","code":"parse_csv(...)  parse_octet()  parse_rds(...)  parse_feather(...)  parse_parquet(...)  parse_text(multiple = FALSE)  parse_tsv(...)  parse_yaml(...)  parse_geojson(...)  parse_multipart(parsers = get_parsers())"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parsers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parser functions provided by plumber2 — parsers","text":"... argument passed internal parsing function. See Details information function handles parsing internally parser multiple logical: conversion single     character string multiple individual characters? parsers list parsers use parsing parts body","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parsers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parser functions provided by plumber2 — parsers","text":"function accepting raw vector along directives argument provides directives Content-Type passed along","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parsers.html","id":"provided-parsers","dir":"Reference","previous_headings":"","what":"Provided parsers","title":"Parser functions provided by plumber2 — parsers","text":"parse_csv() uses readr::read_csv() parsing. registered \"csv\" mime types application/csv, application/x-csv, text/csv, text/x-csv parse_multipart uses webutils::parse_multipart() initial parsing. goes part tries find parser matches content type (either given directly guessed file extension provided). parser found leaves value raw vector. registered \"multi\" mime type multipart/* parse_octet() passes raw data unchanged. registered \"octet\" mime type application/octet-stream parse_rds() uses unserialize() parsing. registered \"rds\" mime type application/rds parse_feather() uses arrow::read_feather() parsing. registered \"feather\" mime types application/vnd.apache.arrow.file application/feather parse_parquet() uses arrow::read_parquet() parsing. registered \"parquet\" mime type application/vnd.apache.parquet parse_text() uses rawToChar() parsing. registered \"text\" mime types text/plain text/* parse_tsv() uses readr::read_tsv() parsing. registered \"tsv\" mime types application/tab-separated-values text/tab-separated-values parse_yaml() uses yaml::yaml.load() parsing. registered \"yaml\" mime types text/vnd.yaml, application/yaml, application/x-yaml, text/yaml, text/x-yaml parse_geojson() uses geojsonsf::geojson_sf() parsing. registered \"geojson\" mime types application/geo+json application/vdn.geo+json","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/parsers.html","id":"additional-registered-parsers","dir":"Reference","previous_headings":"","what":"Additional registered parsers","title":"Parser functions provided by plumber2 — parsers","text":"reqres::parse_json() registered \"json\" mime types application/json text/json reqres::parse_queryform() registered \"form\" mime type application/x-www-form-urlencoded reqres::parse_xml() registered \"xml\" mime types application/xml text/xml reqres::parse_html() registered \"html\" mime type text/html","code":""},{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/plumber2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"plumber2: Easy and Powerful Webservers in R — plumber2-package","title":"plumber2: Easy and Powerful Webservers in R — plumber2-package","text":"Automatically create webserver annotated R files building programmatically. Provides automatic OpenAPI documentation, input handling, async support, middleware support.","code":""},{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/plumber2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plumber2: Easy and Powerful Webservers in R — plumber2-package","text":"Maintainer: Thomas Lin Pedersen thomasp85@gmail.com (ORCID)","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. reqres abort_bad_request, abort_conflict, abort_forbidden, abort_gone, abort_http_problem, abort_internal_error, abort_method_not_allowed, abort_not_acceptable, abort_not_found, abort_status, abort_unauthorized, random_key","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_async.html","id":null,"dir":"Reference","previous_headings":"","what":"Register an async evaluater — register_async","title":"Register an async evaluater — register_async","text":"plumber supports async request handling two ways. Either manual returning promise handler, automatic @async tag / async argument handler functions. default evaluater controlled plumber2.async option PLUMBER2_ASYNC environment variable.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_async.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register an async evaluater — register_async","text":"","code":"register_async(name, fun, dependency = NULL)  show_registered_async()  get_async(name = NULL, ...)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_async.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register an async evaluater — register_async","text":"name name evaluater fun function , upon calling returns evaluater taking expr envir argument. See async evaluater functions examples dependency Package dependencies evaluater. ... Arguments passed async function creator","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_parser.html","id":null,"dir":"Reference","previous_headings":"","what":"Register or fetch a parser — register_parser","title":"Register or fetch a parser — register_parser","text":"plumber2 comes many parsers cover almost standard use cases. Still might want provide , function facilitates.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_parser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register or fetch a parser — register_parser","text":"","code":"register_parser(name, fun, mime_types)  show_registered_parsers()  get_parsers(parsers = NULL)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_parser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register or fetch a parser — register_parser","text":"name name register parser function . already present current parser overwritten one provided fun function , called, returns binary function can parse request body. first argument takes raw vector binary encoding request body, second argument takes additional directives given requests Content-Type header mime_types One mime types parser can handle. mime types allowed contain wildcards, e.g. \"text/*\" parsers Parsers collect. can either character vector names registered parsers list. list following expectations apply: unnamed elements containing character vector considered names registered parsers constructed default values. special value \"...\" fetch parsers otherwise specified call element containing function considered provided parser element must named mime type parser understands (wildcards allowed) remaining named elements considered names registered parsers constructed arguments given element","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_parser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register or fetch a parser — register_parser","text":"get_parsers named list parser functions named mime types. order given parsers preserved.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_parser.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register or fetch a parser — register_parser","text":"want register parser, function register must factory function, ie. function returning function. returned function must accept two arguments, first raw vector corresponding request body, second parsed directives request Content-Type header. arguments factory function optional.","code":""},{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_serializer.html","id":null,"dir":"Reference","previous_headings":"","what":"Register or fetch a serializer — register_serializer","title":"Register or fetch a serializer — register_serializer","text":"plumber2 comes many serializers cover almost standard use cases. Still might want provide , function facilitates.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_serializer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register or fetch a serializer — register_serializer","text":"","code":"register_serializer(name, fun, mime_type)  show_registered_serializers()  get_serializers(serializers = NULL)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_serializer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register or fetch a serializer — register_serializer","text":"name name register serializer function . already present current serializer overwritten one provided fun function , called, returns unary function can serialize response body mime type defined mime_type mime_type format serializer creates. take care ensure value provided standard mime type format serializers Serializers collect. can either character vector names registered serializers list. list following expectations apply: unnamed elements containing character vector considered names registered serializers constructed default values. special value \"...\" fetch serializers otherwise specified call. element containing function considered provided serializer element must named mime type serializer understands remaining named elements considered names registered serializers constructed arguments given element","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_serializer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register or fetch a serializer — register_serializer","text":"get_serializers named list serializer functions named mime type. order given serializers preserved.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_serializer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register or fetch a serializer — register_serializer","text":"want register serializer, function register must factory function, ie. function returning function. returned function must accept single argument response body. arguments factory function optional.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/register_serializer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Register or fetch a serializer — register_serializer","text":"Using ... provide remaining graphics serializers graphics serializer explicitely requested elsewhere. Otherwise provide remaining non-graphics serializers. warning thrown mix graphics non-graphics serializers requested.","code":""},{"path":[]},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/serializers.html","id":null,"dir":"Reference","previous_headings":"","what":"Serializer functions provided by plumber2 — serializers","title":"Serializer functions provided by plumber2 — serializers","text":"functions cover large area potential response body formats. registered standard mime type users may want use register alternative types know makes sense.","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/serializers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serializer functions provided by plumber2 — serializers","text":"","code":"format_csv(...)  format_tsv(...)  format_rds(version = \"3\", ascii = FALSE, ...)  format_geojson(...)  format_feather(...)  format_parquet(...)  format_yaml(...)  format_htmlwidget(...)  format_format(..., sep = \"\\n\")  format_print(..., sep = \"\\n\")  format_cat(..., sep = \"\\n\")  format_unboxed(...)  format_png(...)  format_jpeg(...)  format_tiff(...)  format_svg(...)  format_bmp(...)  format_pdf(...)"},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/serializers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serializer functions provided by plumber2 — serializers","text":"... argument passed internal formatting function. See Details information function handles formatting internally serializer version workspace format version use.  NULL     specifies current default version (3). supported     value 2, default R 1.4.0 R 3.5.0. ascii logical.  TRUE NA, ASCII     representation written; otherwise (default) binary one.     See also comments help save. sep separator multiple elements","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/serializers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serializer functions provided by plumber2 — serializers","text":"function accepting response body","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/serializers.html","id":"provided-serializers","dir":"Reference","previous_headings":"","what":"Provided serializers","title":"Serializer functions provided by plumber2 — serializers","text":"format_csv() uses readr::format_csv() formatting. registered \"csv\" mime type text/csv format_tsv() uses readr::format_tsv() formatting. registered \"tsv\" mime type text/tsv format_rds() uses serialize() formatting. registered \"rds\" mime type application/rds format_geojson() uses geojsonsf::sfc_geojson() geojsonsf::sf_geojson() formatting depending class response body. registered \"geojson\" mime type application/geo+json format_feather() uses arrow::write_feather() formatting. registered \"feather\" mime type application/vnd.apache.arrow.file format_parquet() uses nanoparquet::write_parquet() formatting. registered \"parquet\" mime type application/vnd.apache.parquet format_yaml() uses yaml::.yaml() formatting. registered \"yaml\" mime type text/yaml format_htmlwidget() uses htmlwidgets::saveWidget() formatting. registered \"htmlwidget\" mime type text/html format_format() uses format() formatting. registered \"format\" mime type text/plain format_print() uses print() formatting. registered \"print\" mime type text/plain format_cat() uses cat() formatting. registered \"cat\" mime type text/plain format_unboxed() uses reqres::format_json() auto_unbox = TRUE formatting. registered \"unboxedJSON\" mime type application/json","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/serializers.html","id":"additional-registered-serializers","dir":"Reference","previous_headings":"","what":"Additional registered serializers","title":"Serializer functions provided by plumber2 — serializers","text":"reqres::format_json() registered \"json\" mime type application/json reqres::format_html() registered \"html\" mime type text/html reqres::format_xml() registered \"xml\" mime type text/xml reqres::format_plain() registered \"text\" mime type text/plain","code":""},{"path":"https://laughing-spoon-ywk3ewq.pages.github.io/reference/serializers.html","id":"provided-graphics-serializers","dir":"Reference","previous_headings":"","what":"Provided graphics serializers","title":"Serializer functions provided by plumber2 — serializers","text":"Serializing graphic output special requires operations handler executed. , handlers creating graphics expected side-effects (ie. call graphics rendering) returning ggplot2 object. want create graphics serializer use device_formatter() constructing . format_png() uses ragg::agg_png() rendering. registered \"png\" mime type image/png format_jpeg() uses ragg::agg_jpeg() rendering. registered \"jpeg\" mime type image/jpeg format_tiff() uses ragg::agg_tiff() rendering. registered \"tiff\" mime type image/tiff format_svg() uses svglite::svglite() rendering. registered \"svg\" mime type image/svg+xml format_bmp() uses grDevices::bmp() rendering. registered \"bmp\" mime type image/bmp format_pdf() uses grDevices::pdf() rendering. registered \"pdf\" mime type application/pdf","code":""},{"path":[]}]
