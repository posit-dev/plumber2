% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api_handlers.R
\name{api_request_handlers}
\alias{api_request_handlers}
\alias{api_get}
\alias{api_head}
\alias{api_post}
\alias{api_put}
\alias{api_delete}
\alias{api_connect}
\alias{api_options}
\alias{api_trace}
\alias{api_patch}
\alias{api_any}
\title{Add a handler for a request}
\usage{
api_get(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_head(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_post(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_put(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_delete(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_connect(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_options(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_trace(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_patch(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)

api_any(
  api,
  path,
  handler,
  serializers = NULL,
  parsers = NULL,
  use_strict_serializer = FALSE,
  download = FALSE,
  route = NULL,
  doc = NULL
)
}
\arguments{
\item{api}{A plumber2 api object to add the handler to}

\item{path}{A string giving the path the handler responds to. See Details}

\item{handler}{A handler function to call when a request is matched to the
path}

\item{serializers}{A named list of serializers that can be used to format the
response before sending it back to the client. Which one is selected is based
on the request \code{Accept} header. See \code{\link[=get_serializers]{get_serializers()}} for a helper to
construct this}

\item{parsers}{A named list of parsers that can be used to parse the
request body before passing it in as the \code{body} argument. Which one is
selected is based on the request \code{Content-Type} header. See \code{\link[=get_parsers]{get_parsers()}}
for a helper to construct this}

\item{use_strict_serializer}{By default, if a serializer that respects the
requests \code{Accept} header cannot be found, then the first of the provided ones
are used. Setting this to \code{TRUE} will instead send back a
\verb{406 Not Acceptable} response}

\item{download}{Should the response mark itself for download instead of being
shown inline? Setting this to \code{TRUE} will set the \code{Content-Disposition}
header in the response to \code{attachment}. Setting it to a string is equivalent
to setting it to \code{TRUE} but will in addition also set the default filename of
the download to the string value}

\item{route}{The route this handler should be added to. Defaults to the last
route in the stack. If the route does not exist it will be created as the
last route in the stack}

\item{doc}{A list with the OpenAPI spec for the endpoint}
}
\value{
These functions return the \code{api} object allowing for easy chaining
with the pipe
}
\description{
This family of functions facilitates adding a request handler for a specific
HTTP method and path.
}
\section{HTTP Methods}{
The HTTP specs provide a selection of specific methods that clients can send
to the server (your plumber api). While there is no enforcement that the
server follows any conventions you should strive to create a server API that
adheres to common expectations. It is not required that a server understands
all methods, most often the opposite is true. The HTTP methods are described
below, but consider consulting \href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods}{MDN}
to get acquainted with the HTTP spec in general
\itemize{
\item \code{GET}: This method is used to request specific content and is perhaps the
most ubiquitous method in use. \code{GET} requests should only retrieve data and
should not contain any body content
\item \code{HEAD}: This method is identical to \code{GET}, except the response should only
contain headers, no body. Apart from this it is expected that a \code{HEAD}
request is identical to a \code{GET} request for the same ressource
\item \code{POST}: This method delivers content, in the form of a request body, to the
server, potentially causing a change in the server. In the context of
plumber2 it is often used to call functions that require input larger than
what can be put in the URL
\item \code{PUT}: This method is used to update a specific ressource on the server. In
the context of a standard plumber2 server this is rarely relevant, though
usage can come up. \code{PUT} is considered by clients to be indemptotent meaning
that sending the same \code{PUT} request multiple times have no effect
\item \code{DELETE}: This method deletes a ressource and is the opposite to \code{PUT}. As
with \code{PUT} this method has limited use in most standard plumber2 servers
\item \code{CONNECT}: This method request the establishment of a proxy tunnel. It is
considered advanced use and is very unlikely to have a usecase for your
plumber2 api
\item \code{OPTIONS}: This method is used by clients to query a server about what
methods and other settings are supported on a server
\item \code{TRACE}: This method is a form of ping that should send a response
containing the request (stripped of any sensitive information). Many
servers disallow this method due to security concerns
\item \code{PATCH}: This method is like \code{PUT} but allows partial modification of a
ressource
}

Apart from the above, plumber2 also understands the \code{ANY} method which
responds to requests to any of the above methods, assuming that a specific
handler for the method is not found. As the semantics of the various methods
are quite different an \code{ANY} handler should mainly be used for rejections or
for setting specific broad headers on the response, not as the main handler
for the request
}

\section{The Path}{
The path defines the URL the request is being made to with the root removed.
If your plumber2 server runs from \verb{http://example.com/api/} and a request is
made to \verb{http://example.com/api/user/thomas/}, then the path would be
\verb{user/thomas/}. Paths can be static like the prior example, or dynamic as
described below:
\subsection{Path arguments}{

Consider you have a bunch of users. It would be impractical to register a
handler for each one of them. Instead you can use a dynamic path like with
the following syntax: \verb{user/<username>/}. This path would be matched to any
requests made to \verb{user/..something../}. The actual value of \code{..something..}
(e.g. \code{thomas}) would be made available to the handler (see below). A path
can contain multiple arguments if needed, such as
\verb{user/<username>/settings/<setting>/}
}

\subsection{Path wildcards}{

Apart from path arguments it is also possible to be even less specific by
adding a wildcard to the path. The path \verb{user/*} will match both
\verb{user/thomas/}, \verb{user/thomas/settings/interests/}, and anything other path
that begins with \verb{user/}. As with arguments a path can contain multiple
wildcards but the use of these have very diminishing returns. Contrary to
path arguments the value(s) corresponding to \code{*} is not made available to the
handler.
}

\subsection{Path Priority}{

With the existence of path arguments and wildcards it is possible that
multiple handlers in a route can be matched to a single request. Since only
one can be selected we need to determine which one wins. The priority is
based on the specificity of the path. Consider a server containing the
following handler paths: \verb{user/thomas/}, \verb{user/<username>/},
\verb{user/<username>/settings/<setting>/}, \verb{user/*}. These paths will have the
following priority:
\enumerate{
\item \verb{user/<username>/settings/<setting>/}
\item \verb{user/thomas/}
\item \verb{user/<username>/}
\item \verb{user/*}
}

The first spot is due to the fact that it is the path with the most elements
so it is deemed most specific. For the remaining 3 they all have the same
number of elements, but static paths are considered more specific than
dynamic paths, and path arguments are considered more specific than
wildcards.

A request made to \code{user/carl} will thus end up in the third handler, while a
request made to \code{user/thomas} will end up in the second. This ordering makes
it possible to both provide default handlers as well as specialisations for
specific paths.
}
}

\section{The Handler}{
The handler is a standard R function that is called when a request is made
that matches the handlers path (unless a more specific handler path exists â€”
see above). A handler function can perform any operation a normal R function
can do, though you should consider strongly the security implications of your
handler functions. However, there are certain expectations in plumber around
the arguments a handler function takes and the return value it provides
\subsection{Handler Arguments}{

The handler function can take one or more of the following arguments.
\itemize{
\item \strong{Path arguments}: Any path arguments are passed on to the handler. If a
handler is registered for the following path
\verb{user/<username>/settings/<setting>/} and it handles a request to
\verb{user/thomas/settings/interests/} then it will be called with
\verb{username = "thomas", setting = "interest"}
\item \code{request}: The request the handler is responding to as a \link[reqres:Request]{reqres::Request}
object
\item \code{response}: The response being returned to the client as a
\link[reqres:Response]{reqres::Response} object
\item \code{server}: The \link{Plumber} object representing your server implementation
\item \code{client_id}: A string uniquely identifying the session the request comes
from
\item \code{query}: A list giving any additional arguments passed into the handler as
part of the url query string
\item \code{body}: The request body, parsed as specified by the provided parsers
}
}

\subsection{Handler Return Value}{

Handlers can return a range of different value types, which will inform
plumber2 what to do next:
\subsection{Returning \code{Next} or \code{Break}}{

These two control objects informs plumber2 to either proceed handling the
request (\code{Next}) or return the response as is, circumventing any remaining
routes (\code{Break})
}

\subsection{Returning \code{NULL} or the \code{response} object}{

This is the same as returning \code{Next}, ie. it signals that handling can
proceed
}

\subsection{Returning a ggplot2 object}{

If you return a ggplot2 object it will get plotted for you (and added to the
response assuming a graphics serializer is provided) before handling
continues
}

\subsection{Returning any other value}{

Any kind of value returned that is not captured by the above description will
be set to the response body (overwritting what was already there) and
handling is then allowed to continue
}

}
}

\seealso{
Other Request Handlers: 
\code{\link{api_request_header_handlers}}
}
\concept{Request Handlers}
